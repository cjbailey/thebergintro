// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"bq5lJ":[function(require,module,exports) {
"use strict";
var HMR_HOST = null;
var HMR_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "5c1b77e3b71e74eb";
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('ðŸš¨ [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] ðŸš¨ Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] âœ¨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>ðŸ’¡ ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                var oldDeps = modules[asset.id][1];
                for(var dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    var id = oldDeps[dep];
                    var parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    var modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        var deps = modules[id1][1];
        var orphans = [];
        for(var dep in deps){
            var parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach(function(id) {
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    var parents = getParents(module.bundle.root, id);
    var accepted = false;
    while(parents.length > 0){
        var v = parents.shift();
        var a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            var p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push.apply(parents, _toConsumableArray(p));
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"h7u1C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _babelPolyfill = require("babel-polyfill");
var _common = require("./common");
var _game = require("./Game");
var _gameDefault = parcelHelpers.interopDefault(_game);
document.addEventListener("DOMContentLoaded", ()=>{
    _gameDefault.default(document.getElementById("container")).then((args)=>{
        window.game = {
            ...args
        };
        document.getElementById("container").style.display = "block";
        let coverText = document.getElementsByClassName("cover-text")[0];
        let loader = document.getElementsByClassName("loader")[0];
        if (coverText) coverText.style.display = "block";
        if (loader) loader.remove();
    });
});

},{"babel-polyfill":"7LKiE","./common":"8wzUn","./Game":"TyEjs","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"7LKiE":[function(require,module,exports) {
"use strict";
var global = arguments[3];
require("core-js/shim");
require("regenerator-runtime/runtime");
require("core-js/fn/regexp/escape");
if (global._babelPolyfill) throw new Error("only one instance of babel-polyfill is allowed");
global._babelPolyfill = true;
var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
    O[key] || Object[DEFINE_PROPERTY](O, key, {
        writable: true,
        configurable: true,
        value: value
    });
}
define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);
"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(key) {
    [][key] && define(Array, key, Function.call.bind([][key]));
});

},{"core-js/shim":"7GhG8","regenerator-runtime/runtime":"dXNgZ","core-js/fn/regexp/escape":"4Rfsd"}],"7GhG8":[function(require,module,exports) {
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.exec');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.array.flat-map');
require('./modules/es7.array.flatten');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.map.of');
require('./modules/es7.set.of');
require('./modules/es7.weak-map.of');
require('./modules/es7.weak-set.of');
require('./modules/es7.map.from');
require('./modules/es7.set.from');
require('./modules/es7.weak-map.from');
require('./modules/es7.weak-set.from');
require('./modules/es7.global');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.clamp');
require('./modules/es7.math.deg-per-rad');
require('./modules/es7.math.degrees');
require('./modules/es7.math.fscale');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.rad-per-deg');
require('./modules/es7.math.radians');
require('./modules/es7.math.scale');
require('./modules/es7.math.umulh');
require('./modules/es7.math.signbit');
require('./modules/es7.promise.finally');
require('./modules/es7.promise.try');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');

},{"./modules/es6.symbol":"fUQxd","./modules/es6.object.create":"iklZv","./modules/es6.object.define-property":"2JxTY","./modules/es6.object.define-properties":"1cFbl","./modules/es6.object.get-own-property-descriptor":"5sxjB","./modules/es6.object.get-prototype-of":"5fsye","./modules/es6.object.keys":"8woaa","./modules/es6.object.get-own-property-names":"dGCli","./modules/es6.object.freeze":"cb5HM","./modules/es6.object.seal":"j3qY2","./modules/es6.object.prevent-extensions":"2KuMq","./modules/es6.object.is-frozen":"GTKvk","./modules/es6.object.is-sealed":"K45hu","./modules/es6.object.is-extensible":"23gjD","./modules/es6.object.assign":"8DvpM","./modules/es6.object.is":"e23no","./modules/es6.object.set-prototype-of":"d3fGn","./modules/es6.object.to-string":"7cLOk","./modules/es6.function.bind":"54Dqr","./modules/es6.function.name":"lmg4B","./modules/es6.function.has-instance":"flBdS","./modules/es6.parse-int":"l30ZK","./modules/es6.parse-float":"edHLy","./modules/es6.number.constructor":"b3DG0","./modules/es6.number.to-fixed":"jVWO1","./modules/es6.number.to-precision":"fkTCt","./modules/es6.number.epsilon":"dS5u0","./modules/es6.number.is-finite":"gaJ9D","./modules/es6.number.is-integer":"cXfOC","./modules/es6.number.is-nan":"dHEdL","./modules/es6.number.is-safe-integer":"8WZJi","./modules/es6.number.max-safe-integer":"lEoVS","./modules/es6.number.min-safe-integer":"6GYXq","./modules/es6.number.parse-float":"adyPr","./modules/es6.number.parse-int":"cz541","./modules/es6.math.acosh":"atazc","./modules/es6.math.asinh":"9vCFA","./modules/es6.math.atanh":"1Poi7","./modules/es6.math.cbrt":"kEyNP","./modules/es6.math.clz32":"asnnc","./modules/es6.math.cosh":"672oR","./modules/es6.math.expm1":"eLul3","./modules/es6.math.fround":"6JW0t","./modules/es6.math.hypot":"1rcXM","./modules/es6.math.imul":"lAxVU","./modules/es6.math.log10":"fIjzt","./modules/es6.math.log1p":"kK15h","./modules/es6.math.log2":"kkgGM","./modules/es6.math.sign":"18Gp0","./modules/es6.math.sinh":"bkULm","./modules/es6.math.tanh":"br08o","./modules/es6.math.trunc":"8fixj","./modules/es6.string.from-code-point":"gsGce","./modules/es6.string.raw":"4MADL","./modules/es6.string.trim":"hEKob","./modules/es6.string.iterator":"llgDB","./modules/es6.string.code-point-at":"doYwG","./modules/es6.string.ends-with":"39nwy","./modules/es6.string.includes":"9JmYp","./modules/es6.string.repeat":"cqBCd","./modules/es6.string.starts-with":"iMejr","./modules/es6.string.anchor":"97Lll","./modules/es6.string.big":"7nKCA","./modules/es6.string.blink":"jbxAT","./modules/es6.string.bold":"4MfGp","./modules/es6.string.fixed":"4y2Bb","./modules/es6.string.fontcolor":"lmhCi","./modules/es6.string.fontsize":"hL89C","./modules/es6.string.italics":"iwOAc","./modules/es6.string.link":"e07IC","./modules/es6.string.small":"2MSNU","./modules/es6.string.strike":"8kiXd","./modules/es6.string.sub":"iprh9","./modules/es6.string.sup":"doHpa","./modules/es6.date.now":"4HGro","./modules/es6.date.to-json":"7Glbw","./modules/es6.date.to-iso-string":"hQdLT","./modules/es6.date.to-string":"d3yLX","./modules/es6.date.to-primitive":"hoeNq","./modules/es6.array.is-array":"5g48E","./modules/es6.array.from":"i3Nvz","./modules/es6.array.of":"aLmME","./modules/es6.array.join":"lQMhQ","./modules/es6.array.slice":"4E6IU","./modules/es6.array.sort":"lAyeU","./modules/es6.array.for-each":"7cxLy","./modules/es6.array.map":"j4ARR","./modules/es6.array.filter":"5vJuE","./modules/es6.array.some":"iKQGA","./modules/es6.array.every":"5xxJY","./modules/es6.array.reduce":"8tM5y","./modules/es6.array.reduce-right":"aNHFx","./modules/es6.array.index-of":"76kRN","./modules/es6.array.last-index-of":"lEw3U","./modules/es6.array.copy-within":"4xbJW","./modules/es6.array.fill":"bimjQ","./modules/es6.array.find":"cKonp","./modules/es6.array.find-index":"t506G","./modules/es6.array.species":"2S6HD","./modules/es6.array.iterator":"1xhrt","./modules/es6.regexp.constructor":"gc5Or","./modules/es6.regexp.exec":"fcvkD","./modules/es6.regexp.to-string":"aX2Wn","./modules/es6.regexp.flags":"4cXUu","./modules/es6.regexp.match":"93slC","./modules/es6.regexp.replace":"bsjVi","./modules/es6.regexp.search":"ldewt","./modules/es6.regexp.split":"iJScv","./modules/es6.promise":"2sSjP","./modules/es6.map":"1kXi9","./modules/es6.set":"61Y2Y","./modules/es6.weak-map":"dAOwL","./modules/es6.weak-set":"blRp6","./modules/es6.typed.array-buffer":"dp2Nn","./modules/es6.typed.data-view":"FLhcC","./modules/es6.typed.int8-array":"2PtAR","./modules/es6.typed.uint8-array":"g4j5m","./modules/es6.typed.uint8-clamped-array":"68vHx","./modules/es6.typed.int16-array":"iZyZL","./modules/es6.typed.uint16-array":"4Jyn3","./modules/es6.typed.int32-array":"dSRiX","./modules/es6.typed.uint32-array":"lKCGR","./modules/es6.typed.float32-array":"fASXR","./modules/es6.typed.float64-array":"e3YAQ","./modules/es6.reflect.apply":"kstrm","./modules/es6.reflect.construct":"fXcT1","./modules/es6.reflect.define-property":"kibOK","./modules/es6.reflect.delete-property":"2NlGq","./modules/es6.reflect.enumerate":"iKC7x","./modules/es6.reflect.get":"dIqbe","./modules/es6.reflect.get-own-property-descriptor":"lSfAN","./modules/es6.reflect.get-prototype-of":"aO9N4","./modules/es6.reflect.has":"4HzcT","./modules/es6.reflect.is-extensible":"dmYlo","./modules/es6.reflect.own-keys":"15duj","./modules/es6.reflect.prevent-extensions":"cC4pR","./modules/es6.reflect.set":"dl5fS","./modules/es6.reflect.set-prototype-of":"jH9nI","./modules/es7.array.includes":"9KPxe","./modules/es7.array.flat-map":"lKIEm","./modules/es7.array.flatten":"lpb4z","./modules/es7.string.at":"eVq5h","./modules/es7.string.pad-start":"kxeDX","./modules/es7.string.pad-end":"6j6XE","./modules/es7.string.trim-left":"4dYUb","./modules/es7.string.trim-right":"5yndh","./modules/es7.string.match-all":"cZhYH","./modules/es7.symbol.async-iterator":"8vHXs","./modules/es7.symbol.observable":"jDpxk","./modules/es7.object.get-own-property-descriptors":"k5woh","./modules/es7.object.values":"kQJLQ","./modules/es7.object.entries":"7zW9M","./modules/es7.object.define-getter":"92ysW","./modules/es7.object.define-setter":"emt8A","./modules/es7.object.lookup-getter":"9LH3Q","./modules/es7.object.lookup-setter":"kEN8G","./modules/es7.map.to-json":"7iBxS","./modules/es7.set.to-json":"exanP","./modules/es7.map.of":"dT1Dc","./modules/es7.set.of":"jSRTa","./modules/es7.weak-map.of":"39wfA","./modules/es7.weak-set.of":"ikieO","./modules/es7.map.from":"2MGKl","./modules/es7.set.from":"3AF6v","./modules/es7.weak-map.from":"23jtR","./modules/es7.weak-set.from":"hJc4O","./modules/es7.global":"lshq0","./modules/es7.system.global":"aLRNx","./modules/es7.error.is-error":"3xhVh","./modules/es7.math.clamp":"bZ0NA","./modules/es7.math.deg-per-rad":"gOGEZ","./modules/es7.math.degrees":"cdQDY","./modules/es7.math.fscale":"fR5LK","./modules/es7.math.iaddh":"5Jbi2","./modules/es7.math.isubh":"hrxFs","./modules/es7.math.imulh":"i4YiT","./modules/es7.math.rad-per-deg":"il4w2","./modules/es7.math.radians":"7RQmX","./modules/es7.math.scale":"jOPwg","./modules/es7.math.umulh":"8NRee","./modules/es7.math.signbit":"ePksm","./modules/es7.promise.finally":"2JMTL","./modules/es7.promise.try":"2RsT8","./modules/es7.reflect.define-metadata":"iQ9qT","./modules/es7.reflect.delete-metadata":"4glRb","./modules/es7.reflect.get-metadata":"kmvi8","./modules/es7.reflect.get-metadata-keys":"6bA9p","./modules/es7.reflect.get-own-metadata":"jebxh","./modules/es7.reflect.get-own-metadata-keys":"jGnWP","./modules/es7.reflect.has-metadata":"bZiK8","./modules/es7.reflect.has-own-metadata":"khZMr","./modules/es7.reflect.metadata":"dQNHX","./modules/es7.asap":"eXG8y","./modules/es7.observable":"dqE8O","./modules/web.timers":"dl3SO","./modules/web.immediate":"49tUX","./modules/web.dom.iterable":"iv8Qo","./modules/_core":"4o9Ko"}],"fUQxd":[function(require,module,exports) {
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toObject = require('./_to-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $GOPS = require('./_object-gops');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function() {
    return _create(dP({}, 'a', {
        get: function() {
            return dP(this, 'a', {
                value: 7
            }).a;
        }
    })).a != 7;
}) ? function(it, key, D) {
    var protoDesc = gOPD(ObjectProto, key);
    if (protoDesc) delete ObjectProto[key];
    dP(it, key, D);
    if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;
var wrap = function(tag) {
    var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
    sym._k = tag;
    return sym;
};
var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it) {
    return typeof it == 'symbol';
} : function(it) {
    return it instanceof $Symbol;
};
var $defineProperty = function defineProperty(it, key, D) {
    if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
    anObject(it);
    key = toPrimitive(key, true);
    anObject(D);
    if (has(AllSymbols, key)) {
        if (!D.enumerable) {
            if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
            it[HIDDEN][key] = true;
        } else {
            if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
            D = _create(D, {
                enumerable: createDesc(0, false)
            });
        }
        return setSymbolDesc(it, key, D);
    }
    return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
    anObject(it);
    var keys = enumKeys(P = toIObject(P));
    var i = 0;
    var l = keys.length;
    var key;
    while(l > i)$defineProperty(it, key = keys[i++], P[key]);
    return it;
};
var $create = function create(it, P) {
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key = toPrimitive(key, true));
    if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    it = toIObject(it);
    key = toPrimitive(key, true);
    if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
    var D = gOPD(it, key);
    if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
    return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = gOPN(toIObject(it));
    var result = [];
    var i = 0;
    var key;
    while(names.length > i)if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
    return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var IS_OP = it === ObjectProto;
    var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
    var result = [];
    var i = 0;
    var key;
    while(names.length > i)if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
    return result;
};
// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
    $Symbol = function Symbol() {
        if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
        var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
        var $set = function(value) {
            if (this === ObjectProto) $set.call(OPSymbols, value);
            if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
            setSymbolDesc(this, tag, createDesc(1, value));
        };
        if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
            configurable: true,
            set: $set
        });
        return wrap(tag);
    };
    redefine($Symbol[PROTOTYPE], 'toString', function toString() {
        return this._k;
    });
    $GOPD.f = $getOwnPropertyDescriptor;
    $DP.f = $defineProperty;
    require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
    require('./_object-pie').f = $propertyIsEnumerable;
    $GOPS.f = $getOwnPropertySymbols;
    if (DESCRIPTORS && !require('./_library')) redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    wksExt.f = function(name) {
        return wrap(wks(name));
    };
}
$export($export.G + $export.W + $export.F * !USE_NATIVE, {
    Symbol: $Symbol
});
for(var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);
for(var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;)wksDefine(wellKnownSymbols[k++]);
$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
    // 19.4.2.1 Symbol.for(key)
    'for': function(key) {
        return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
    },
    // 19.4.2.5 Symbol.keyFor(sym)
    keyFor: function keyFor(sym) {
        if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
        for(var key in SymbolRegistry)if (SymbolRegistry[key] === sym) return key;
    },
    useSetter: function() {
        setter = true;
    },
    useSimple: function() {
        setter = false;
    }
});
$export($export.S + $export.F * !USE_NATIVE, 'Object', {
    // 19.1.2.2 Object.create(O [, Properties])
    create: $create,
    // 19.1.2.4 Object.defineProperty(O, P, Attributes)
    defineProperty: $defineProperty,
    // 19.1.2.3 Object.defineProperties(O, Properties)
    defineProperties: $defineProperties,
    // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    // 19.1.2.7 Object.getOwnPropertyNames(O)
    getOwnPropertyNames: $getOwnPropertyNames,
    // 19.1.2.8 Object.getOwnPropertySymbols(O)
    getOwnPropertySymbols: $getOwnPropertySymbols
});
// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function() {
    $GOPS.f(1);
});
$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
    getOwnPropertySymbols: function getOwnPropertySymbols(it) {
        return $GOPS.f(toObject(it));
    }
});
// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
    var S = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    // WebKit converts symbol values to JSON as null
    // V8 throws on boxed symbols
    return _stringify([
        S
    ]) != '[null]' || _stringify({
        a: S
    }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
    stringify: function stringify(it) {
        var args = [
            it
        ];
        var i = 1;
        var replacer, $replacer;
        while(arguments.length > i)args.push(arguments[i++]);
        $replacer = replacer = args[1];
        if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
        if (!isArray(replacer)) replacer = function(key, value) {
            if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
            if (!isSymbol(value)) return value;
        };
        args[1] = replacer;
        return _stringify.apply($JSON, args);
    }
});
// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_global":"8xCse","./_has":"biQ7v","./_descriptors":"dr2tY","./_export":"1Tgvm","./_redefine":"9vAu7","./_meta":"043Qa","./_fails":"iAFH1","./_shared":"9XC5J","./_set-to-string-tag":"7YXlq","./_uid":"gBq6n","./_wks":"eaoKZ","./_wks-ext":"2dxMf","./_wks-define":"28rGc","./_enum-keys":"c7wJO","./_is-array":"dTLRt","./_an-object":"kiL2X","./_is-object":"eIE5K","./_to-object":"7HHXi","./_to-iobject":"f9RCz","./_to-primitive":"4Oubb","./_property-desc":"825qY","./_object-create":"b4m8n","./_object-gopn-ext":"2is9e","./_object-gopd":"4bAUG","./_object-gops":"5oH2C","./_object-dp":"cLcWd","./_object-keys":"98CC0","./_object-gopn":"jK0Om","./_object-pie":"2aUxV","./_library":"lmtqY","./_hide":"ddpVq"}],"8xCse":[function(require,module,exports) {
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],"biQ7v":[function(require,module,exports) {
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
};

},{}],"dr2tY":[function(require,module,exports) {
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function() {
    return Object.defineProperty({}, 'a', {
        get: function() {
            return 7;
        }
    }).a != 7;
});

},{"./_fails":"iAFH1"}],"iAFH1":[function(require,module,exports) {
module.exports = function(exec) {
    try {
        return !!exec();
    } catch (e) {
        return true;
    }
};

},{}],"1Tgvm":[function(require,module,exports) {
var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';
var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
    var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
    var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
    var key, own, out, exp;
    if (IS_GLOBAL) source = name;
    for(key in source){
        // contains in native
        own = !IS_FORCED && target && target[key] !== undefined;
        // export native or passed
        out = (own ? target : source)[key];
        // bind timers to global for call from export context
        exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
        // extend global
        if (target) redefine(target, key, out, type & $export.U);
        // export
        if (exports[key] != out) hide(exports, key, exp);
        if (IS_PROTO && expProto[key] != out) expProto[key] = out;
    }
};
global.core = core;
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_global":"8xCse","./_core":"4o9Ko","./_hide":"ddpVq","./_redefine":"9vAu7","./_ctx":"4rQSm"}],"4o9Ko":[function(require,module,exports) {
var core = module.exports = {
    version: '2.6.9'
};
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],"ddpVq":[function(require,module,exports) {
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value) {
    return dP.f(object, key, createDesc(1, value));
} : function(object, key, value) {
    object[key] = value;
    return object;
};

},{"./_object-dp":"cLcWd","./_property-desc":"825qY","./_descriptors":"dr2tY"}],"cLcWd":[function(require,module,exports) {
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;
exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if (IE8_DOM_DEFINE) try {
        return dP(O, P, Attributes);
    } catch (e) {}
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
};

},{"./_an-object":"kiL2X","./_ie8-dom-define":"cIJOj","./_to-primitive":"4Oubb","./_descriptors":"dr2tY"}],"kiL2X":[function(require,module,exports) {
var isObject = require('./_is-object');
module.exports = function(it) {
    if (!isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
};

},{"./_is-object":"eIE5K"}],"eIE5K":[function(require,module,exports) {
module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],"cIJOj":[function(require,module,exports) {
module.exports = !require('./_descriptors') && !require('./_fails')(function() {
    return Object.defineProperty(require('./_dom-create')('div'), 'a', {
        get: function() {
            return 7;
        }
    }).a != 7;
});

},{"./_descriptors":"dr2tY","./_fails":"iAFH1","./_dom-create":"2qBag"}],"2qBag":[function(require,module,exports) {
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function(it) {
    return is ? document.createElement(it) : {};
};

},{"./_is-object":"eIE5K","./_global":"8xCse"}],"4Oubb":[function(require,module,exports) {
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S) {
    if (!isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":"eIE5K"}],"825qY":[function(require,module,exports) {
module.exports = function(bitmap, value) {
    return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
    };
};

},{}],"9vAu7":[function(require,module,exports) {
var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var $toString = require('./_function-to-string');
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);
require('./_core').inspectSource = function(it) {
    return $toString.call(it);
};
(module.exports = function(O, key, val, safe) {
    var isFunction = typeof val == 'function';
    if (isFunction) has(val, 'name') || hide(val, 'name', key);
    if (O[key] === val) return;
    if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
    if (O === global) O[key] = val;
    else if (!safe) {
        delete O[key];
        hide(O, key, val);
    } else if (O[key]) O[key] = val;
    else hide(O, key, val);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_global":"8xCse","./_hide":"ddpVq","./_has":"biQ7v","./_uid":"gBq6n","./_function-to-string":"5IPoO","./_core":"4o9Ko"}],"gBq6n":[function(require,module,exports) {
var id = 0;
var px = Math.random();
module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],"5IPoO":[function(require,module,exports) {
module.exports = require('./_shared')('native-function-to-string', Function.toString);

},{"./_shared":"9XC5J"}],"9XC5J":[function(require,module,exports) {
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
(module.exports = function(key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
    version: core.version,
    mode: require('./_library') ? 'pure' : 'global',
    copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":"4o9Ko","./_global":"8xCse","./_library":"lmtqY"}],"lmtqY":[function(require,module,exports) {
module.exports = false;

},{}],"4rQSm":[function(require,module,exports) {
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;
    switch(length){
        case 1:
            return function(a) {
                return fn.call(that, a);
            };
        case 2:
            return function(a, b) {
                return fn.call(that, a, b);
            };
        case 3:
            return function(a, b, c) {
                return fn.call(that, a, b, c);
            };
    }
    return function() {
        return fn.apply(that, arguments);
    };
};

},{"./_a-function":"55L9l"}],"55L9l":[function(require,module,exports) {
module.exports = function(it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
};

},{}],"043Qa":[function(require,module,exports) {
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function() {
    return true;
};
var FREEZE = !require('./_fails')(function() {
    return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it) {
    setDesc(it, META, {
        value: {
            i: 'O' + ++id,
            w: {} // weak collections IDs
        }
    });
};
var fastKey = function(it, create) {
    // return primitive with prefix
    if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!has(it, META)) {
        // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return 'F';
        // not necessary to add metadata
        if (!create) return 'E';
        // add missing metadata
        setMeta(it);
    // return object ID
    }
    return it[META].i;
};
var getWeak = function(it, create) {
    if (!has(it, META)) {
        // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return true;
        // not necessary to add metadata
        if (!create) return false;
        // add missing metadata
        setMeta(it);
    // return hash weak collections IDs
    }
    return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it) {
    if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
    return it;
};
var meta = module.exports = {
    KEY: META,
    NEED: false,
    fastKey: fastKey,
    getWeak: getWeak,
    onFreeze: onFreeze
};

},{"./_uid":"gBq6n","./_is-object":"eIE5K","./_has":"biQ7v","./_object-dp":"cLcWd","./_fails":"iAFH1"}],"7YXlq":[function(require,module,exports) {
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');
module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
        configurable: true,
        value: tag
    });
};

},{"./_object-dp":"cLcWd","./_has":"biQ7v","./_wks":"eaoKZ"}],"eaoKZ":[function(require,module,exports) {
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';
var $exports = module.exports = function(name) {
    return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};
$exports.store = store;

},{"./_shared":"9XC5J","./_uid":"gBq6n","./_global":"8xCse"}],"2dxMf":[function(require,module,exports) {
exports.f = require('./_wks');

},{"./_wks":"eaoKZ"}],"28rGc":[function(require,module,exports) {
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function(name) {
    var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
    if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
        value: wksExt.f(name)
    });
};

},{"./_global":"8xCse","./_core":"4o9Ko","./_library":"lmtqY","./_wks-ext":"2dxMf","./_object-dp":"cLcWd"}],"c7wJO":[function(require,module,exports) {
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function(it) {
    var result = getKeys(it);
    var getSymbols = gOPS.f;
    if (getSymbols) {
        var symbols = getSymbols(it);
        var isEnum = pIE.f;
        var i = 0;
        var key;
        while(symbols.length > i)if (isEnum.call(it, key = symbols[i++])) result.push(key);
    }
    return result;
};

},{"./_object-keys":"98CC0","./_object-gops":"5oH2C","./_object-pie":"2aUxV"}],"98CC0":[function(require,module,exports) {
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');
module.exports = Object.keys || function keys(O) {
    return $keys(O, enumBugKeys);
};

},{"./_object-keys-internal":"x7vs4","./_enum-bug-keys":"NGsf4"}],"x7vs4":[function(require,module,exports) {
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');
module.exports = function(object, names) {
    var O = toIObject(object);
    var i = 0;
    var result = [];
    var key;
    for(key in O)if (key != IE_PROTO) has(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while(names.length > i)if (has(O, key = names[i++])) ~arrayIndexOf(result, key) || result.push(key);
    return result;
};

},{"./_has":"biQ7v","./_to-iobject":"f9RCz","./_array-includes":"1Ebaw","./_shared-key":"kPb7V"}],"f9RCz":[function(require,module,exports) {
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function(it) {
    return IObject(defined(it));
};

},{"./_iobject":"24JwK","./_defined":"4Lj5U"}],"24JwK":[function(require,module,exports) {
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":"frIbo"}],"frIbo":[function(require,module,exports) {
var toString = {}.toString;
module.exports = function(it) {
    return toString.call(it).slice(8, -1);
};

},{}],"4Lj5U":[function(require,module,exports) {
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
};

},{}],"1Ebaw":[function(require,module,exports) {
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
        var O = toIObject($this);
        var length = toLength(O.length);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        // Array#includes uses SameValueZero equality algorithm
        // eslint-disable-next-line no-self-compare
        if (IS_INCLUDES && el != el) while(length > index){
            value = O[index++];
            // eslint-disable-next-line no-self-compare
            if (value != value) return true;
        // Array#indexOf ignores holes, Array#includes - not
        }
        else for(; length > index; index++)if (IS_INCLUDES || index in O) {
            if (O[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
    };
};

},{"./_to-iobject":"f9RCz","./_to-length":"irYfS","./_to-absolute-index":"1lPjf"}],"irYfS":[function(require,module,exports) {
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 9007199254740991) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":"cb0GT"}],"cb0GT":[function(require,module,exports) {
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],"1lPjf":[function(require,module,exports) {
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function(index, length) {
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":"cb0GT"}],"kPb7V":[function(require,module,exports) {
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function(key) {
    return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":"9XC5J","./_uid":"gBq6n"}],"NGsf4":[function(require,module,exports) {
// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

},{}],"5oH2C":[function(require,module,exports) {
exports.f = Object.getOwnPropertySymbols;

},{}],"2aUxV":[function(require,module,exports) {
exports.f = ({}).propertyIsEnumerable;

},{}],"dTLRt":[function(require,module,exports) {
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
    return cof(arg) == 'Array';
};

},{"./_cof":"frIbo"}],"7HHXi":[function(require,module,exports) {
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function(it) {
    return Object(defined(it));
};

},{"./_defined":"4Lj5U"}],"b4m8n":[function(require,module,exports) {
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function() {};
var PROTOTYPE = 'prototype';
// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function() {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = require('./_dom-create')('iframe');
    var i = enumBugKeys.length;
    var lt = '<';
    var gt = '>';
    var iframeDocument;
    iframe.style.display = 'none';
    require('./_html').appendChild(iframe);
    iframe.src = 'javascript:'; // eslint-disable-line no-script-url
    // createDict = iframe.contentWindow.Object;
    // html.removeChild(iframe);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
    return createDict();
};
module.exports = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
        Empty[PROTOTYPE] = anObject(O);
        result = new Empty();
        Empty[PROTOTYPE] = null;
        // add "__proto__" for Object.getPrototypeOf polyfill
        result[IE_PROTO] = O;
    } else result = createDict();
    return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":"kiL2X","./_object-dps":"8EUaM","./_enum-bug-keys":"NGsf4","./_shared-key":"kPb7V","./_dom-create":"2qBag","./_html":"lPhWk"}],"8EUaM":[function(require,module,exports) {
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');
module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var keys = getKeys(Properties);
    var length = keys.length;
    var i = 0;
    var P;
    while(length > i)dP.f(O, P = keys[i++], Properties[P]);
    return O;
};

},{"./_object-dp":"cLcWd","./_an-object":"kiL2X","./_object-keys":"98CC0","./_descriptors":"dr2tY"}],"lPhWk":[function(require,module,exports) {
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":"8xCse"}],"2is9e":[function(require,module,exports) {
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
var getWindowNames = function(it) {
    try {
        return gOPN(it);
    } catch (e) {
        return windowNames.slice();
    }
};
module.exports.f = function getOwnPropertyNames(it) {
    return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_to-iobject":"f9RCz","./_object-gopn":"jK0Om"}],"jK0Om":[function(require,module,exports) {
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return $keys(O, hiddenKeys);
};

},{"./_object-keys-internal":"x7vs4","./_enum-bug-keys":"NGsf4"}],"4bAUG":[function(require,module,exports) {
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;
exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
    O = toIObject(O);
    P = toPrimitive(P, true);
    if (IE8_DOM_DEFINE) try {
        return gOPD(O, P);
    } catch (e) {}
    if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_object-pie":"2aUxV","./_property-desc":"825qY","./_to-iobject":"f9RCz","./_to-primitive":"4Oubb","./_has":"biQ7v","./_ie8-dom-define":"cIJOj","./_descriptors":"dr2tY"}],"iklZv":[function(require,module,exports) {
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {
    create: require('./_object-create')
});

},{"./_export":"1Tgvm","./_object-create":"b4m8n"}],"2JxTY":[function(require,module,exports) {
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {
    defineProperty: require('./_object-dp').f
});

},{"./_export":"1Tgvm","./_descriptors":"dr2tY","./_object-dp":"cLcWd"}],"1cFbl":[function(require,module,exports) {
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {
    defineProperties: require('./_object-dps')
});

},{"./_export":"1Tgvm","./_descriptors":"dr2tY","./_object-dps":"8EUaM"}],"5sxjB":[function(require,module,exports) {
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;
require('./_object-sap')('getOwnPropertyDescriptor', function() {
    return function getOwnPropertyDescriptor(it, key) {
        return $getOwnPropertyDescriptor(toIObject(it), key);
    };
});

},{"./_to-iobject":"f9RCz","./_object-gopd":"4bAUG","./_object-sap":"fgwTp"}],"fgwTp":[function(require,module,exports) {
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function(KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY];
    var exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function() {
        fn(1);
    }), 'Object', exp);
};

},{"./_export":"1Tgvm","./_core":"4o9Ko","./_fails":"iAFH1"}],"5fsye":[function(require,module,exports) {
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');
require('./_object-sap')('getPrototypeOf', function() {
    return function getPrototypeOf(it) {
        return $getPrototypeOf(toObject(it));
    };
});

},{"./_to-object":"7HHXi","./_object-gpo":"4uFAD","./_object-sap":"fgwTp"}],"4uFAD":[function(require,module,exports) {
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;
module.exports = Object.getPrototypeOf || function(O) {
    O = toObject(O);
    if (has(O, IE_PROTO)) return O[IE_PROTO];
    if (typeof O.constructor == 'function' && O instanceof O.constructor) return O.constructor.prototype;
    return O instanceof Object ? ObjectProto : null;
};

},{"./_has":"biQ7v","./_to-object":"7HHXi","./_shared-key":"kPb7V"}],"8woaa":[function(require,module,exports) {
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');
require('./_object-sap')('keys', function() {
    return function keys(it) {
        return $keys(toObject(it));
    };
});

},{"./_to-object":"7HHXi","./_object-keys":"98CC0","./_object-sap":"fgwTp"}],"dGCli":[function(require,module,exports) {
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function() {
    return require('./_object-gopn-ext').f;
});

},{"./_object-sap":"fgwTp","./_object-gopn-ext":"2is9e"}],"cb5HM":[function(require,module,exports) {
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;
require('./_object-sap')('freeze', function($freeze) {
    return function freeze(it) {
        return $freeze && isObject(it) ? $freeze(meta(it)) : it;
    };
});

},{"./_is-object":"eIE5K","./_meta":"043Qa","./_object-sap":"fgwTp"}],"j3qY2":[function(require,module,exports) {
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;
require('./_object-sap')('seal', function($seal) {
    return function seal(it) {
        return $seal && isObject(it) ? $seal(meta(it)) : it;
    };
});

},{"./_is-object":"eIE5K","./_meta":"043Qa","./_object-sap":"fgwTp"}],"2KuMq":[function(require,module,exports) {
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;
require('./_object-sap')('preventExtensions', function($preventExtensions) {
    return function preventExtensions(it) {
        return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
    };
});

},{"./_is-object":"eIE5K","./_meta":"043Qa","./_object-sap":"fgwTp"}],"GTKvk":[function(require,module,exports) {
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');
require('./_object-sap')('isFrozen', function($isFrozen) {
    return function isFrozen(it) {
        return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
    };
});

},{"./_is-object":"eIE5K","./_object-sap":"fgwTp"}],"K45hu":[function(require,module,exports) {
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');
require('./_object-sap')('isSealed', function($isSealed) {
    return function isSealed(it) {
        return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
    };
});

},{"./_is-object":"eIE5K","./_object-sap":"fgwTp"}],"23gjD":[function(require,module,exports) {
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');
require('./_object-sap')('isExtensible', function($isExtensible) {
    return function isExtensible(it) {
        return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
    };
});

},{"./_is-object":"eIE5K","./_object-sap":"fgwTp"}],"8DvpM":[function(require,module,exports) {
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');
$export($export.S + $export.F, 'Object', {
    assign: require('./_object-assign')
});

},{"./_export":"1Tgvm","./_object-assign":"h8iBq"}],"h8iBq":[function(require,module,exports) {
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;
// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function() {
    var A = {};
    var B = {};
    // eslint-disable-next-line no-undef
    var S = Symbol();
    var K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function(k) {
        B[k] = k;
    });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
    var T = toObject(target);
    var aLen = arguments.length;
    var index = 1;
    var getSymbols = gOPS.f;
    var isEnum = pIE.f;
    while(aLen > index){
        var S = IObject(arguments[index++]);
        var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
        var length = keys.length;
        var j = 0;
        var key;
        while(length > j){
            key = keys[j++];
            if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
        }
    }
    return T;
} : $assign;

},{"./_descriptors":"dr2tY","./_object-keys":"98CC0","./_object-gops":"5oH2C","./_object-pie":"2aUxV","./_to-object":"7HHXi","./_iobject":"24JwK","./_fails":"iAFH1"}],"e23no":[function(require,module,exports) {
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', {
    is: require('./_same-value')
});

},{"./_export":"1Tgvm","./_same-value":"94M5S"}],"94M5S":[function(require,module,exports) {
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
    // eslint-disable-next-line no-self-compare
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],"d3fGn":[function(require,module,exports) {
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', {
    setPrototypeOf: require('./_set-proto').set
});

},{"./_export":"1Tgvm","./_set-proto":"ltEMf"}],"ltEMf":[function(require,module,exports) {
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */ var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
        try {
            set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
            set(test, []);
            buggy = !(test instanceof Array);
        } catch (e) {
            buggy = true;
        }
        return function setPrototypeOf(O, proto) {
            check(O, proto);
            if (buggy) O.__proto__ = proto;
            else set(O, proto);
            return O;
        };
    }({}, false) : undefined),
    check: check
};

},{"./_is-object":"eIE5K","./_an-object":"kiL2X","./_ctx":"4rQSm","./_object-gopd":"4bAUG"}],"7cLOk":[function(require,module,exports) {
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
}, true);

},{"./_classof":"5TIen","./_wks":"eaoKZ","./_redefine":"9vAu7"}],"5TIen":[function(require,module,exports) {
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function() {
    return arguments;
}()) == 'Arguments';
// fallback for IE11 Script Access Denied error
var tryGet = function(it, key) {
    try {
        return it[key];
    } catch (e) {}
};
module.exports = function(it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":"frIbo","./_wks":"eaoKZ"}],"54Dqr":[function(require,module,exports) {
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');
$export($export.P, 'Function', {
    bind: require('./_bind')
});

},{"./_export":"1Tgvm","./_bind":"2xSTE"}],"2xSTE":[function(require,module,exports) {
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};
var construct = function(F, len, args) {
    if (!(len in factories)) {
        for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
        // eslint-disable-next-line no-new-func
        factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
    }
    return factories[len](F, args);
};
module.exports = Function.bind || function bind(that /* , ...args */ ) {
    var fn = aFunction(this);
    var partArgs = arraySlice.call(arguments, 1);
    var bound = function() {
        var args = partArgs.concat(arraySlice.call(arguments));
        return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
    };
    if (isObject(fn.prototype)) bound.prototype = fn.prototype;
    return bound;
};

},{"./_a-function":"55L9l","./_is-object":"eIE5K","./_invoke":"c7Bab"}],"c7Bab":[function(require,module,exports) {
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch(args.length){
        case 0:
            return un ? fn() : fn.call(that);
        case 1:
            return un ? fn(args[0]) : fn.call(that, args[0]);
        case 2:
            return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
        case 3:
            return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
        case 4:
            return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
};

},{}],"lmg4B":[function(require,module,exports) {
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';
// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
    configurable: true,
    get: function() {
        try {
            return ('' + this).match(nameRE)[1];
        } catch (e) {
            return '';
        }
    }
});

},{"./_object-dp":"cLcWd","./_descriptors":"dr2tY"}],"flBdS":[function(require,module,exports) {
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, {
    value: function(O) {
        if (typeof this != 'function' || !isObject(O)) return false;
        if (!isObject(this.prototype)) return O instanceof this;
        // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
        while(O = getPrototypeOf(O))if (this.prototype === O) return true;
        return false;
    }
});

},{"./_is-object":"eIE5K","./_object-gpo":"4uFAD","./_wks":"eaoKZ","./_object-dp":"cLcWd"}],"l30ZK":[function(require,module,exports) {
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), {
    parseInt: $parseInt
});

},{"./_export":"1Tgvm","./_parse-int":"b3ov9"}],"b3ov9":[function(require,module,exports) {
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;
module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
    var string = $trim(String(str), 3);
    return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":"8xCse","./_string-trim":"9YCA9","./_string-ws":"bg6tv"}],"9YCA9":[function(require,module,exports) {
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');
var exporter = function(KEY, exec, ALIAS) {
    var exp = {};
    var FORCE = fails(function() {
        return !!spaces[KEY]() || non[KEY]() != non;
    });
    var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
    if (ALIAS) exp[ALIAS] = fn;
    $export($export.P + $export.F * FORCE, 'String', exp);
};
// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function(string, TYPE) {
    string = String(defined(string));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
};
module.exports = exporter;

},{"./_export":"1Tgvm","./_defined":"4Lj5U","./_fails":"iAFH1","./_string-ws":"bg6tv"}],"bg6tv":[function(require,module,exports) {
module.exports = "	\n\v\f\r \xa0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";

},{}],"edHLy":[function(require,module,exports) {
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), {
    parseFloat: $parseFloat
});

},{"./_export":"1Tgvm","./_parse-float":"eAzEB"}],"eAzEB":[function(require,module,exports) {
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;
module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
    var string = $trim(String(str), 3);
    var result = $parseFloat(string);
    return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":"8xCse","./_string-trim":"9YCA9","./_string-ws":"bg6tv"}],"b3DG0":[function(require,module,exports) {
'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;
// 7.1.3 ToNumber(argument)
var toNumber = function(argument) {
    var it = toPrimitive(argument, false);
    if (typeof it == 'string' && it.length > 2) {
        it = TRIM ? it.trim() : $trim(it, 3);
        var first = it.charCodeAt(0);
        var third, radix, maxCode;
        if (first === 43 || first === 45) {
            third = it.charCodeAt(2);
            if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
        } else if (first === 48) {
            switch(it.charCodeAt(1)){
                case 66:
                case 98:
                    radix = 2;
                    maxCode = 49;
                    break; // fast equal /^0b[01]+$/i
                case 79:
                case 111:
                    radix = 8;
                    maxCode = 55;
                    break; // fast equal /^0o[0-7]+$/i
                default:
                    return +it;
            }
            for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
                code = digits.charCodeAt(i);
                // parseInt parses a string to a first unavailable symbol
                // but ToNumber should return NaN if a string contains unavailable symbols
                if (code < 48 || code > maxCode) return NaN;
            }
            return parseInt(digits, radix);
        }
    }
    return +it;
};
if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
    $Number = function Number(value) {
        var it = arguments.length < 1 ? 0 : value;
        var that = this;
        return that instanceof $Number && (BROKEN_COF ? fails(function() {
            proto.valueOf.call(that);
        }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
    };
    for(var keys = require('./_descriptors') ? gOPN(Base) : // ES3:
    "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(','), j = 0, key; keys.length > j; j++)if (has(Base, key = keys[j]) && !has($Number, key)) dP($Number, key, gOPD(Base, key));
    $Number.prototype = proto;
    proto.constructor = $Number;
    require('./_redefine')(global, NUMBER, $Number);
}

},{"./_global":"8xCse","./_has":"biQ7v","./_cof":"frIbo","./_inherit-if-required":"9GGeZ","./_to-primitive":"4Oubb","./_fails":"iAFH1","./_object-gopn":"jK0Om","./_object-gopd":"4bAUG","./_object-dp":"cLcWd","./_string-trim":"9YCA9","./_object-create":"b4m8n","./_descriptors":"dr2tY","./_redefine":"9vAu7"}],"9GGeZ":[function(require,module,exports) {
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function(that, target, C) {
    var S = target.constructor;
    var P;
    if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) setPrototypeOf(that, P);
    return that;
};

},{"./_is-object":"eIE5K","./_set-proto":"ltEMf"}],"jVWO1":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toInteger = require('./_to-integer');
var aNumberValue = require('./_a-number-value');
var repeat = require('./_string-repeat');
var $toFixed = 1..toFixed;
var floor = Math.floor;
var data = [
    0,
    0,
    0,
    0,
    0,
    0
];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';
var multiply = function(n, c) {
    var i = -1;
    var c2 = c;
    while(++i < 6){
        c2 += n * data[i];
        data[i] = c2 % 10000000;
        c2 = floor(c2 / 10000000);
    }
};
var divide = function(n) {
    var i = 6;
    var c = 0;
    while(--i >= 0){
        c += data[i];
        data[i] = floor(c / n);
        c = c % n * 10000000;
    }
};
var numToString = function() {
    var i = 6;
    var s = '';
    while(--i >= 0)if (s !== '' || i === 0 || data[i] !== 0) {
        var t = String(data[i]);
        s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
    return s;
};
var pow = function(x, n, acc) {
    return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function(x) {
    var n = 0;
    var x2 = x;
    while(x2 >= 4096){
        n += 12;
        x2 /= 4096;
    }
    while(x2 >= 2){
        n += 1;
        x2 /= 2;
    }
    return n;
};
$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000100..toFixed(0) !== '1000000000000000128') || !require('./_fails')(function() {
    // V8 ~ Android 4.3-
    $toFixed.call({});
})), 'Number', {
    toFixed: function toFixed(fractionDigits) {
        var x = aNumberValue(this, ERROR);
        var f = toInteger(fractionDigits);
        var s = '';
        var m = ZERO;
        var e, z, j, k;
        if (f < 0 || f > 20) throw RangeError(ERROR);
        // eslint-disable-next-line no-self-compare
        if (x != x) return 'NaN';
        if (x <= -1000000000000000000000 || x >= 1000000000000000000000) return String(x);
        if (x < 0) {
            s = '-';
            x = -x;
        }
        if (x > 0.000000000000000000001) {
            e = log(x * pow(2, 69, 1)) - 69;
            z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
            z *= 4503599627370496;
            e = 52 - e;
            if (e > 0) {
                multiply(0, z);
                j = f;
                while(j >= 7){
                    multiply(10000000, 0);
                    j -= 7;
                }
                multiply(pow(10, j, 1), 0);
                j = e - 1;
                while(j >= 23){
                    divide(8388608);
                    j -= 23;
                }
                divide(1 << j);
                multiply(1, 1);
                divide(2);
                m = numToString();
            } else {
                multiply(0, z);
                multiply(1 << -e, 0);
                m = numToString() + repeat.call(ZERO, f);
            }
        }
        if (f > 0) {
            k = m.length;
            m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
        } else m = s + m;
        return m;
    }
});

},{"./_export":"1Tgvm","./_to-integer":"cb0GT","./_a-number-value":"3132k","./_string-repeat":"2JEgf","./_fails":"iAFH1"}],"3132k":[function(require,module,exports) {
var cof = require('./_cof');
module.exports = function(it, msg) {
    if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
    return +it;
};

},{"./_cof":"frIbo"}],"2JEgf":[function(require,module,exports) {
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');
module.exports = function repeat(count) {
    var str = String(defined(this));
    var res = '';
    var n = toInteger(count);
    if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
    for(; n > 0; (n >>>= 1) && (str += str))if (n & 1) res += str;
    return res;
};

},{"./_to-integer":"cb0GT","./_defined":"4Lj5U"}],"fkTCt":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $fails = require('./_fails');
var aNumberValue = require('./_a-number-value');
var $toPrecision = 1..toPrecision;
$export($export.P + $export.F * ($fails(function() {
    // IE7-
    return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function() {
    // V8 ~ Android 4.3-
    $toPrecision.call({});
})), 'Number', {
    toPrecision: function toPrecision(precision) {
        var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
        return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
    }
});

},{"./_export":"1Tgvm","./_fails":"iAFH1","./_a-number-value":"3132k"}],"dS5u0":[function(require,module,exports) {
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');
$export($export.S, 'Number', {
    EPSILON: Math.pow(2, -52)
});

},{"./_export":"1Tgvm"}],"gaJ9D":[function(require,module,exports) {
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;
$export($export.S, 'Number', {
    isFinite: function isFinite(it) {
        return typeof it == 'number' && _isFinite(it);
    }
});

},{"./_export":"1Tgvm","./_global":"8xCse"}],"cXfOC":[function(require,module,exports) {
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');
$export($export.S, 'Number', {
    isInteger: require('./_is-integer')
});

},{"./_export":"1Tgvm","./_is-integer":"eFruS"}],"eFruS":[function(require,module,exports) {
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
    return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":"eIE5K"}],"dHEdL":[function(require,module,exports) {
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');
$export($export.S, 'Number', {
    isNaN: function isNaN(number) {
        // eslint-disable-next-line no-self-compare
        return number != number;
    }
});

},{"./_export":"1Tgvm"}],"8WZJi":[function(require,module,exports) {
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;
$export($export.S, 'Number', {
    isSafeInteger: function isSafeInteger(number) {
        return isInteger(number) && abs(number) <= 9007199254740991;
    }
});

},{"./_export":"1Tgvm","./_is-integer":"eFruS"}],"lEoVS":[function(require,module,exports) {
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');
$export($export.S, 'Number', {
    MAX_SAFE_INTEGER: 9007199254740991
});

},{"./_export":"1Tgvm"}],"6GYXq":[function(require,module,exports) {
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');
$export($export.S, 'Number', {
    MIN_SAFE_INTEGER: -9007199254740991
});

},{"./_export":"1Tgvm"}],"adyPr":[function(require,module,exports) {
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {
    parseFloat: $parseFloat
});

},{"./_export":"1Tgvm","./_parse-float":"eAzEB"}],"cz541":[function(require,module,exports) {
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {
    parseInt: $parseInt
});

},{"./_export":"1Tgvm","./_parse-int":"b3ov9"}],"atazc":[function(require,module,exports) {
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;
$export($export.S + $export.F * !($acosh && Math.floor($acosh(Number.MAX_VALUE)) == 710 && $acosh(Infinity) == Infinity), 'Math', {
    acosh: function acosh(x) {
        return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
    }
});

},{"./_export":"1Tgvm","./_math-log1p":"39ll1"}],"39ll1":[function(require,module,exports) {
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
    return (x = +x) > -0.00000001 && x < 0.00000001 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],"9vCFA":[function(require,module,exports) {
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;
function asinh(x) {
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}
// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {
    asinh: asinh
});

},{"./_export":"1Tgvm"}],"1Poi7":[function(require,module,exports) {
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;
// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
    atanh: function atanh(x) {
        return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
    }
});

},{"./_export":"1Tgvm"}],"kEyNP":[function(require,module,exports) {
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');
$export($export.S, 'Math', {
    cbrt: function cbrt(x) {
        return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
    }
});

},{"./_export":"1Tgvm","./_math-sign":"7nT0W"}],"7nT0W":[function(require,module,exports) {
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
    // eslint-disable-next-line no-self-compare
    return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],"asnnc":[function(require,module,exports) {
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');
$export($export.S, 'Math', {
    clz32: function clz32(x) {
        return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
    }
});

},{"./_export":"1Tgvm"}],"672oR":[function(require,module,exports) {
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;
$export($export.S, 'Math', {
    cosh: function cosh(x) {
        return (exp(x = +x) + exp(-x)) / 2;
    }
});

},{"./_export":"1Tgvm"}],"eLul3":[function(require,module,exports) {
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');
$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {
    expm1: $expm1
});

},{"./_export":"1Tgvm","./_math-expm1":"6SST9"}],"6SST9":[function(require,module,exports) {
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = !$expm1 || $expm1(10) > 22025.465794806718 || $expm1(10) < 22025.465794806718 || $expm1(-0.00000000000000002) != -0.00000000000000002 ? function expm1(x) {
    return (x = +x) == 0 ? x : x > -0.000001 && x < 0.000001 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],"6JW0t":[function(require,module,exports) {
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');
$export($export.S, 'Math', {
    fround: require('./_math-fround')
});

},{"./_export":"1Tgvm","./_math-fround":"9TbbN"}],"9TbbN":[function(require,module,exports) {
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);
var roundTiesToEven = function(n) {
    return n + 1 / EPSILON - 1 / EPSILON;
};
module.exports = Math.fround || function fround(x) {
    var $abs = Math.abs(x);
    var $sign = sign(x);
    var a, result;
    if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    // eslint-disable-next-line no-self-compare
    if (result > MAX32 || result != result) return $sign * Infinity;
    return $sign * result;
};

},{"./_math-sign":"7nT0W"}],"1rcXM":[function(require,module,exports) {
// 20.2.2.17 Math.hypot([value1[, value2[, â€¦ ]]])
var $export = require('./_export');
var abs = Math.abs;
$export($export.S, 'Math', {
    hypot: function hypot(value1, value2) {
        var sum = 0;
        var i = 0;
        var aLen = arguments.length;
        var larg = 0;
        var arg, div;
        while(i < aLen){
            arg = abs(arguments[i++]);
            if (larg < arg) {
                div = larg / arg;
                sum = sum * div * div + 1;
                larg = arg;
            } else if (arg > 0) {
                div = arg / larg;
                sum += div * div;
            } else sum += arg;
        }
        return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
    }
});

},{"./_export":"1Tgvm"}],"lAxVU":[function(require,module,exports) {
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;
// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function() {
    return $imul(4294967295, 5) != -5 || $imul.length != 2;
}), 'Math', {
    imul: function imul(x, y) {
        var UINT16 = 65535;
        var xn = +x;
        var yn = +y;
        var xl = UINT16 & xn;
        var yl = UINT16 & yn;
        return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
    }
});

},{"./_export":"1Tgvm","./_fails":"iAFH1"}],"fIjzt":[function(require,module,exports) {
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');
$export($export.S, 'Math', {
    log10: function log10(x) {
        return Math.log(x) * Math.LOG10E;
    }
});

},{"./_export":"1Tgvm"}],"kK15h":[function(require,module,exports) {
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');
$export($export.S, 'Math', {
    log1p: require('./_math-log1p')
});

},{"./_export":"1Tgvm","./_math-log1p":"39ll1"}],"kkgGM":[function(require,module,exports) {
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');
$export($export.S, 'Math', {
    log2: function log2(x) {
        return Math.log(x) / Math.LN2;
    }
});

},{"./_export":"1Tgvm"}],"18Gp0":[function(require,module,exports) {
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');
$export($export.S, 'Math', {
    sign: require('./_math-sign')
});

},{"./_export":"1Tgvm","./_math-sign":"7nT0W"}],"bkULm":[function(require,module,exports) {
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;
// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function() {
    return !Math.sinh(-0.00000000000000002) != -0.00000000000000002;
}), 'Math', {
    sinh: function sinh(x) {
        return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
    }
});

},{"./_export":"1Tgvm","./_math-expm1":"6SST9","./_fails":"iAFH1"}],"br08o":[function(require,module,exports) {
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;
$export($export.S, 'Math', {
    tanh: function tanh(x) {
        var a = expm1(x = +x);
        var b = expm1(-x);
        return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
    }
});

},{"./_export":"1Tgvm","./_math-expm1":"6SST9"}],"8fixj":[function(require,module,exports) {
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');
$export($export.S, 'Math', {
    trunc: function trunc(it) {
        return (it > 0 ? Math.floor : Math.ceil)(it);
    }
});

},{"./_export":"1Tgvm"}],"gsGce":[function(require,module,exports) {
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;
// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
    // 21.1.2.2 String.fromCodePoint(...codePoints)
    fromCodePoint: function fromCodePoint(x) {
        var res = [];
        var aLen = arguments.length;
        var i = 0;
        var code;
        while(aLen > i){
            code = +arguments[i++];
            if (toAbsoluteIndex(code, 1114111) !== code) throw RangeError(code + ' is not a valid code point');
            res.push(code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320));
        }
        return res.join('');
    }
});

},{"./_export":"1Tgvm","./_to-absolute-index":"1lPjf"}],"4MADL":[function(require,module,exports) {
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
$export($export.S, 'String', {
    // 21.1.2.4 String.raw(callSite, ...substitutions)
    raw: function raw(callSite) {
        var tpl = toIObject(callSite.raw);
        var len = toLength(tpl.length);
        var aLen = arguments.length;
        var res = [];
        var i = 0;
        while(len > i){
            res.push(String(tpl[i++]));
            if (i < aLen) res.push(String(arguments[i]));
        }
        return res.join('');
    }
});

},{"./_export":"1Tgvm","./_to-iobject":"f9RCz","./_to-length":"irYfS"}],"hEKob":[function(require,module,exports) {
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function($trim) {
    return function trim() {
        return $trim(this, 3);
    };
});

},{"./_string-trim":"9YCA9"}],"llgDB":[function(require,module,exports) {
'use strict';
var $at = require('./_string-at')(true);
// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function(iterated) {
    this._t = String(iterated); // target
    this._i = 0; // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function() {
    var O = this._t;
    var index = this._i;
    var point;
    if (index >= O.length) return {
        value: undefined,
        done: true
    };
    point = $at(O, index);
    this._i += point.length;
    return {
        value: point,
        done: false
    };
});

},{"./_string-at":"rbgP0","./_iter-define":"egJhK"}],"rbgP0":[function(require,module,exports) {
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING) {
    return function(that, pos) {
        var s = String(defined(that));
        var i = toInteger(pos);
        var l = s.length;
        var a, b;
        if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
        a = s.charCodeAt(i);
        return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
    };
};

},{"./_to-integer":"cb0GT","./_defined":"4Lj5U"}],"egJhK":[function(require,module,exports) {
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';
var returnThis = function() {
    return this;
};
module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function(kind) {
        if (!BUGGY && kind in proto) return proto[kind];
        switch(kind){
            case KEYS:
                return function keys() {
                    return new Constructor(this, kind);
                };
            case VALUES:
                return function values() {
                    return new Constructor(this, kind);
                };
        }
        return function entries() {
            return new Constructor(this, kind);
        };
    };
    var TAG = NAME + ' Iterator';
    var DEF_VALUES = DEFAULT == VALUES;
    var VALUES_BUG = false;
    var proto = Base.prototype;
    var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
    var $default = $native || getMethod(DEFAULT);
    var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
    var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
    var methods, key, IteratorPrototype;
    // Fix native
    if ($anyNative) {
        IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
        if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
            // Set @@toStringTag to native iterators
            setToStringTag(IteratorPrototype, TAG, true);
            // fix for some old engines
            if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
        }
    }
    // fix Array#{values, @@iterator}.name in V8 / FF
    if (DEF_VALUES && $native && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
            return $native.call(this);
        };
    }
    // Define iterator
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) hide(proto, ITERATOR, $default);
    // Plug for library
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
        methods = {
            values: DEF_VALUES ? $default : getMethod(VALUES),
            keys: IS_SET ? $default : getMethod(KEYS),
            entries: $entries
        };
        if (FORCED) {
            for(key in methods)if (!(key in proto)) redefine(proto, key, methods[key]);
        } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
};

},{"./_library":"lmtqY","./_export":"1Tgvm","./_redefine":"9vAu7","./_hide":"ddpVq","./_iterators":"dITQr","./_iter-create":"eTcx3","./_set-to-string-tag":"7YXlq","./_object-gpo":"4uFAD","./_wks":"eaoKZ"}],"dITQr":[function(require,module,exports) {
module.exports = {};

},{}],"eTcx3":[function(require,module,exports) {
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};
// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function() {
    return this;
});
module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = create(IteratorPrototype, {
        next: descriptor(1, next)
    });
    setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_object-create":"b4m8n","./_property-desc":"825qY","./_set-to-string-tag":"7YXlq","./_hide":"ddpVq","./_wks":"eaoKZ"}],"doYwG":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
    // 21.1.3.3 String.prototype.codePointAt(pos)
    codePointAt: function codePointAt(pos) {
        return $at(this, pos);
    }
});

},{"./_export":"1Tgvm","./_string-at":"rbgP0"}],"39nwy":[function(require,module,exports) {
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];
$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
    endsWith: function endsWith(searchString /* , endPosition = @length */ ) {
        var that = context(this, searchString, ENDS_WITH);
        var endPosition = arguments.length > 1 ? arguments[1] : undefined;
        var len = toLength(that.length);
        var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
        var search = String(searchString);
        return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
    }
});

},{"./_export":"1Tgvm","./_to-length":"irYfS","./_string-context":"dNNLc","./_fails-is-regexp":"4q5P7"}],"dNNLc":[function(require,module,exports) {
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');
module.exports = function(that, searchString, NAME) {
    if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
    return String(defined(that));
};

},{"./_is-regexp":"aGcfF","./_defined":"4Lj5U"}],"aGcfF":[function(require,module,exports) {
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function(it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_is-object":"eIE5K","./_cof":"frIbo","./_wks":"eaoKZ"}],"4q5P7":[function(require,module,exports) {
var MATCH = require('./_wks')('match');
module.exports = function(KEY) {
    var re = /./;
    try {
        '/./'[KEY](re);
    } catch (e) {
        try {
            re[MATCH] = false;
            return !'/./'[KEY](re);
        } catch (f) {}
    }
    return true;
};

},{"./_wks":"eaoKZ"}],"9JmYp":[function(require,module,exports) {
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';
$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
    includes: function includes(searchString /* , position = 0 */ ) {
        return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
    }
});

},{"./_export":"1Tgvm","./_string-context":"dNNLc","./_fails-is-regexp":"4q5P7"}],"cqBCd":[function(require,module,exports) {
var $export = require('./_export');
$export($export.P, 'String', {
    // 21.1.3.13 String.prototype.repeat(count)
    repeat: require('./_string-repeat')
});

},{"./_export":"1Tgvm","./_string-repeat":"2JEgf"}],"iMejr":[function(require,module,exports) {
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];
$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
    startsWith: function startsWith(searchString /* , position = 0 */ ) {
        var that = context(this, searchString, STARTS_WITH);
        var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
        var search = String(searchString);
        return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
    }
});

},{"./_export":"1Tgvm","./_to-length":"irYfS","./_string-context":"dNNLc","./_fails-is-regexp":"4q5P7"}],"97Lll":[function(require,module,exports) {
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function(createHTML) {
    return function anchor(name) {
        return createHTML(this, 'a', 'name', name);
    };
});

},{"./_string-html":"8eGZd"}],"8eGZd":[function(require,module,exports) {
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function(string, tag, attribute, value) {
    var S = String(defined(string));
    var p1 = '<' + tag;
    if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
    return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function(NAME, exec) {
    var O = {};
    O[NAME] = exec(createHTML);
    $export($export.P + $export.F * fails(function() {
        var test = ''[NAME]('"');
        return test !== test.toLowerCase() || test.split('"').length > 3;
    }), 'String', O);
};

},{"./_export":"1Tgvm","./_fails":"iAFH1","./_defined":"4Lj5U"}],"7nKCA":[function(require,module,exports) {
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function(createHTML) {
    return function big() {
        return createHTML(this, 'big', '', '');
    };
});

},{"./_string-html":"8eGZd"}],"jbxAT":[function(require,module,exports) {
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function(createHTML) {
    return function blink() {
        return createHTML(this, 'blink', '', '');
    };
});

},{"./_string-html":"8eGZd"}],"4MfGp":[function(require,module,exports) {
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function(createHTML) {
    return function bold() {
        return createHTML(this, 'b', '', '');
    };
});

},{"./_string-html":"8eGZd"}],"4y2Bb":[function(require,module,exports) {
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function(createHTML) {
    return function fixed() {
        return createHTML(this, 'tt', '', '');
    };
});

},{"./_string-html":"8eGZd"}],"lmhCi":[function(require,module,exports) {
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function(createHTML) {
    return function fontcolor(color) {
        return createHTML(this, 'font', 'color', color);
    };
});

},{"./_string-html":"8eGZd"}],"hL89C":[function(require,module,exports) {
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function(createHTML) {
    return function fontsize(size) {
        return createHTML(this, 'font', 'size', size);
    };
});

},{"./_string-html":"8eGZd"}],"iwOAc":[function(require,module,exports) {
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function(createHTML) {
    return function italics() {
        return createHTML(this, 'i', '', '');
    };
});

},{"./_string-html":"8eGZd"}],"e07IC":[function(require,module,exports) {
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function(createHTML) {
    return function link(url) {
        return createHTML(this, 'a', 'href', url);
    };
});

},{"./_string-html":"8eGZd"}],"2MSNU":[function(require,module,exports) {
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function(createHTML) {
    return function small() {
        return createHTML(this, 'small', '', '');
    };
});

},{"./_string-html":"8eGZd"}],"8kiXd":[function(require,module,exports) {
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function(createHTML) {
    return function strike() {
        return createHTML(this, 'strike', '', '');
    };
});

},{"./_string-html":"8eGZd"}],"iprh9":[function(require,module,exports) {
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function(createHTML) {
    return function sub() {
        return createHTML(this, 'sub', '', '');
    };
});

},{"./_string-html":"8eGZd"}],"doHpa":[function(require,module,exports) {
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function(createHTML) {
    return function sup() {
        return createHTML(this, 'sup', '', '');
    };
});

},{"./_string-html":"8eGZd"}],"4HGro":[function(require,module,exports) {
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');
$export($export.S, 'Date', {
    now: function() {
        return new Date().getTime();
    }
});

},{"./_export":"1Tgvm"}],"7Glbw":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
$export($export.P + $export.F * require('./_fails')(function() {
    return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
        toISOString: function() {
            return 1;
        }
    }) !== 1;
}), 'Date', {
    // eslint-disable-next-line no-unused-vars
    toJSON: function toJSON(key) {
        var O = toObject(this);
        var pv = toPrimitive(O);
        return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
    }
});

},{"./_export":"1Tgvm","./_to-object":"7HHXi","./_to-primitive":"4Oubb","./_fails":"iAFH1"}],"hQdLT":[function(require,module,exports) {
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export');
var toISOString = require('./_date-to-iso-string');
// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
    toISOString: toISOString
});

},{"./_export":"1Tgvm","./_date-to-iso-string":"aJh30"}],"aJh30":[function(require,module,exports) {
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = require('./_fails');
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;
var lz = function(num) {
    return num > 9 ? num : '0' + num;
};
// PhantomJS / old WebKit has a broken implementations
module.exports = fails(function() {
    return $toISOString.call(new Date(-50000000000000 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function() {
    $toISOString.call(new Date(NaN));
}) ? function toISOString() {
    if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
    var d = this;
    var y = d.getUTCFullYear();
    var m = d.getUTCMilliseconds();
    var s = y < 0 ? '-' : y > 9999 ? '+' : '';
    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

},{"./_fails":"iAFH1"}],"d3yLX":[function(require,module,exports) {
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) require('./_redefine')(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
});

},{"./_redefine":"9vAu7"}],"hoeNq":[function(require,module,exports) {
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;
if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_wks":"eaoKZ","./_hide":"ddpVq","./_date-to-primitive":"i1V0X"}],"i1V0X":[function(require,module,exports) {
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';
module.exports = function(hint) {
    if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
    return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":"kiL2X","./_to-primitive":"4Oubb"}],"5g48E":[function(require,module,exports) {
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');
$export($export.S, 'Array', {
    isArray: require('./_is-array')
});

},{"./_export":"1Tgvm","./_is-array":"dTLRt"}],"i3Nvz":[function(require,module,exports) {
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');
$export($export.S + $export.F * !require('./_iter-detect')(function(iter) {
    Array.from(iter);
}), 'Array', {
    // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
    from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */ ) {
        var O = toObject(arrayLike);
        var C = typeof this == 'function' ? this : Array;
        var aLen = arguments.length;
        var mapfn = aLen > 1 ? arguments[1] : undefined;
        var mapping = mapfn !== undefined;
        var index = 0;
        var iterFn = getIterFn(O);
        var length, result, step, iterator;
        if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
        // if object isn't iterable or it's array with default iterator - use simple case
        if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) for(iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++)createProperty(result, index, mapping ? call(iterator, mapfn, [
            step.value,
            index
        ], true) : step.value);
        else {
            length = toLength(O.length);
            for(result = new C(length); length > index; index++)createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
        }
        result.length = index;
        return result;
    }
});

},{"./_ctx":"4rQSm","./_export":"1Tgvm","./_to-object":"7HHXi","./_iter-call":"hZ7Tf","./_is-array-iter":"ipP6u","./_to-length":"irYfS","./_create-property":"8UZLF","./core.get-iterator-method":"hb865","./_iter-detect":"3KQwU"}],"hZ7Tf":[function(require,module,exports) {
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function(iterator, fn, value, entries) {
    try {
        return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
    } catch (e) {
        var ret = iterator['return'];
        if (ret !== undefined) anObject(ret.call(iterator));
        throw e;
    }
};

},{"./_an-object":"kiL2X"}],"ipP6u":[function(require,module,exports) {
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;
module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":"dITQr","./_wks":"eaoKZ"}],"8UZLF":[function(require,module,exports) {
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = function(object, index, value) {
    if (index in object) $defineProperty.f(object, index, createDesc(0, value));
    else object[index] = value;
};

},{"./_object-dp":"cLcWd","./_property-desc":"825qY"}],"hb865":[function(require,module,exports) {
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function(it) {
    if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

},{"./_classof":"5TIen","./_wks":"eaoKZ","./_iterators":"dITQr","./_core":"4o9Ko"}],"3KQwU":[function(require,module,exports) {
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;
try {
    var riter = [
        7
    ][ITERATOR]();
    riter['return'] = function() {
        SAFE_CLOSING = true;
    };
    // eslint-disable-next-line no-throw-literal
    Array.from(riter, function() {
        throw 2;
    });
} catch (e) {}
module.exports = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
        var arr = [
            7
        ];
        var iter = arr[ITERATOR]();
        iter.next = function() {
            return {
                done: safe = true
            };
        };
        arr[ITERATOR] = function() {
            return iter;
        };
        exec(arr);
    } catch (e) {}
    return safe;
};

},{"./_wks":"eaoKZ"}],"aLmME":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');
// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function() {
    function F() {}
    return !(Array.of.call(F) instanceof F);
}), 'Array', {
    // 22.1.2.3 Array.of( ...items)
    of: function of() {
        var index = 0;
        var aLen = arguments.length;
        var result = new (typeof this == 'function' ? this : Array)(aLen);
        while(aLen > index)createProperty(result, index, arguments[index++]);
        result.length = aLen;
        return result;
    }
});

},{"./_export":"1Tgvm","./_create-property":"8UZLF","./_fails":"iAFH1"}],"lQMhQ":[function(require,module,exports) {
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var arrayJoin = [].join;
// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
    join: function join(separator) {
        return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
    }
});

},{"./_export":"1Tgvm","./_to-iobject":"f9RCz","./_iobject":"24JwK","./_strict-method":"7xXNH"}],"7xXNH":[function(require,module,exports) {
'use strict';
var fails = require('./_fails');
module.exports = function(method, arg) {
    return !!method && fails(function() {
        // eslint-disable-next-line no-useless-call
        arg ? method.call(null, function() {}, 1) : method.call(null);
    });
};

},{"./_fails":"iAFH1"}],"4E6IU":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var html = require('./_html');
var cof = require('./_cof');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var arraySlice = [].slice;
// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function() {
    if (html) arraySlice.call(html);
}), 'Array', {
    slice: function slice(begin, end) {
        var len = toLength(this.length);
        var klass = cof(this);
        end = end === undefined ? len : end;
        if (klass == 'Array') return arraySlice.call(this, begin, end);
        var start = toAbsoluteIndex(begin, len);
        var upTo = toAbsoluteIndex(end, len);
        var size = toLength(upTo - start);
        var cloned = new Array(size);
        var i = 0;
        for(; i < size; i++)cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
        return cloned;
    }
});

},{"./_export":"1Tgvm","./_html":"lPhWk","./_cof":"frIbo","./_to-absolute-index":"1lPjf","./_to-length":"irYfS","./_fails":"iAFH1"}],"lAyeU":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [
    1,
    2,
    3
];
$export($export.P + $export.F * (fails(function() {
    // IE8-
    test.sort(undefined);
}) || !fails(function() {
    // V8 bug
    test.sort(null);
// Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
    // 22.1.3.25 Array.prototype.sort(comparefn)
    sort: function sort(comparefn) {
        return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
    }
});

},{"./_export":"1Tgvm","./_a-function":"55L9l","./_to-object":"7HHXi","./_fails":"iAFH1","./_strict-method":"7xXNH"}],"7cxLy":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $forEach = require('./_array-methods')(0);
var STRICT = require('./_strict-method')([].forEach, true);
$export($export.P + $export.F * !STRICT, 'Array', {
    // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
    forEach: function forEach(callbackfn /* , thisArg */ ) {
        return $forEach(this, callbackfn, arguments[1]);
    }
});

},{"./_export":"1Tgvm","./_array-methods":"9C3tD","./_strict-method":"7xXNH"}],"9C3tD":[function(require,module,exports) {
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function(TYPE, $create) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    var create = $create || asc;
    return function($this, callbackfn, that) {
        var O = toObject($this);
        var self = IObject(O);
        var f = ctx(callbackfn, that, 3);
        var length = toLength(self.length);
        var index = 0;
        var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
        var val, res;
        for(; length > index; index++)if (NO_HOLES || index in self) {
            val = self[index];
            res = f(val, index, O);
            if (TYPE) {
                if (IS_MAP) result[index] = res; // map
                else if (res) switch(TYPE){
                    case 3:
                        return true; // some
                    case 5:
                        return val; // find
                    case 6:
                        return index; // findIndex
                    case 2:
                        result.push(val); // filter
                }
                else if (IS_EVERY) return false; // every
            }
        }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
};

},{"./_ctx":"4rQSm","./_iobject":"24JwK","./_to-object":"7HHXi","./_to-length":"irYfS","./_array-species-create":"93xs6"}],"93xs6":[function(require,module,exports) {
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');
module.exports = function(original, length) {
    return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":"9JYoz"}],"9JYoz":[function(require,module,exports) {
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');
module.exports = function(original) {
    var C;
    if (isArray(original)) {
        C = original.constructor;
        // cross-realm fallback
        if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
        if (isObject(C)) {
            C = C[SPECIES];
            if (C === null) C = undefined;
        }
    }
    return C === undefined ? Array : C;
};

},{"./_is-object":"eIE5K","./_is-array":"dTLRt","./_wks":"eaoKZ"}],"j4ARR":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $map = require('./_array-methods')(1);
$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
    // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
    map: function map(callbackfn /* , thisArg */ ) {
        return $map(this, callbackfn, arguments[1]);
    }
});

},{"./_export":"1Tgvm","./_array-methods":"9C3tD","./_strict-method":"7xXNH"}],"5vJuE":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $filter = require('./_array-methods')(2);
$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
    // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
    filter: function filter(callbackfn /* , thisArg */ ) {
        return $filter(this, callbackfn, arguments[1]);
    }
});

},{"./_export":"1Tgvm","./_array-methods":"9C3tD","./_strict-method":"7xXNH"}],"iKQGA":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $some = require('./_array-methods')(3);
$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
    // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
    some: function some(callbackfn /* , thisArg */ ) {
        return $some(this, callbackfn, arguments[1]);
    }
});

},{"./_export":"1Tgvm","./_array-methods":"9C3tD","./_strict-method":"7xXNH"}],"5xxJY":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $every = require('./_array-methods')(4);
$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
    // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
    every: function every(callbackfn /* , thisArg */ ) {
        return $every(this, callbackfn, arguments[1]);
    }
});

},{"./_export":"1Tgvm","./_array-methods":"9C3tD","./_strict-method":"7xXNH"}],"8tM5y":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');
$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
    // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
    reduce: function reduce(callbackfn /* , initialValue */ ) {
        return $reduce(this, callbackfn, arguments.length, arguments[1], false);
    }
});

},{"./_export":"1Tgvm","./_array-reduce":"743Di","./_strict-method":"7xXNH"}],"743Di":[function(require,module,exports) {
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var toLength = require('./_to-length');
module.exports = function(that, callbackfn, aLen, memo, isRight) {
    aFunction(callbackfn);
    var O = toObject(that);
    var self = IObject(O);
    var length = toLength(O.length);
    var index = isRight ? length - 1 : 0;
    var i = isRight ? -1 : 1;
    if (aLen < 2) for(;;){
        if (index in self) {
            memo = self[index];
            index += i;
            break;
        }
        index += i;
        if (isRight ? index < 0 : length <= index) throw TypeError('Reduce of empty array with no initial value');
    }
    for(; isRight ? index >= 0 : length > index; index += i)if (index in self) memo = callbackfn(memo, self[index], index, O);
    return memo;
};

},{"./_a-function":"55L9l","./_to-object":"7HHXi","./_iobject":"24JwK","./_to-length":"irYfS"}],"aNHFx":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');
$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
    // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
    reduceRight: function reduceRight(callbackfn /* , initialValue */ ) {
        return $reduce(this, callbackfn, arguments.length, arguments[1], true);
    }
});

},{"./_export":"1Tgvm","./_array-reduce":"743Di","./_strict-method":"7xXNH"}],"76kRN":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $indexOf = require('./_array-includes')(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [
    1
].indexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
    // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
    indexOf: function indexOf(searchElement /* , fromIndex = 0 */ ) {
        return NEGATIVE_ZERO ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
    }
});

},{"./_export":"1Tgvm","./_array-includes":"1Ebaw","./_strict-method":"7xXNH"}],"lEw3U":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [
    1
].lastIndexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
    // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */ ) {
        // convert -0 to +0
        if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
        var O = toIObject(this);
        var length = toLength(O.length);
        var index = length - 1;
        if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
        if (index < 0) index = length + index;
        for(; index >= 0; index--)if (index in O) {
            if (O[index] === searchElement) return index || 0;
        }
        return -1;
    }
});

},{"./_export":"1Tgvm","./_to-iobject":"f9RCz","./_to-integer":"cb0GT","./_to-length":"irYfS","./_strict-method":"7xXNH"}],"4xbJW":[function(require,module,exports) {
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');
$export($export.P, 'Array', {
    copyWithin: require('./_array-copy-within')
});
require('./_add-to-unscopables')('copyWithin');

},{"./_export":"1Tgvm","./_array-copy-within":"55wbB","./_add-to-unscopables":"ltQTG"}],"55wbB":[function(require,module,exports) {
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = [].copyWithin || function copyWithin(target /* = 0 */ , start /* = 0, end = @length */ ) {
    var O = toObject(this);
    var len = toLength(O.length);
    var to = toAbsoluteIndex(target, len);
    var from = toAbsoluteIndex(start, len);
    var end = arguments.length > 2 ? arguments[2] : undefined;
    var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
    var inc = 1;
    if (from < to && to < from + count) {
        inc = -1;
        from += count - 1;
        to += count - 1;
    }
    while(count-- > 0){
        if (from in O) O[to] = O[from];
        else delete O[to];
        to += inc;
        from += inc;
    }
    return O;
};

},{"./_to-object":"7HHXi","./_to-absolute-index":"1lPjf","./_to-length":"irYfS"}],"ltQTG":[function(require,module,exports) {
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function(key) {
    ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_wks":"eaoKZ","./_hide":"ddpVq"}],"bimjQ":[function(require,module,exports) {
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');
$export($export.P, 'Array', {
    fill: require('./_array-fill')
});
require('./_add-to-unscopables')('fill');

},{"./_export":"1Tgvm","./_array-fill":"dXwYX","./_add-to-unscopables":"ltQTG"}],"dXwYX":[function(require,module,exports) {
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */ ) {
    var O = toObject(this);
    var length = toLength(O.length);
    var aLen = arguments.length;
    var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
    var end = aLen > 2 ? arguments[2] : undefined;
    var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
    while(endPos > index)O[index++] = value;
    return O;
};

},{"./_to-object":"7HHXi","./_to-absolute-index":"1lPjf","./_to-length":"irYfS"}],"cKonp":[function(require,module,exports) {
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function() {
    forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
    find: function find(callbackfn /* , that = undefined */ ) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});
require('./_add-to-unscopables')(KEY);

},{"./_export":"1Tgvm","./_array-methods":"9C3tD","./_add-to-unscopables":"ltQTG"}],"t506G":[function(require,module,exports) {
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function() {
    forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
    findIndex: function findIndex(callbackfn /* , that = undefined */ ) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
});
require('./_add-to-unscopables')(KEY);

},{"./_export":"1Tgvm","./_array-methods":"9C3tD","./_add-to-unscopables":"ltQTG"}],"2S6HD":[function(require,module,exports) {
require('./_set-species')('Array');

},{"./_set-species":"1qQNM"}],"1qQNM":[function(require,module,exports) {
'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');
module.exports = function(KEY) {
    var C = global[KEY];
    if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
        configurable: true,
        get: function() {
            return this;
        }
    });
};

},{"./_global":"8xCse","./_object-dp":"cLcWd","./_descriptors":"dr2tY","./_wks":"eaoKZ"}],"1xhrt":[function(require,module,exports) {
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');
// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated); // target
    this._i = 0; // next index
    this._k = kind; // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function() {
    var O = this._t;
    var kind = this._k;
    var index = this._i++;
    if (!O || index >= O.length) {
        this._t = undefined;
        return step(1);
    }
    if (kind == 'keys') return step(0, index);
    if (kind == 'values') return step(0, O[index]);
    return step(0, [
        index,
        O[index]
    ]);
}, 'values');
// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":"ltQTG","./_iter-step":"6kbrW","./_iterators":"dITQr","./_to-iobject":"f9RCz","./_iter-define":"egJhK"}],"6kbrW":[function(require,module,exports) {
module.exports = function(done, value) {
    return {
        value: value,
        done: !!done
    };
};

},{}],"gc5Or":[function(require,module,exports) {
var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;
if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function() {
    re2[require('./_wks')('match')] = false;
    // RegExp constructor can alter flags and IsRegExp works correct with @@match
    return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
    $RegExp = function RegExp(p, f) {
        var tiRE = this instanceof $RegExp;
        var piRE = isRegExp(p);
        var fiU = f === undefined;
        return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
    };
    var proxy = function(key) {
        key in $RegExp || dP($RegExp, key, {
            configurable: true,
            get: function() {
                return Base[key];
            },
            set: function(it) {
                Base[key] = it;
            }
        });
    };
    for(var keys = gOPN(Base), i = 0; keys.length > i;)proxy(keys[i++]);
    proto.constructor = $RegExp;
    $RegExp.prototype = proto;
    require('./_redefine')(global, 'RegExp', $RegExp);
}
require('./_set-species')('RegExp');

},{"./_global":"8xCse","./_inherit-if-required":"9GGeZ","./_object-dp":"cLcWd","./_object-gopn":"jK0Om","./_is-regexp":"aGcfF","./_flags":"KuZtV","./_descriptors":"dr2tY","./_fails":"iAFH1","./_wks":"eaoKZ","./_redefine":"9vAu7","./_set-species":"1qQNM"}],"KuZtV":[function(require,module,exports) {
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function() {
    var that = anObject(this);
    var result = '';
    if (that.global) result += 'g';
    if (that.ignoreCase) result += 'i';
    if (that.multiline) result += 'm';
    if (that.unicode) result += 'u';
    if (that.sticky) result += 'y';
    return result;
};

},{"./_an-object":"kiL2X"}],"fcvkD":[function(require,module,exports) {
'use strict';
var regexpExec = require('./_regexp-exec');
require('./_export')({
    target: 'RegExp',
    proto: true,
    forced: regexpExec !== /./.exec
}, {
    exec: regexpExec
});

},{"./_regexp-exec":"lUZX6","./_export":"1Tgvm"}],"lUZX6":[function(require,module,exports) {
'use strict';
var regexpFlags = require('./_flags');
var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;
var LAST_INDEX = 'lastIndex';
var UPDATES_LAST_INDEX_WRONG = function() {
    var re1 = /a/, re2 = /b*/g;
    nativeExec.call(re1, 'a');
    nativeExec.call(re2, 'a');
    return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
}();
// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;
if (PATCH) patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;
    if (NPCG_INCLUDED) reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
    match = nativeExec.call(re, str);
    if (UPDATES_LAST_INDEX_WRONG && match) re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    if (NPCG_INCLUDED && match && match.length > 1) // Fix browsers whose `exec` methods don't consistently return `undefined`
    // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
    // eslint-disable-next-line no-loop-func
    nativeReplace.call(match[0], reCopy, function() {
        for(i = 1; i < arguments.length - 2; i++)if (arguments[i] === undefined) match[i] = undefined;
    });
    return match;
};
module.exports = patchedExec;

},{"./_flags":"KuZtV"}],"aX2Wn":[function(require,module,exports) {
'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];
var define = function(fn) {
    require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};
// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function() {
    return $toString.call({
        source: 'a',
        flags: 'b'
    }) != '/a/b';
})) define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
});
else if ($toString.name != TO_STRING) define(function toString() {
    return $toString.call(this);
});

},{"./es6.regexp.flags":"4cXUu","./_an-object":"kiL2X","./_flags":"KuZtV","./_descriptors":"dr2tY","./_redefine":"9vAu7","./_fails":"iAFH1"}],"4cXUu":[function(require,module,exports) {
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
    configurable: true,
    get: require('./_flags')
});

},{"./_descriptors":"dr2tY","./_object-dp":"cLcWd","./_flags":"KuZtV"}],"93slC":[function(require,module,exports) {
'use strict';
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');
// @@match logic
require('./_fix-re-wks')('match', 1, function(defined, MATCH, $match, maybeCallNative) {
    return [
        // `String.prototype.match` method
        // https://tc39.github.io/ecma262/#sec-string.prototype.match
        function match(regexp) {
            var O = defined(this);
            var fn = regexp == undefined ? undefined : regexp[MATCH];
            return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
        },
        // `RegExp.prototype[@@match]` method
        // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
        function(regexp) {
            var res = maybeCallNative($match, regexp, this);
            if (res.done) return res.value;
            var rx = anObject(regexp);
            var S = String(this);
            if (!rx.global) return regExpExec(rx, S);
            var fullUnicode = rx.unicode;
            rx.lastIndex = 0;
            var A = [];
            var n = 0;
            var result;
            while((result = regExpExec(rx, S)) !== null){
                var matchStr = String(result[0]);
                A[n] = matchStr;
                if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                n++;
            }
            return n === 0 ? null : A;
        }
    ];
});

},{"./_an-object":"kiL2X","./_to-length":"irYfS","./_advance-string-index":"dBZmz","./_regexp-exec-abstract":"27rgt","./_fix-re-wks":"80W9B"}],"dBZmz":[function(require,module,exports) {
'use strict';
var at = require('./_string-at')(true);
// `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function(S, index, unicode) {
    return index + (unicode ? at(S, index).length : 1);
};

},{"./_string-at":"rbgP0"}],"27rgt":[function(require,module,exports) {
'use strict';
var classof = require('./_classof');
var builtinExec = RegExp.prototype.exec;
// `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function(R, S) {
    var exec = R.exec;
    if (typeof exec === 'function') {
        var result = exec.call(R, S);
        if (typeof result !== 'object') throw new TypeError('RegExp exec method returned something other than an Object or null');
        return result;
    }
    if (classof(R) !== 'RegExp') throw new TypeError('RegExp#exec called on incompatible receiver');
    return builtinExec.call(R, S);
};

},{"./_classof":"5TIen"}],"80W9B":[function(require,module,exports) {
'use strict';
require('./es6.regexp.exec');
var redefine = require('./_redefine');
var hide = require('./_hide');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');
var regexpExec = require('./_regexp-exec');
var SPECIES = wks('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
    // #replace needs built-in support for named groups.
    // #match works fine because it just return the exec results, even if it has
    // a "grops" property.
    var re = /./;
    re.exec = function() {
        var result = [];
        result.groups = {
            a: '7'
        };
        return result;
    };
    return ''.replace(re, '$<a>') !== '7';
});
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function() {
    // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
    var re = /(?:)/;
    var originalExec = re.exec;
    re.exec = function() {
        return originalExec.apply(this, arguments);
    };
    var result = 'ab'.split(re);
    return result.length === 2 && result[0] === 'a' && result[1] === 'b';
}();
module.exports = function(KEY, length, exec) {
    var SYMBOL = wks(KEY);
    var DELEGATES_TO_SYMBOL = !fails(function() {
        // String methods call symbol-named RegEp methods
        var O = {};
        O[SYMBOL] = function() {
            return 7;
        };
        return ''[KEY](O) != 7;
    });
    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function() {
        // Symbol-named RegExp methods call .exec
        var execCalled = false;
        var re = /a/;
        re.exec = function() {
            execCalled = true;
            return null;
        };
        if (KEY === 'split') {
            // RegExp[@@split] doesn't call the regex's exec method, but first creates
            // a new one. We need to return the patched regex when creating the new one.
            re.constructor = {};
            re.constructor[SPECIES] = function() {
                return re;
            };
        }
        re[SYMBOL]('');
        return !execCalled;
    }) : undefined;
    if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
        var nativeRegExpMethod = /./[SYMBOL];
        var fns = exec(defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
            if (regexp.exec === regexpExec) {
                if (DELEGATES_TO_SYMBOL && !forceStringMethod) // The native String method already delegates to @@method (this
                // polyfilled function), leasing to infinite recursion.
                // We avoid it by directly calling the native @@method method.
                return {
                    done: true,
                    value: nativeRegExpMethod.call(regexp, str, arg2)
                };
                return {
                    done: true,
                    value: nativeMethod.call(str, regexp, arg2)
                };
            }
            return {
                done: false
            };
        });
        var strfn = fns[0];
        var rxfn = fns[1];
        redefine(String.prototype, KEY, strfn);
        hide(RegExp.prototype, SYMBOL, length == 2 ? function(string, arg) {
            return rxfn.call(string, this, arg);
        } : function(string) {
            return rxfn.call(string, this);
        });
    }
};

},{"./es6.regexp.exec":"fcvkD","./_redefine":"9vAu7","./_hide":"ddpVq","./_fails":"iAFH1","./_defined":"4Lj5U","./_wks":"eaoKZ","./_regexp-exec":"lUZX6"}],"bsjVi":[function(require,module,exports) {
'use strict';
var anObject = require('./_an-object');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;
var maybeToString = function(it) {
    return it === undefined ? it : String(it);
};
// @@replace logic
require('./_fix-re-wks')('replace', 2, function(defined, REPLACE, $replace, maybeCallNative) {
    return [
        // `String.prototype.replace` method
        // https://tc39.github.io/ecma262/#sec-string.prototype.replace
        function replace(searchValue, replaceValue) {
            var O = defined(this);
            var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
            return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
        },
        // `RegExp.prototype[@@replace]` method
        // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
        function(regexp, replaceValue) {
            var res = maybeCallNative($replace, regexp, this, replaceValue);
            if (res.done) return res.value;
            var rx = anObject(regexp);
            var S = String(this);
            var functionalReplace = typeof replaceValue === 'function';
            if (!functionalReplace) replaceValue = String(replaceValue);
            var global = rx.global;
            if (global) {
                var fullUnicode = rx.unicode;
                rx.lastIndex = 0;
            }
            var results = [];
            while(true){
                var result = regExpExec(rx, S);
                if (result === null) break;
                results.push(result);
                if (!global) break;
                var matchStr = String(result[0]);
                if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
            }
            var accumulatedResult = '';
            var nextSourcePosition = 0;
            for(var i = 0; i < results.length; i++){
                result = results[i];
                var matched = String(result[0]);
                var position = max(min(toInteger(result.index), S.length), 0);
                var captures = [];
                // NOTE: This is equivalent to
                //   captures = result.slice(1).map(maybeToString)
                // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
                // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
                // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
                for(var j = 1; j < result.length; j++)captures.push(maybeToString(result[j]));
                var namedCaptures = result.groups;
                if (functionalReplace) {
                    var replacerArgs = [
                        matched
                    ].concat(captures, position, S);
                    if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
                    var replacement = String(replaceValue.apply(undefined, replacerArgs));
                } else replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                if (position >= nextSourcePosition) {
                    accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                    nextSourcePosition = position + matched.length;
                }
            }
            return accumulatedResult + S.slice(nextSourcePosition);
        }
    ];
    // https://tc39.github.io/ecma262/#sec-getsubstitution
    function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
        var tailPos = position + matched.length;
        var m = captures.length;
        var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
        if (namedCaptures !== undefined) {
            namedCaptures = toObject(namedCaptures);
            symbols = SUBSTITUTION_SYMBOLS;
        }
        return $replace.call(replacement, symbols, function(match, ch) {
            var capture;
            switch(ch.charAt(0)){
                case '$':
                    return '$';
                case '&':
                    return matched;
                case '`':
                    return str.slice(0, position);
                case "'":
                    return str.slice(tailPos);
                case '<':
                    capture = namedCaptures[ch.slice(1, -1)];
                    break;
                default:
                    var n = +ch;
                    if (n === 0) return match;
                    if (n > m) {
                        var f = floor(n / 10);
                        if (f === 0) return match;
                        if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                        return match;
                    }
                    capture = captures[n - 1];
            }
            return capture === undefined ? '' : capture;
        });
    }
});

},{"./_an-object":"kiL2X","./_to-object":"7HHXi","./_to-length":"irYfS","./_to-integer":"cb0GT","./_advance-string-index":"dBZmz","./_regexp-exec-abstract":"27rgt","./_fix-re-wks":"80W9B"}],"ldewt":[function(require,module,exports) {
'use strict';
var anObject = require('./_an-object');
var sameValue = require('./_same-value');
var regExpExec = require('./_regexp-exec-abstract');
// @@search logic
require('./_fix-re-wks')('search', 1, function(defined, SEARCH, $search, maybeCallNative) {
    return [
        // `String.prototype.search` method
        // https://tc39.github.io/ecma262/#sec-string.prototype.search
        function search(regexp) {
            var O = defined(this);
            var fn = regexp == undefined ? undefined : regexp[SEARCH];
            return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
        },
        // `RegExp.prototype[@@search]` method
        // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
        function(regexp) {
            var res = maybeCallNative($search, regexp, this);
            if (res.done) return res.value;
            var rx = anObject(regexp);
            var S = String(this);
            var previousLastIndex = rx.lastIndex;
            if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
            var result = regExpExec(rx, S);
            if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
            return result === null ? -1 : result.index;
        }
    ];
});

},{"./_an-object":"kiL2X","./_same-value":"94M5S","./_regexp-exec-abstract":"27rgt","./_fix-re-wks":"80W9B"}],"iJScv":[function(require,module,exports) {
'use strict';
var isRegExp = require('./_is-regexp');
var anObject = require('./_an-object');
var speciesConstructor = require('./_species-constructor');
var advanceStringIndex = require('./_advance-string-index');
var toLength = require('./_to-length');
var callRegExpExec = require('./_regexp-exec-abstract');
var regexpExec = require('./_regexp-exec');
var fails = require('./_fails');
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 4294967295;
// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function() {
    RegExp(MAX_UINT32, 'y');
});
// @@split logic
require('./_fix-re-wks')('split', 2, function(defined, SPLIT, $split, maybeCallNative) {
    var internalSplit;
    if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) // based on es5-shim implementation, need to rework it
    internalSplit = function(separator, limit) {
        var string = String(this);
        if (separator === undefined && limit === 0) return [];
        // If `separator` is not a regex, use native split
        if (!isRegExp(separator)) return $split.call(string, separator, limit);
        var output = [];
        var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
        var lastLastIndex = 0;
        var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
        // Make `global` and avoid `lastIndex` issues by working with a copy
        var separatorCopy = new RegExp(separator.source, flags + 'g');
        var match, lastIndex, lastLength;
        while(match = regexpExec.call(separatorCopy, string)){
            lastIndex = separatorCopy[LAST_INDEX];
            if (lastIndex > lastLastIndex) {
                output.push(string.slice(lastLastIndex, match.index));
                if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
                lastLength = match[0][LENGTH];
                lastLastIndex = lastIndex;
                if (output[LENGTH] >= splitLimit) break;
            }
            if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
        }
        if (lastLastIndex === string[LENGTH]) {
            if (lastLength || !separatorCopy.test('')) output.push('');
        } else output.push(string.slice(lastLastIndex));
        return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
    else if ('0'[$SPLIT](undefined, 0)[LENGTH]) internalSplit = function(separator, limit) {
        return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
    else internalSplit = $split;
    return [
        // `String.prototype.split` method
        // https://tc39.github.io/ecma262/#sec-string.prototype.split
        function split(separator, limit) {
            var O = defined(this);
            var splitter = separator == undefined ? undefined : separator[SPLIT];
            return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
        },
        // `RegExp.prototype[@@split]` method
        // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
        //
        // NOTE: This cannot be properly polyfilled in engines that don't support
        // the 'y' flag.
        function(regexp, limit) {
            var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
            if (res.done) return res.value;
            var rx = anObject(regexp);
            var S = String(this);
            var C = speciesConstructor(rx, RegExp);
            var unicodeMatching = rx.unicode;
            var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g');
            // ^(? + rx + ) is needed, in combination with some S slicing, to
            // simulate the 'y' flag.
            var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
            var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
            if (lim === 0) return [];
            if (S.length === 0) return callRegExpExec(splitter, S) === null ? [
                S
            ] : [];
            var p = 0;
            var q = 0;
            var A = [];
            while(q < S.length){
                splitter.lastIndex = SUPPORTS_Y ? q : 0;
                var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
                var e;
                if (z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) q = advanceStringIndex(S, q, unicodeMatching);
                else {
                    A.push(S.slice(p, q));
                    if (A.length === lim) return A;
                    for(var i = 1; i <= z.length - 1; i++){
                        A.push(z[i]);
                        if (A.length === lim) return A;
                    }
                    q = p = e;
                }
            }
            A.push(S.slice(p));
            return A;
        }
    ];
});

},{"./_is-regexp":"aGcfF","./_an-object":"kiL2X","./_species-constructor":"8Vo8d","./_advance-string-index":"dBZmz","./_to-length":"irYfS","./_regexp-exec-abstract":"27rgt","./_regexp-exec":"lUZX6","./_fails":"iAFH1","./_fix-re-wks":"80W9B"}],"8Vo8d":[function(require,module,exports) {
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function(O, D) {
    var C = anObject(O).constructor;
    var S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_an-object":"kiL2X","./_a-function":"55L9l","./_wks":"eaoKZ"}],"2sSjP":[function(require,module,exports) {
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var userAgent = require('./_user-agent');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function() {};
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
var USE_NATIVE = !!function() {
    try {
        // correct subclassing with @@species support
        var promise = $Promise.resolve(1);
        var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function(exec) {
            exec(empty, empty);
        };
        // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
        return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise && v8.indexOf('6.6') !== 0 && userAgent.indexOf('Chrome/66') === -1;
    } catch (e) {}
}();
// helpers
var isThenable = function(it) {
    var then;
    return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function(promise, isReject) {
    if (promise._n) return;
    promise._n = true;
    var chain = promise._c;
    microtask(function() {
        var value = promise._v;
        var ok = promise._s == 1;
        var i = 0;
        var run = function(reaction) {
            var handler = ok ? reaction.ok : reaction.fail;
            var resolve = reaction.resolve;
            var reject = reaction.reject;
            var domain = reaction.domain;
            var result, then, exited;
            try {
                if (handler) {
                    if (!ok) {
                        if (promise._h == 2) onHandleUnhandled(promise);
                        promise._h = 1;
                    }
                    if (handler === true) result = value;
                    else {
                        if (domain) domain.enter();
                        result = handler(value); // may throw
                        if (domain) {
                            domain.exit();
                            exited = true;
                        }
                    }
                    if (result === reaction.promise) reject(TypeError('Promise-chain cycle'));
                    else if (then = isThenable(result)) then.call(result, resolve, reject);
                    else resolve(result);
                } else reject(value);
            } catch (e) {
                if (domain && !exited) domain.exit();
                reject(e);
            }
        };
        while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
        promise._c = [];
        promise._n = false;
        if (isReject && !promise._h) onUnhandled(promise);
    });
};
var onUnhandled = function(promise) {
    task.call(global, function() {
        var value = promise._v;
        var unhandled = isUnhandled(promise);
        var result, handler, console;
        if (unhandled) {
            result = perform(function() {
                if (isNode) process.emit('unhandledRejection', value, promise);
                else if (handler = global.onunhandledrejection) handler({
                    promise: promise,
                    reason: value
                });
                else if ((console = global.console) && console.error) console.error('Unhandled promise rejection', value);
            });
            // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
            promise._h = isNode || isUnhandled(promise) ? 2 : 1;
        }
        promise._a = undefined;
        if (unhandled && result.e) throw result.v;
    });
};
var isUnhandled = function(promise) {
    return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function(promise) {
    task.call(global, function() {
        var handler;
        if (isNode) process.emit('rejectionHandled', promise);
        else if (handler = global.onrejectionhandled) handler({
            promise: promise,
            reason: promise._v
        });
    });
};
var $reject = function(value) {
    var promise = this;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise; // unwrap
    promise._v = value;
    promise._s = 2;
    if (!promise._a) promise._a = promise._c.slice();
    notify(promise, true);
};
var $resolve = function(value) {
    var promise = this;
    var then;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise; // unwrap
    try {
        if (promise === value) throw TypeError("Promise can't be resolved itself");
        if (then = isThenable(value)) microtask(function() {
            var wrapper = {
                _w: promise,
                _d: false
            }; // wrap
            try {
                then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
                $reject.call(wrapper, e);
            }
        });
        else {
            promise._v = value;
            promise._s = 1;
            notify(promise, false);
        }
    } catch (e) {
        $reject.call({
            _w: promise,
            _d: false
        }, e); // wrap
    }
};
// constructor polyfill
if (!USE_NATIVE) {
    // 25.4.3.1 Promise(executor)
    $Promise = function Promise(executor) {
        anInstance(this, $Promise, PROMISE, '_h');
        aFunction(executor);
        Internal.call(this);
        try {
            executor(ctx($resolve, this, 1), ctx($reject, this, 1));
        } catch (err) {
            $reject.call(this, err);
        }
    };
    // eslint-disable-next-line no-unused-vars
    Internal = function Promise(executor) {
        this._c = []; // <- awaiting reactions
        this._a = undefined; // <- checked in isUnhandled reactions
        this._s = 0; // <- state
        this._d = false; // <- done
        this._v = undefined; // <- value
        this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
        this._n = false; // <- notify
    };
    Internal.prototype = require('./_redefine-all')($Promise.prototype, {
        // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
        then: function then(onFulfilled, onRejected) {
            var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
            reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
            reaction.fail = typeof onRejected == 'function' && onRejected;
            reaction.domain = isNode ? process.domain : undefined;
            this._c.push(reaction);
            if (this._a) this._a.push(reaction);
            if (this._s) notify(this, false);
            return reaction.promise;
        },
        // 25.4.5.1 Promise.prototype.catch(onRejected)
        'catch': function(onRejected) {
            return this.then(undefined, onRejected);
        }
    });
    OwnPromiseCapability = function() {
        var promise = new Internal();
        this.promise = promise;
        this.resolve = ctx($resolve, promise, 1);
        this.reject = ctx($reject, promise, 1);
    };
    newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
        return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
    };
}
$export($export.G + $export.W + $export.F * !USE_NATIVE, {
    Promise: $Promise
});
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];
// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
    // 25.4.4.5 Promise.reject(r)
    reject: function reject(r) {
        var capability = newPromiseCapability(this);
        var $$reject = capability.reject;
        $$reject(r);
        return capability.promise;
    }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
    // 25.4.4.6 Promise.resolve(x)
    resolve: function resolve(x) {
        return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
    }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function(iter) {
    $Promise.all(iter)['catch'](empty);
})), PROMISE, {
    // 25.4.4.1 Promise.all(iterable)
    all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
            var values = [];
            var index = 0;
            var remaining = 1;
            forOf(iterable, false, function(promise) {
                var $index = index++;
                var alreadyCalled = false;
                values.push(undefined);
                remaining++;
                C.resolve(promise).then(function(value) {
                    if (alreadyCalled) return;
                    alreadyCalled = true;
                    values[$index] = value;
                    --remaining || resolve(values);
                }, reject);
            });
            --remaining || resolve(values);
        });
        if (result.e) reject(result.v);
        return capability.promise;
    },
    // 25.4.4.4 Promise.race(iterable)
    race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var reject = capability.reject;
        var result = perform(function() {
            forOf(iterable, false, function(promise) {
                C.resolve(promise).then(capability.resolve, reject);
            });
        });
        if (result.e) reject(result.v);
        return capability.promise;
    }
});

},{"./_library":"lmtqY","./_global":"8xCse","./_ctx":"4rQSm","./_classof":"5TIen","./_export":"1Tgvm","./_is-object":"eIE5K","./_a-function":"55L9l","./_an-instance":"ivm35","./_for-of":"9a8I8","./_species-constructor":"8Vo8d","./_task":"bPiT9","./_microtask":"8lwWF","./_new-promise-capability":"clM6P","./_perform":"7Nx5Z","./_user-agent":"9eCfU","./_promise-resolve":"58Dua","./_wks":"eaoKZ","./_redefine-all":"6Mnp5","./_set-to-string-tag":"7YXlq","./_set-species":"1qQNM","./_core":"4o9Ko","./_iter-detect":"3KQwU"}],"ivm35":[function(require,module,exports) {
module.exports = function(it, Constructor, name, forbiddenField) {
    if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) throw TypeError(name + ': incorrect invocation!');
    return it;
};

},{}],"9a8I8":[function(require,module,exports) {
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR) {
    var iterFn = ITERATOR ? function() {
        return iterable;
    } : getIterFn(iterable);
    var f = ctx(fn, that, entries ? 2 : 1);
    var index = 0;
    var length, step, iterator, result;
    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
    // fast case for arrays with default iterator
    if (isArrayIter(iterFn)) for(length = toLength(iterable.length); length > index; index++){
        result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
        if (result === BREAK || result === RETURN) return result;
    }
    else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done;){
        result = call(iterator, f, step.value, entries);
        if (result === BREAK || result === RETURN) return result;
    }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_ctx":"4rQSm","./_iter-call":"hZ7Tf","./_is-array-iter":"ipP6u","./_an-object":"kiL2X","./_to-length":"irYfS","./core.get-iterator-method":"hb865"}],"bPiT9":[function(require,module,exports) {
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function() {
    var id = +this;
    // eslint-disable-next-line no-prototype-builtins
    if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
    }
};
var listener = function(event) {
    run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
    setTask = function setImmediate(fn) {
        var args = [];
        var i = 1;
        while(arguments.length > i)args.push(arguments[i++]);
        queue[++counter] = function() {
            // eslint-disable-next-line no-new-func
            invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
    };
    clearTask = function clearImmediate(id) {
        delete queue[id];
    };
    // Node.js 0.8-
    if (require('./_cof')(process) == 'process') defer = function(id) {
        process.nextTick(ctx(run, id, 1));
    };
    else if (Dispatch && Dispatch.now) defer = function(id) {
        Dispatch.now(ctx(run, id, 1));
    };
    else if (MessageChannel) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = listener;
        defer = ctx(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function(id) {
            global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listener, false);
    // IE8-
    } else if (ONREADYSTATECHANGE in cel('script')) defer = function(id) {
        html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
        };
    };
    else defer = function(id) {
        setTimeout(ctx(run, id, 1), 0);
    };
}
module.exports = {
    set: setTask,
    clear: clearTask
};

},{"./_ctx":"4rQSm","./_invoke":"c7Bab","./_html":"lPhWk","./_dom-create":"2qBag","./_global":"8xCse","./_cof":"frIbo"}],"8lwWF":[function(require,module,exports) {
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';
module.exports = function() {
    var head, last, notify;
    var flush = function() {
        var parent, fn;
        if (isNode && (parent = process.domain)) parent.exit();
        while(head){
            fn = head.fn;
            head = head.next;
            try {
                fn();
            } catch (e) {
                if (head) notify();
                else last = undefined;
                throw e;
            }
        }
        last = undefined;
        if (parent) parent.enter();
    };
    // Node.js
    if (isNode) notify = function() {
        process.nextTick(flush);
    };
    else if (Observer && !(global.navigator && global.navigator.standalone)) {
        var toggle = true;
        var node = document.createTextNode('');
        new Observer(flush).observe(node, {
            characterData: true
        }); // eslint-disable-line no-new
        notify = function() {
            node.data = toggle = !toggle;
        };
    // environments with maybe non-completely correct, but existent Promise
    } else if (Promise && Promise.resolve) {
        // Promise.resolve without an argument throws an error in LG WebOS 2
        var promise = Promise.resolve(undefined);
        notify = function() {
            promise.then(flush);
        };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout
    } else notify = function() {
        // strange IE + webpack dev server bug - use .call(global)
        macrotask.call(global, flush);
    };
    return function(fn) {
        var task = {
            fn: fn,
            next: undefined
        };
        if (last) last.next = task;
        if (!head) {
            head = task;
            notify();
        }
        last = task;
    };
};

},{"./_global":"8xCse","./_task":"bPiT9","./_cof":"frIbo"}],"clM6P":[function(require,module,exports) {
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');
function PromiseCapability(C) {
    var resolve, reject;
    this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
    });
    this.resolve = aFunction(resolve);
    this.reject = aFunction(reject);
}
module.exports.f = function(C) {
    return new PromiseCapability(C);
};

},{"./_a-function":"55L9l"}],"7Nx5Z":[function(require,module,exports) {
module.exports = function(exec) {
    try {
        return {
            e: false,
            v: exec()
        };
    } catch (e) {
        return {
            e: true,
            v: e
        };
    }
};

},{}],"9eCfU":[function(require,module,exports) {
var global = require('./_global');
var navigator = global.navigator;
module.exports = navigator && navigator.userAgent || '';

},{"./_global":"8xCse"}],"58Dua":[function(require,module,exports) {
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');
module.exports = function(C, x) {
    anObject(C);
    if (isObject(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
};

},{"./_an-object":"kiL2X","./_is-object":"eIE5K","./_new-promise-capability":"clM6P"}],"6Mnp5":[function(require,module,exports) {
var redefine = require('./_redefine');
module.exports = function(target, src, safe) {
    for(var key in src)redefine(target, key, src[key], safe);
    return target;
};

},{"./_redefine":"9vAu7"}],"1kXi9":[function(require,module,exports) {
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';
// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function(get) {
    return function Map() {
        return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
}, {
    // 23.1.3.6 Map.prototype.get(key)
    get: function get(key) {
        var entry = strong.getEntry(validate(this, MAP), key);
        return entry && entry.v;
    },
    // 23.1.3.9 Map.prototype.set(key, value)
    set: function set(key, value) {
        return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
    }
}, strong, true);

},{"./_collection-strong":"65T55","./_validate-collection":"8oFKK","./_collection":"6SH4d"}],"65T55":[function(require,module,exports) {
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';
var getEntry = function(that, key) {
    // fast case
    var index = fastKey(key);
    var entry;
    if (index !== 'F') return that._i[index];
    // frozen object case
    for(entry = that._f; entry; entry = entry.n){
        if (entry.k == key) return entry;
    }
};
module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
        var C = wrapper(function(that, iterable) {
            anInstance(that, C, NAME, '_i');
            that._t = NAME; // collection type
            that._i = create(null); // index
            that._f = undefined; // first entry
            that._l = undefined; // last entry
            that[SIZE] = 0; // size
            if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        });
        redefineAll(C.prototype, {
            // 23.1.3.1 Map.prototype.clear()
            // 23.2.3.2 Set.prototype.clear()
            clear: function clear() {
                for(var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n){
                    entry.r = true;
                    if (entry.p) entry.p = entry.p.n = undefined;
                    delete data[entry.i];
                }
                that._f = that._l = undefined;
                that[SIZE] = 0;
            },
            // 23.1.3.3 Map.prototype.delete(key)
            // 23.2.3.4 Set.prototype.delete(value)
            'delete': function(key) {
                var that = validate(this, NAME);
                var entry = getEntry(that, key);
                if (entry) {
                    var next = entry.n;
                    var prev = entry.p;
                    delete that._i[entry.i];
                    entry.r = true;
                    if (prev) prev.n = next;
                    if (next) next.p = prev;
                    if (that._f == entry) that._f = next;
                    if (that._l == entry) that._l = prev;
                    that[SIZE]--;
                }
                return !!entry;
            },
            // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
            // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
            forEach: function forEach(callbackfn /* , that = undefined */ ) {
                validate(this, NAME);
                var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
                var entry;
                while(entry = entry ? entry.n : this._f){
                    f(entry.v, entry.k, this);
                    // revert to the last existing entry
                    while(entry && entry.r)entry = entry.p;
                }
            },
            // 23.1.3.7 Map.prototype.has(key)
            // 23.2.3.7 Set.prototype.has(value)
            has: function has(key) {
                return !!getEntry(validate(this, NAME), key);
            }
        });
        if (DESCRIPTORS) dP(C.prototype, 'size', {
            get: function() {
                return validate(this, NAME)[SIZE];
            }
        });
        return C;
    },
    def: function(that, key, value) {
        var entry = getEntry(that, key);
        var prev, index;
        // change existing entry
        if (entry) entry.v = value;
        else {
            that._l = entry = {
                i: index = fastKey(key, true),
                k: key,
                v: value,
                p: prev = that._l,
                n: undefined,
                r: false // <- removed
            };
            if (!that._f) that._f = entry;
            if (prev) prev.n = entry;
            that[SIZE]++;
            // add to index
            if (index !== 'F') that._i[index] = entry;
        }
        return that;
    },
    getEntry: getEntry,
    setStrong: function(C, NAME, IS_MAP) {
        // add .keys, .values, .entries, [@@iterator]
        // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
        $iterDefine(C, NAME, function(iterated, kind) {
            this._t = validate(iterated, NAME); // target
            this._k = kind; // kind
            this._l = undefined; // previous
        }, function() {
            var that = this;
            var kind = that._k;
            var entry = that._l;
            // revert to the last existing entry
            while(entry && entry.r)entry = entry.p;
            // get next entry
            if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
                // or finish the iteration
                that._t = undefined;
                return step(1);
            }
            // return step by kind
            if (kind == 'keys') return step(0, entry.k);
            if (kind == 'values') return step(0, entry.v);
            return step(0, [
                entry.k,
                entry.v
            ]);
        }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
        // add [@@species], 23.1.2.2, 23.2.2.2
        setSpecies(NAME);
    }
};

},{"./_object-dp":"cLcWd","./_object-create":"b4m8n","./_redefine-all":"6Mnp5","./_ctx":"4rQSm","./_an-instance":"ivm35","./_for-of":"9a8I8","./_iter-define":"egJhK","./_iter-step":"6kbrW","./_set-species":"1qQNM","./_descriptors":"dr2tY","./_meta":"043Qa","./_validate-collection":"8oFKK"}],"8oFKK":[function(require,module,exports) {
var isObject = require('./_is-object');
module.exports = function(it, TYPE) {
    if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
    return it;
};

},{"./_is-object":"eIE5K"}],"6SH4d":[function(require,module,exports) {
'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');
module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = global[NAME];
    var C = Base;
    var ADDER = IS_MAP ? 'set' : 'add';
    var proto = C && C.prototype;
    var O = {};
    var fixMethod = function(KEY) {
        var fn = proto[KEY];
        redefine(proto, KEY, KEY == 'delete' ? function(a) {
            return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
        } : KEY == 'has' ? function has(a) {
            return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
        } : KEY == 'get' ? function get(a) {
            return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
        } : KEY == 'add' ? function add(a) {
            fn.call(this, a === 0 ? 0 : a);
            return this;
        } : function set(a, b) {
            fn.call(this, a === 0 ? 0 : a, b);
            return this;
        });
    };
    if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function() {
        new C().entries().next();
    }))) {
        // create collection constructor
        C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
        redefineAll(C.prototype, methods);
        meta.NEED = true;
    } else {
        var instance = new C();
        // early implementations not supports chaining
        var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
        // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
        var THROWS_ON_PRIMITIVES = fails(function() {
            instance.has(1);
        });
        // most early implementations doesn't supports iterables, most modern - not close it correctly
        var ACCEPT_ITERABLES = $iterDetect(function(iter) {
            new C(iter);
        }); // eslint-disable-line no-new
        // for early implementations -0 and +0 not the same
        var BUGGY_ZERO = !IS_WEAK && fails(function() {
            // V8 ~ Chromium 42- fails only with 5+ elements
            var $instance = new C();
            var index = 5;
            while(index--)$instance[ADDER](index, index);
            return !$instance.has(-0);
        });
        if (!ACCEPT_ITERABLES) {
            C = wrapper(function(target, iterable) {
                anInstance(target, C, NAME);
                var that = inheritIfRequired(new Base(), target, C);
                if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
                return that;
            });
            C.prototype = proto;
            proto.constructor = C;
        }
        if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
            fixMethod('delete');
            fixMethod('has');
            IS_MAP && fixMethod('get');
        }
        if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
        // weak collections should not contains .clear method
        if (IS_WEAK && proto.clear) delete proto.clear;
    }
    setToStringTag(C, NAME);
    O[NAME] = C;
    $export($export.G + $export.W + $export.F * (C != Base), O);
    if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
    return C;
};

},{"./_global":"8xCse","./_export":"1Tgvm","./_redefine":"9vAu7","./_redefine-all":"6Mnp5","./_meta":"043Qa","./_for-of":"9a8I8","./_an-instance":"ivm35","./_is-object":"eIE5K","./_fails":"iAFH1","./_iter-detect":"3KQwU","./_set-to-string-tag":"7YXlq","./_inherit-if-required":"9GGeZ"}],"61Y2Y":[function(require,module,exports) {
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';
// 23.2 Set Objects
module.exports = require('./_collection')(SET, function(get) {
    return function Set() {
        return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
}, {
    // 23.2.3.1 Set.prototype.add(value)
    add: function add(value) {
        return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
    }
}, strong);

},{"./_collection-strong":"65T55","./_validate-collection":"8oFKK","./_collection":"6SH4d"}],"dAOwL":[function(require,module,exports) {
'use strict';
var global = require('./_global');
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var validate = require('./_validate-collection');
var NATIVE_WEAK_MAP = require('./_validate-collection');
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;
var wrapper = function(get) {
    return function WeakMap() {
        return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
};
var methods = {
    // 23.3.3.3 WeakMap.prototype.get(key)
    get: function get(key) {
        if (isObject(key)) {
            var data = getWeak(key);
            if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
            return data ? data[this._i] : undefined;
        }
    },
    // 23.3.3.5 WeakMap.prototype.set(key, value)
    set: function set(key, value) {
        return weak.def(validate(this, WEAK_MAP), key, value);
    }
};
// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);
// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
    InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
    assign(InternalMap.prototype, methods);
    meta.NEED = true;
    each([
        'delete',
        'has',
        'get',
        'set'
    ], function(key) {
        var proto = $WeakMap.prototype;
        var method = proto[key];
        redefine(proto, key, function(a, b) {
            // store frozen objects on internal weakmap shim
            if (isObject(a) && !isExtensible(a)) {
                if (!this._f) this._f = new InternalMap();
                var result = this._f[key](a, b);
                return key == 'set' ? this : result;
            // store all the rest on native weakmap
            }
            return method.call(this, a, b);
        });
    });
}

},{"./_global":"8xCse","./_array-methods":"9C3tD","./_redefine":"9vAu7","./_meta":"043Qa","./_object-assign":"h8iBq","./_collection-weak":"lBiRK","./_is-object":"eIE5K","./_validate-collection":"8oFKK","./_collection":"6SH4d"}],"lBiRK":[function(require,module,exports) {
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;
// fallback for uncaught frozen keys
var uncaughtFrozenStore = function(that) {
    return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function() {
    this.a = [];
};
var findUncaughtFrozen = function(store, key) {
    return arrayFind(store.a, function(it) {
        return it[0] === key;
    });
};
UncaughtFrozenStore.prototype = {
    get: function(key) {
        var entry = findUncaughtFrozen(this, key);
        if (entry) return entry[1];
    },
    has: function(key) {
        return !!findUncaughtFrozen(this, key);
    },
    set: function(key, value) {
        var entry = findUncaughtFrozen(this, key);
        if (entry) entry[1] = value;
        else this.a.push([
            key,
            value
        ]);
    },
    'delete': function(key) {
        var index = arrayFindIndex(this.a, function(it) {
            return it[0] === key;
        });
        if (~index) this.a.splice(index, 1);
        return !!~index;
    }
};
module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
        var C = wrapper(function(that, iterable) {
            anInstance(that, C, NAME, '_i');
            that._t = NAME; // collection type
            that._i = id++; // collection id
            that._l = undefined; // leak store for uncaught frozen objects
            if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        });
        redefineAll(C.prototype, {
            // 23.3.3.2 WeakMap.prototype.delete(key)
            // 23.4.3.3 WeakSet.prototype.delete(value)
            'delete': function(key) {
                if (!isObject(key)) return false;
                var data = getWeak(key);
                if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
                return data && $has(data, this._i) && delete data[this._i];
            },
            // 23.3.3.4 WeakMap.prototype.has(key)
            // 23.4.3.4 WeakSet.prototype.has(value)
            has: function has(key) {
                if (!isObject(key)) return false;
                var data = getWeak(key);
                if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
                return data && $has(data, this._i);
            }
        });
        return C;
    },
    def: function(that, key, value) {
        var data = getWeak(anObject(key), true);
        if (data === true) uncaughtFrozenStore(that).set(key, value);
        else data[that._i] = value;
        return that;
    },
    ufstore: uncaughtFrozenStore
};

},{"./_redefine-all":"6Mnp5","./_meta":"043Qa","./_an-object":"kiL2X","./_is-object":"eIE5K","./_an-instance":"ivm35","./_for-of":"9a8I8","./_array-methods":"9C3tD","./_has":"biQ7v","./_validate-collection":"8oFKK"}],"blRp6":[function(require,module,exports) {
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';
// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function(get) {
    return function WeakSet() {
        return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
}, {
    // 23.4.3.1 WeakSet.prototype.add(value)
    add: function add(value) {
        return weak.def(validate(this, WEAK_SET), value, true);
    }
}, weak, false, true);

},{"./_collection-weak":"lBiRK","./_validate-collection":"8oFKK","./_collection":"6SH4d"}],"dp2Nn":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';
$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {
    ArrayBuffer: $ArrayBuffer
});
$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
    // 24.1.3.1 ArrayBuffer.isView(arg)
    isView: function isView(it) {
        return $isView && $isView(it) || isObject(it) && VIEW in it;
    }
});
$export($export.P + $export.U + $export.F * require('./_fails')(function() {
    return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
    // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
    slice: function slice(start, end) {
        if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
        var len = anObject(this).byteLength;
        var first = toAbsoluteIndex(start, len);
        var fin = toAbsoluteIndex(end === undefined ? len : end, len);
        var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
        var viewS = new $DataView(this);
        var viewT = new $DataView(result);
        var index = 0;
        while(first < fin)viewT.setUint8(index++, viewS.getUint8(first++));
        return result;
    }
});
require('./_set-species')(ARRAY_BUFFER);

},{"./_export":"1Tgvm","./_typed":"euXsj","./_typed-buffer":"bO20V","./_an-object":"kiL2X","./_to-absolute-index":"1lPjf","./_to-length":"irYfS","./_is-object":"eIE5K","./_global":"8xCse","./_species-constructor":"8Vo8d","./_fails":"iAFH1","./_set-species":"1qQNM"}],"euXsj":[function(require,module,exports) {
var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;
var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');
while(i < l)if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
} else CONSTR = false;
module.exports = {
    ABV: ABV,
    CONSTR: CONSTR,
    TYPED: TYPED,
    VIEW: VIEW
};

},{"./_global":"8xCse","./_hide":"ddpVq","./_uid":"gBq6n"}],"bO20V":[function(require,module,exports) {
'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;
// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
    var buffer = new Array(nBytes);
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
    var i = 0;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    var e, m, c;
    value = abs(value);
    // eslint-disable-next-line no-self-compare
    if (value != value || value === Infinity) {
        // eslint-disable-next-line no-self-compare
        m = value != value ? 1 : 0;
        e = eMax;
    } else {
        e = floor(log(value) / LN2);
        if (value * (c = pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * pow(2, eBias - 1) * pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
    buffer[--i] |= s * 128;
    return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = eLen - 7;
    var i = nBytes - 1;
    var s = buffer[i--];
    var e = s & 127;
    var m;
    s >>= 7;
    for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : s ? -Infinity : Infinity;
    else {
        m = m + pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * pow(2, e - mLen);
}
function unpackI32(bytes) {
    return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
    return [
        it & 255
    ];
}
function packI16(it) {
    return [
        it & 255,
        it >> 8 & 255
    ];
}
function packI32(it) {
    return [
        it & 255,
        it >> 8 & 255,
        it >> 16 & 255,
        it >> 24 & 255
    ];
}
function packF64(it) {
    return packIEEE754(it, 52, 8);
}
function packF32(it) {
    return packIEEE754(it, 23, 4);
}
function addGetter(C, key1, internal) {
    dP(C[PROTOTYPE], key1, {
        get: function() {
            return this[internal];
        }
    });
}
function get(view1, bytes, index, isLittleEndian) {
    var numIndex = +index;
    var intIndex = toIndex(numIndex);
    if (intIndex + bytes > view1[$LENGTH]) throw RangeError(WRONG_INDEX);
    var store = view1[$BUFFER]._b;
    var start = intIndex + view1[$OFFSET];
    var pack = store.slice(start, start + bytes);
    return isLittleEndian ? pack : pack.reverse();
}
function set(view2, bytes, index, conversion, value, isLittleEndian) {
    var numIndex = +index;
    var intIndex = toIndex(numIndex);
    if (intIndex + bytes > view2[$LENGTH]) throw RangeError(WRONG_INDEX);
    var store = view2[$BUFFER]._b;
    var start = intIndex + view2[$OFFSET];
    var pack = conversion(+value);
    for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}
if (!$typed.ABV) {
    $ArrayBuffer = function ArrayBuffer(length) {
        anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
        var byteLength = toIndex(length);
        this._b = arrayFill.call(new Array(byteLength), 0);
        this[$LENGTH] = byteLength;
    };
    $DataView = function DataView(buffer, byteOffset, byteLength) {
        anInstance(this, $DataView, DATA_VIEW);
        anInstance(buffer, $ArrayBuffer, DATA_VIEW);
        var bufferLength = buffer[$LENGTH];
        var offset = toInteger(byteOffset);
        if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
        byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
        if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
        this[$BUFFER] = buffer;
        this[$OFFSET] = offset;
        this[$LENGTH] = byteLength;
    };
    if (DESCRIPTORS) {
        addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
        addGetter($DataView, BUFFER, '_b');
        addGetter($DataView, BYTE_LENGTH, '_l');
        addGetter($DataView, BYTE_OFFSET, '_o');
    }
    redefineAll($DataView[PROTOTYPE], {
        getInt8: function getInt8(byteOffset) {
            return get(this, 1, byteOffset)[0] << 24 >> 24;
        },
        getUint8: function getUint8(byteOffset) {
            return get(this, 1, byteOffset)[0];
        },
        getInt16: function getInt16(byteOffset /* , littleEndian */ ) {
            var bytes = get(this, 2, byteOffset, arguments[1]);
            return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
        },
        getUint16: function getUint16(byteOffset /* , littleEndian */ ) {
            var bytes = get(this, 2, byteOffset, arguments[1]);
            return bytes[1] << 8 | bytes[0];
        },
        getInt32: function getInt32(byteOffset /* , littleEndian */ ) {
            return unpackI32(get(this, 4, byteOffset, arguments[1]));
        },
        getUint32: function getUint32(byteOffset /* , littleEndian */ ) {
            return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
        },
        getFloat32: function getFloat32(byteOffset /* , littleEndian */ ) {
            return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
        },
        getFloat64: function getFloat64(byteOffset /* , littleEndian */ ) {
            return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
        },
        setInt8: function setInt8(byteOffset, value) {
            set(this, 1, byteOffset, packI8, value);
        },
        setUint8: function setUint8(byteOffset, value) {
            set(this, 1, byteOffset, packI8, value);
        },
        setInt16: function setInt16(byteOffset, value /* , littleEndian */ ) {
            set(this, 2, byteOffset, packI16, value, arguments[2]);
        },
        setUint16: function setUint16(byteOffset, value /* , littleEndian */ ) {
            set(this, 2, byteOffset, packI16, value, arguments[2]);
        },
        setInt32: function setInt32(byteOffset, value /* , littleEndian */ ) {
            set(this, 4, byteOffset, packI32, value, arguments[2]);
        },
        setUint32: function setUint32(byteOffset, value /* , littleEndian */ ) {
            set(this, 4, byteOffset, packI32, value, arguments[2]);
        },
        setFloat32: function setFloat32(byteOffset, value /* , littleEndian */ ) {
            set(this, 4, byteOffset, packF32, value, arguments[2]);
        },
        setFloat64: function setFloat64(byteOffset, value /* , littleEndian */ ) {
            set(this, 8, byteOffset, packF64, value, arguments[2]);
        }
    });
} else {
    if (!fails(function() {
        $ArrayBuffer(1);
    }) || !fails(function() {
        new $ArrayBuffer(-1); // eslint-disable-line no-new
    }) || fails(function() {
        new $ArrayBuffer(); // eslint-disable-line no-new
        new $ArrayBuffer(1.5); // eslint-disable-line no-new
        new $ArrayBuffer(NaN); // eslint-disable-line no-new
        return $ArrayBuffer.name != ARRAY_BUFFER;
    })) {
        $ArrayBuffer = function ArrayBuffer(length) {
            anInstance(this, $ArrayBuffer);
            return new BaseBuffer(toIndex(length));
        };
        var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
        for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;)if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
        if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
    }
    // iOS Safari 7.x bug
    var view = new $DataView(new $ArrayBuffer(2));
    var $setInt8 = $DataView[PROTOTYPE].setInt8;
    view.setInt8(0, 2147483648);
    view.setInt8(1, 2147483649);
    if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
        setInt8: function setInt8(byteOffset, value) {
            $setInt8.call(this, byteOffset, value << 24 >> 24);
        },
        setUint8: function setUint8(byteOffset, value) {
            $setInt8.call(this, byteOffset, value << 24 >> 24);
        }
    }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_global":"8xCse","./_descriptors":"dr2tY","./_library":"lmtqY","./_typed":"euXsj","./_hide":"ddpVq","./_redefine-all":"6Mnp5","./_fails":"iAFH1","./_an-instance":"ivm35","./_to-integer":"cb0GT","./_to-length":"irYfS","./_to-index":"3tbBZ","./_object-gopn":"jK0Om","./_object-dp":"cLcWd","./_array-fill":"dXwYX","./_set-to-string-tag":"7YXlq"}],"3tbBZ":[function(require,module,exports) {
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function(it) {
    if (it === undefined) return 0;
    var number = toInteger(it);
    var length = toLength(number);
    if (number !== length) throw RangeError('Wrong length!');
    return length;
};

},{"./_to-integer":"cb0GT","./_to-length":"irYfS"}],"FLhcC":[function(require,module,exports) {
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
    DataView: require('./_typed-buffer').DataView
});

},{"./_export":"1Tgvm","./_typed":"euXsj","./_typed-buffer":"bO20V"}],"2PtAR":[function(require,module,exports) {
require('./_typed-array')('Int8', 1, function(init) {
    return function Int8Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"./_typed-array":"heDu8"}],"heDu8":[function(require,module,exports) {
'use strict';
if (require('./_descriptors')) {
    var LIBRARY = require('./_library');
    var global = require('./_global');
    var fails = require('./_fails');
    var $export = require('./_export');
    var $typed = require('./_typed');
    var $buffer = require('./_typed-buffer');
    var ctx = require('./_ctx');
    var anInstance = require('./_an-instance');
    var propertyDesc = require('./_property-desc');
    var hide = require('./_hide');
    var redefineAll = require('./_redefine-all');
    var toInteger = require('./_to-integer');
    var toLength = require('./_to-length');
    var toIndex = require('./_to-index');
    var toAbsoluteIndex = require('./_to-absolute-index');
    var toPrimitive = require('./_to-primitive');
    var has = require('./_has');
    var classof = require('./_classof');
    var isObject = require('./_is-object');
    var toObject = require('./_to-object');
    var isArrayIter = require('./_is-array-iter');
    var create = require('./_object-create');
    var getPrototypeOf = require('./_object-gpo');
    var gOPN = require('./_object-gopn').f;
    var getIterFn = require('./core.get-iterator-method');
    var uid = require('./_uid');
    var wks = require('./_wks');
    var createArrayMethod = require('./_array-methods');
    var createArrayIncludes = require('./_array-includes');
    var speciesConstructor = require('./_species-constructor');
    var ArrayIterators = require('./es6.array.iterator');
    var Iterators = require('./_iterators');
    var $iterDetect = require('./_iter-detect');
    var setSpecies = require('./_set-species');
    var arrayFill = require('./_array-fill');
    var arrayCopyWithin = require('./_array-copy-within');
    var $DP = require('./_object-dp');
    var $GOPD = require('./_object-gopd');
    var dP = $DP.f;
    var gOPD = $GOPD.f;
    var RangeError = global.RangeError;
    var TypeError = global.TypeError;
    var Uint8Array = global.Uint8Array;
    var ARRAY_BUFFER = 'ArrayBuffer';
    var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
    var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
    var PROTOTYPE = 'prototype';
    var ArrayProto = Array[PROTOTYPE];
    var $ArrayBuffer = $buffer.ArrayBuffer;
    var $DataView = $buffer.DataView;
    var arrayForEach = createArrayMethod(0);
    var arrayFilter = createArrayMethod(2);
    var arraySome = createArrayMethod(3);
    var arrayEvery = createArrayMethod(4);
    var arrayFind = createArrayMethod(5);
    var arrayFindIndex = createArrayMethod(6);
    var arrayIncludes = createArrayIncludes(true);
    var arrayIndexOf = createArrayIncludes(false);
    var arrayValues = ArrayIterators.values;
    var arrayKeys = ArrayIterators.keys;
    var arrayEntries = ArrayIterators.entries;
    var arrayLastIndexOf = ArrayProto.lastIndexOf;
    var arrayReduce = ArrayProto.reduce;
    var arrayReduceRight = ArrayProto.reduceRight;
    var arrayJoin = ArrayProto.join;
    var arraySort = ArrayProto.sort;
    var arraySlice = ArrayProto.slice;
    var arrayToString = ArrayProto.toString;
    var arrayToLocaleString = ArrayProto.toLocaleString;
    var ITERATOR = wks('iterator');
    var TAG = wks('toStringTag');
    var TYPED_CONSTRUCTOR = uid('typed_constructor');
    var DEF_CONSTRUCTOR = uid('def_constructor');
    var ALL_CONSTRUCTORS = $typed.CONSTR;
    var TYPED_ARRAY = $typed.TYPED;
    var VIEW = $typed.VIEW;
    var WRONG_LENGTH = 'Wrong length!';
    var $map = createArrayMethod(1, function(O, length) {
        return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
    });
    var LITTLE_ENDIAN = fails(function() {
        // eslint-disable-next-line no-undef
        return new Uint8Array(new Uint16Array([
            1
        ]).buffer)[0] === 1;
    });
    var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function() {
        new Uint8Array(1).set({});
    });
    var toOffset = function(it, BYTES) {
        var offset = toInteger(it);
        if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
        return offset;
    };
    var validate = function(it) {
        if (isObject(it) && TYPED_ARRAY in it) return it;
        throw TypeError(it + ' is not a typed array!');
    };
    var allocate = function(C, length) {
        if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) throw TypeError('It is not a typed array constructor!');
        return new C(length);
    };
    var speciesFromList = function(O, list) {
        return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
    };
    var fromList = function(C, list) {
        var index = 0;
        var length = list.length;
        var result = allocate(C, length);
        while(length > index)result[index] = list[index++];
        return result;
    };
    var addGetter = function(it, key, internal) {
        dP(it, key, {
            get: function() {
                return this._d[internal];
            }
        });
    };
    var $from = function from(source /* , mapfn, thisArg */ ) {
        var O = toObject(source);
        var aLen = arguments.length;
        var mapfn = aLen > 1 ? arguments[1] : undefined;
        var mapping = mapfn !== undefined;
        var iterFn = getIterFn(O);
        var i, length, values, result, step, iterator;
        if (iterFn != undefined && !isArrayIter(iterFn)) {
            for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++)values.push(step.value);
            O = values;
        }
        if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
        for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++)result[i] = mapping ? mapfn(O[i], i) : O[i];
        return result;
    };
    var $of = function of() {
        var index = 0;
        var length = arguments.length;
        var result = allocate(this, length);
        while(length > index)result[index] = arguments[index++];
        return result;
    };
    // iOS Safari 6.x fails here
    var TO_LOCALE_BUG = !!Uint8Array && fails(function() {
        arrayToLocaleString.call(new Uint8Array(1));
    });
    var $toLocaleString = function toLocaleString() {
        return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
    };
    var proto = {
        copyWithin: function copyWithin(target, start /* , end */ ) {
            return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
        },
        every: function every(callbackfn /* , thisArg */ ) {
            return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        },
        fill: function fill(value /* , start, end */ ) {
            return arrayFill.apply(validate(this), arguments);
        },
        filter: function filter(callbackfn /* , thisArg */ ) {
            return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
        },
        find: function find(predicate /* , thisArg */ ) {
            return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
        },
        findIndex: function findIndex(predicate /* , thisArg */ ) {
            return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
        },
        forEach: function forEach(callbackfn /* , thisArg */ ) {
            arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        },
        indexOf: function indexOf(searchElement /* , fromIndex */ ) {
            return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
        },
        includes: function includes(searchElement /* , fromIndex */ ) {
            return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
        },
        join: function join(separator) {
            return arrayJoin.apply(validate(this), arguments);
        },
        lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */ ) {
            return arrayLastIndexOf.apply(validate(this), arguments);
        },
        map: function map(mapfn /* , thisArg */ ) {
            return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
        },
        reduce: function reduce(callbackfn /* , initialValue */ ) {
            return arrayReduce.apply(validate(this), arguments);
        },
        reduceRight: function reduceRight(callbackfn /* , initialValue */ ) {
            return arrayReduceRight.apply(validate(this), arguments);
        },
        reverse: function reverse() {
            var that = this;
            var length = validate(that).length;
            var middle = Math.floor(length / 2);
            var index = 0;
            var value;
            while(index < middle){
                value = that[index];
                that[index++] = that[--length];
                that[length] = value;
            }
            return that;
        },
        some: function some(callbackfn /* , thisArg */ ) {
            return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        },
        sort: function sort(comparefn) {
            return arraySort.call(validate(this), comparefn);
        },
        subarray: function subarray(begin, end) {
            var O = validate(this);
            var length = O.length;
            var $begin = toAbsoluteIndex(begin, length);
            return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
        }
    };
    var $slice = function slice(start, end) {
        return speciesFromList(this, arraySlice.call(validate(this), start, end));
    };
    var $set = function set(arrayLike /* , offset */ ) {
        validate(this);
        var offset = toOffset(arguments[1], 1);
        var length = this.length;
        var src = toObject(arrayLike);
        var len = toLength(src.length);
        var index = 0;
        if (len + offset > length) throw RangeError(WRONG_LENGTH);
        while(index < len)this[offset + index] = src[index++];
    };
    var $iterators = {
        entries: function entries() {
            return arrayEntries.call(validate(this));
        },
        keys: function keys() {
            return arrayKeys.call(validate(this));
        },
        values: function values() {
            return arrayValues.call(validate(this));
        }
    };
    var isTAIndex = function(target, key) {
        return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key);
    };
    var $getDesc = function getOwnPropertyDescriptor(target, key) {
        return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
    };
    var $setDesc = function defineProperty(target, key, desc) {
        if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
            target[key] = desc.value;
            return target;
        }
        return dP(target, key, desc);
    };
    if (!ALL_CONSTRUCTORS) {
        $GOPD.f = $getDesc;
        $DP.f = $setDesc;
    }
    $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
        getOwnPropertyDescriptor: $getDesc,
        defineProperty: $setDesc
    });
    if (fails(function() {
        arrayToString.call({});
    })) arrayToString = arrayToLocaleString = function toString() {
        return arrayJoin.call(this);
    };
    var $TypedArrayPrototype$ = redefineAll({}, proto);
    redefineAll($TypedArrayPrototype$, $iterators);
    hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
    redefineAll($TypedArrayPrototype$, {
        slice: $slice,
        set: $set,
        constructor: function() {},
        toString: arrayToString,
        toLocaleString: $toLocaleString
    });
    addGetter($TypedArrayPrototype$, 'buffer', 'b');
    addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
    addGetter($TypedArrayPrototype$, 'byteLength', 'l');
    addGetter($TypedArrayPrototype$, 'length', 'e');
    dP($TypedArrayPrototype$, TAG, {
        get: function() {
            return this[TYPED_ARRAY];
        }
    });
    // eslint-disable-next-line max-statements
    module.exports = function(KEY, BYTES, wrapper, CLAMPED) {
        CLAMPED = !!CLAMPED;
        var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
        var GETTER = 'get' + KEY;
        var SETTER = 'set' + KEY;
        var TypedArray = global[NAME];
        var Base = TypedArray || {};
        var TAC = TypedArray && getPrototypeOf(TypedArray);
        var FORCED = !TypedArray || !$typed.ABV;
        var O = {};
        var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
        var getter = function(that, index) {
            var data = that._d;
            return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
        };
        var setter = function(that, index, value) {
            var data = that._d;
            if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 255 ? 255 : value & 255;
            data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
        };
        var addElement = function(that, index) {
            dP(that, index, {
                get: function() {
                    return getter(this, index);
                },
                set: function(value) {
                    return setter(this, index, value);
                },
                enumerable: true
            });
        };
        if (FORCED) {
            TypedArray = wrapper(function(that, data, $offset, $length) {
                anInstance(that, TypedArray, NAME, '_d');
                var index = 0;
                var offset = 0;
                var buffer, byteLength, length, klass;
                if (!isObject(data)) {
                    length = toIndex(data);
                    byteLength = length * BYTES;
                    buffer = new $ArrayBuffer(byteLength);
                } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
                    buffer = data;
                    offset = toOffset($offset, BYTES);
                    var $len = data.byteLength;
                    if ($length === undefined) {
                        if ($len % BYTES) throw RangeError(WRONG_LENGTH);
                        byteLength = $len - offset;
                        if (byteLength < 0) throw RangeError(WRONG_LENGTH);
                    } else {
                        byteLength = toLength($length) * BYTES;
                        if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
                    }
                    length = byteLength / BYTES;
                } else if (TYPED_ARRAY in data) return fromList(TypedArray, data);
                else return $from.call(TypedArray, data);
                hide(that, '_d', {
                    b: buffer,
                    o: offset,
                    l: byteLength,
                    e: length,
                    v: new $DataView(buffer)
                });
                while(index < length)addElement(that, index++);
            });
            TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
            hide(TypedArrayPrototype, 'constructor', TypedArray);
        } else if (!fails(function() {
            TypedArray(1);
        }) || !fails(function() {
            new TypedArray(-1); // eslint-disable-line no-new
        }) || !$iterDetect(function(iter) {
            new TypedArray(); // eslint-disable-line no-new
            new TypedArray(null); // eslint-disable-line no-new
            new TypedArray(1.5); // eslint-disable-line no-new
            new TypedArray(iter); // eslint-disable-line no-new
        }, true)) {
            TypedArray = wrapper(function(that, data, $offset, $length) {
                anInstance(that, TypedArray, NAME);
                var klass;
                // `ws` module bug, temporarily remove validation length for Uint8Array
                // https://github.com/websockets/ws/pull/645
                if (!isObject(data)) return new Base(toIndex(data));
                if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
                if (TYPED_ARRAY in data) return fromList(TypedArray, data);
                return $from.call(TypedArray, data);
            });
            arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key) {
                if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
            });
            TypedArray[PROTOTYPE] = TypedArrayPrototype;
            if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
        }
        var $nativeIterator = TypedArrayPrototype[ITERATOR];
        var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
        var $iterator = $iterators.values;
        hide(TypedArray, TYPED_CONSTRUCTOR, true);
        hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
        hide(TypedArrayPrototype, VIEW, true);
        hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
        if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) dP(TypedArrayPrototype, TAG, {
            get: function() {
                return NAME;
            }
        });
        O[NAME] = TypedArray;
        $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
        $export($export.S, NAME, {
            BYTES_PER_ELEMENT: BYTES
        });
        $export($export.S + $export.F * fails(function() {
            Base.of.call(TypedArray, 1);
        }), NAME, {
            from: $from,
            of: $of
        });
        if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
        $export($export.P, NAME, proto);
        setSpecies(NAME);
        $export($export.P + $export.F * FORCED_SET, NAME, {
            set: $set
        });
        $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
        if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
        $export($export.P + $export.F * fails(function() {
            new TypedArray(1).slice();
        }), NAME, {
            slice: $slice
        });
        $export($export.P + $export.F * (fails(function() {
            return [
                1,
                2
            ].toLocaleString() != new TypedArray([
                1,
                2
            ]).toLocaleString();
        }) || !fails(function() {
            TypedArrayPrototype.toLocaleString.call([
                1,
                2
            ]);
        })), NAME, {
            toLocaleString: $toLocaleString
        });
        Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
        if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
    };
} else module.exports = function() {};

},{"./_descriptors":"dr2tY","./_library":"lmtqY","./_global":"8xCse","./_fails":"iAFH1","./_export":"1Tgvm","./_typed":"euXsj","./_typed-buffer":"bO20V","./_ctx":"4rQSm","./_an-instance":"ivm35","./_property-desc":"825qY","./_hide":"ddpVq","./_redefine-all":"6Mnp5","./_to-integer":"cb0GT","./_to-length":"irYfS","./_to-index":"3tbBZ","./_to-absolute-index":"1lPjf","./_to-primitive":"4Oubb","./_has":"biQ7v","./_classof":"5TIen","./_is-object":"eIE5K","./_to-object":"7HHXi","./_is-array-iter":"ipP6u","./_object-create":"b4m8n","./_object-gpo":"4uFAD","./_object-gopn":"jK0Om","./core.get-iterator-method":"hb865","./_uid":"gBq6n","./_wks":"eaoKZ","./_array-methods":"9C3tD","./_array-includes":"1Ebaw","./_species-constructor":"8Vo8d","./es6.array.iterator":"1xhrt","./_iterators":"dITQr","./_iter-detect":"3KQwU","./_set-species":"1qQNM","./_array-fill":"dXwYX","./_array-copy-within":"55wbB","./_object-dp":"cLcWd","./_object-gopd":"4bAUG"}],"g4j5m":[function(require,module,exports) {
require('./_typed-array')('Uint8', 1, function(init) {
    return function Uint8Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"./_typed-array":"heDu8"}],"68vHx":[function(require,module,exports) {
require('./_typed-array')('Uint8', 1, function(init) {
    return function Uint8ClampedArray(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
}, true);

},{"./_typed-array":"heDu8"}],"iZyZL":[function(require,module,exports) {
require('./_typed-array')('Int16', 2, function(init) {
    return function Int16Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"./_typed-array":"heDu8"}],"4Jyn3":[function(require,module,exports) {
require('./_typed-array')('Uint16', 2, function(init) {
    return function Uint16Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"./_typed-array":"heDu8"}],"dSRiX":[function(require,module,exports) {
require('./_typed-array')('Int32', 4, function(init) {
    return function Int32Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"./_typed-array":"heDu8"}],"lKCGR":[function(require,module,exports) {
require('./_typed-array')('Uint32', 4, function(init) {
    return function Uint32Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"./_typed-array":"heDu8"}],"fASXR":[function(require,module,exports) {
require('./_typed-array')('Float32', 4, function(init) {
    return function Float32Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"./_typed-array":"heDu8"}],"e3YAQ":[function(require,module,exports) {
require('./_typed-array')('Float64', 8, function(init) {
    return function Float64Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

},{"./_typed-array":"heDu8"}],"kstrm":[function(require,module,exports) {
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function() {
    rApply(function() {});
}), 'Reflect', {
    apply: function apply(target, thisArgument, argumentsList) {
        var T = aFunction(target);
        var L = anObject(argumentsList);
        return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
    }
});

},{"./_export":"1Tgvm","./_a-function":"55L9l","./_an-object":"kiL2X","./_global":"8xCse","./_fails":"iAFH1"}],"fXcT1":[function(require,module,exports) {
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function() {
    function F() {}
    return !(rConstruct(function() {}, [], F) instanceof F);
});
var ARGS_BUG = !fails(function() {
    rConstruct(function() {});
});
$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
    construct: function construct(Target, args /* , newTarget */ ) {
        aFunction(Target);
        anObject(args);
        var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
        if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
        if (Target == newTarget) {
            // w/o altered newTarget, optimization for 0-4 arguments
            switch(args.length){
                case 0:
                    return new Target();
                case 1:
                    return new Target(args[0]);
                case 2:
                    return new Target(args[0], args[1]);
                case 3:
                    return new Target(args[0], args[1], args[2]);
                case 4:
                    return new Target(args[0], args[1], args[2], args[3]);
            }
            // w/o altered newTarget, lot of arguments case
            var $args = [
                null
            ];
            $args.push.apply($args, args);
            return new (bind.apply(Target, $args))();
        }
        // with altered newTarget, not support built-in constructors
        var proto = newTarget.prototype;
        var instance = create(isObject(proto) ? proto : Object.prototype);
        var result = Function.apply.call(Target, instance, args);
        return isObject(result) ? result : instance;
    }
});

},{"./_export":"1Tgvm","./_object-create":"b4m8n","./_a-function":"55L9l","./_an-object":"kiL2X","./_is-object":"eIE5K","./_fails":"iAFH1","./_bind":"2xSTE","./_global":"8xCse"}],"kibOK":[function(require,module,exports) {
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function() {
    // eslint-disable-next-line no-undef
    Reflect.defineProperty(dP.f({}, 1, {
        value: 1
    }), 1, {
        value: 2
    });
}), 'Reflect', {
    defineProperty: function defineProperty(target, propertyKey, attributes) {
        anObject(target);
        propertyKey = toPrimitive(propertyKey, true);
        anObject(attributes);
        try {
            dP.f(target, propertyKey, attributes);
            return true;
        } catch (e) {
            return false;
        }
    }
});

},{"./_object-dp":"cLcWd","./_export":"1Tgvm","./_an-object":"kiL2X","./_to-primitive":"4Oubb","./_fails":"iAFH1"}],"2NlGq":[function(require,module,exports) {
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');
$export($export.S, 'Reflect', {
    deleteProperty: function deleteProperty(target, propertyKey) {
        var desc = gOPD(anObject(target), propertyKey);
        return desc && !desc.configurable ? false : delete target[propertyKey];
    }
});

},{"./_export":"1Tgvm","./_object-gopd":"4bAUG","./_an-object":"kiL2X"}],"iKC7x":[function(require,module,exports) {
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var Enumerate = function(iterated) {
    this._t = anObject(iterated); // target
    this._i = 0; // next index
    var keys = this._k = []; // keys
    var key;
    for(key in iterated)keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function() {
    var that = this;
    var keys = that._k;
    var key;
    do {
        if (that._i >= keys.length) return {
            value: undefined,
            done: true
        };
    }while (!((key = keys[that._i++]) in that._t))
    return {
        value: key,
        done: false
    };
});
$export($export.S, 'Reflect', {
    enumerate: function enumerate(target) {
        return new Enumerate(target);
    }
});

},{"./_export":"1Tgvm","./_an-object":"kiL2X","./_iter-create":"eTcx3"}],"dIqbe":[function(require,module,exports) {
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');
function get(target, propertyKey /* , receiver */ ) {
    var receiver = arguments.length < 3 ? target : arguments[2];
    var desc, proto;
    if (anObject(target) === receiver) return target[propertyKey];
    if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
    if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}
$export($export.S, 'Reflect', {
    get: get
});

},{"./_object-gopd":"4bAUG","./_object-gpo":"4uFAD","./_has":"biQ7v","./_export":"1Tgvm","./_is-object":"eIE5K","./_an-object":"kiL2X"}],"lSfAN":[function(require,module,exports) {
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');
$export($export.S, 'Reflect', {
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
        return gOPD.f(anObject(target), propertyKey);
    }
});

},{"./_object-gopd":"4bAUG","./_export":"1Tgvm","./_an-object":"kiL2X"}],"aO9N4":[function(require,module,exports) {
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');
$export($export.S, 'Reflect', {
    getPrototypeOf: function getPrototypeOf(target) {
        return getProto(anObject(target));
    }
});

},{"./_export":"1Tgvm","./_object-gpo":"4uFAD","./_an-object":"kiL2X"}],"4HzcT":[function(require,module,exports) {
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');
$export($export.S, 'Reflect', {
    has: function has(target, propertyKey) {
        return propertyKey in target;
    }
});

},{"./_export":"1Tgvm"}],"dmYlo":[function(require,module,exports) {
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;
$export($export.S, 'Reflect', {
    isExtensible: function isExtensible(target) {
        anObject(target);
        return $isExtensible ? $isExtensible(target) : true;
    }
});

},{"./_export":"1Tgvm","./_an-object":"kiL2X"}],"15duj":[function(require,module,exports) {
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');
$export($export.S, 'Reflect', {
    ownKeys: require('./_own-keys')
});

},{"./_export":"1Tgvm","./_own-keys":"h4xsg"}],"h4xsg":[function(require,module,exports) {
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
    var keys = gOPN.f(anObject(it));
    var getSymbols = gOPS.f;
    return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_object-gopn":"jK0Om","./_object-gops":"5oH2C","./_an-object":"kiL2X","./_global":"8xCse"}],"cC4pR":[function(require,module,exports) {
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;
$export($export.S, 'Reflect', {
    preventExtensions: function preventExtensions(target) {
        anObject(target);
        try {
            if ($preventExtensions) $preventExtensions(target);
            return true;
        } catch (e) {
            return false;
        }
    }
});

},{"./_export":"1Tgvm","./_an-object":"kiL2X"}],"dl5fS":[function(require,module,exports) {
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
function set(target, propertyKey, V /* , receiver */ ) {
    var receiver = arguments.length < 4 ? target : arguments[3];
    var ownDesc = gOPD.f(anObject(target), propertyKey);
    var existingDescriptor, proto;
    if (!ownDesc) {
        if (isObject(proto = getPrototypeOf(target))) return set(proto, propertyKey, V, receiver);
        ownDesc = createDesc(0);
    }
    if (has(ownDesc, 'value')) {
        if (ownDesc.writable === false || !isObject(receiver)) return false;
        if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
            if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
            existingDescriptor.value = V;
            dP.f(receiver, propertyKey, existingDescriptor);
        } else dP.f(receiver, propertyKey, createDesc(0, V));
        return true;
    }
    return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}
$export($export.S, 'Reflect', {
    set: set
});

},{"./_object-dp":"cLcWd","./_object-gopd":"4bAUG","./_object-gpo":"4uFAD","./_has":"biQ7v","./_export":"1Tgvm","./_property-desc":"825qY","./_an-object":"kiL2X","./_is-object":"eIE5K"}],"jH9nI":[function(require,module,exports) {
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');
if (setProto) $export($export.S, 'Reflect', {
    setPrototypeOf: function setPrototypeOf(target, proto) {
        setProto.check(target, proto);
        try {
            setProto.set(target, proto);
            return true;
        } catch (e) {
            return false;
        }
    }
});

},{"./_export":"1Tgvm","./_set-proto":"ltEMf"}],"9KPxe":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);
$export($export.P, 'Array', {
    includes: function includes(el /* , fromIndex = 0 */ ) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }
});
require('./_add-to-unscopables')('includes');

},{"./_export":"1Tgvm","./_array-includes":"1Ebaw","./_add-to-unscopables":"ltQTG"}],"lKIEm":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');
$export($export.P, 'Array', {
    flatMap: function flatMap(callbackfn /* , thisArg */ ) {
        var O = toObject(this);
        var sourceLen, A;
        aFunction(callbackfn);
        sourceLen = toLength(O.length);
        A = arraySpeciesCreate(O, 0);
        flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
        return A;
    }
});
require('./_add-to-unscopables')('flatMap');

},{"./_export":"1Tgvm","./_flatten-into-array":"1UpmY","./_to-object":"7HHXi","./_to-length":"irYfS","./_a-function":"55L9l","./_array-species-create":"93xs6","./_add-to-unscopables":"ltQTG"}],"1UpmY":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');
function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
    var targetIndex = start;
    var sourceIndex = 0;
    var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
    var element, spreadable;
    while(sourceIndex < sourceLen){
        if (sourceIndex in source) {
            element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
            spreadable = false;
            if (isObject(element)) {
                spreadable = element[IS_CONCAT_SPREADABLE];
                spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
            }
            if (spreadable && depth > 0) targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
            else {
                if (targetIndex >= 9007199254740991) throw TypeError();
                target[targetIndex] = element;
            }
            targetIndex++;
        }
        sourceIndex++;
    }
    return targetIndex;
}
module.exports = flattenIntoArray;

},{"./_is-array":"dTLRt","./_is-object":"eIE5K","./_to-length":"irYfS","./_ctx":"4rQSm","./_wks":"eaoKZ"}],"lpb4z":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var arraySpeciesCreate = require('./_array-species-create');
$export($export.P, 'Array', {
    flatten: function flatten() {
        var depthArg = arguments[0];
        var O = toObject(this);
        var sourceLen = toLength(O.length);
        var A = arraySpeciesCreate(O, 0);
        flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
        return A;
    }
});
require('./_add-to-unscopables')('flatten');

},{"./_export":"1Tgvm","./_flatten-into-array":"1UpmY","./_to-object":"7HHXi","./_to-length":"irYfS","./_to-integer":"cb0GT","./_array-species-create":"93xs6","./_add-to-unscopables":"ltQTG"}],"eVq5h":[function(require,module,exports) {
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export');
var $at = require('./_string-at')(true);
$export($export.P, 'String', {
    at: function at(pos) {
        return $at(this, pos);
    }
});

},{"./_export":"1Tgvm","./_string-at":"rbgP0"}],"kxeDX":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');
// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
$export($export.P + $export.F * WEBKIT_BUG, 'String', {
    padStart: function padStart(maxLength /* , fillString = ' ' */ ) {
        return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
    }
});

},{"./_export":"1Tgvm","./_string-pad":"7gHpZ","./_user-agent":"9eCfU"}],"7gHpZ":[function(require,module,exports) {
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');
module.exports = function(that, maxLength, fillString, left) {
    var S = String(defined(that));
    var stringLength = S.length;
    var fillStr = fillString === undefined ? ' ' : String(fillString);
    var intMaxLength = toLength(maxLength);
    if (intMaxLength <= stringLength || fillStr == '') return S;
    var fillLen = intMaxLength - stringLength;
    var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
    return left ? stringFiller + S : S + stringFiller;
};

},{"./_to-length":"irYfS","./_string-repeat":"2JEgf","./_defined":"4Lj5U"}],"6j6XE":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');
// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
$export($export.P + $export.F * WEBKIT_BUG, 'String', {
    padEnd: function padEnd(maxLength /* , fillString = ' ' */ ) {
        return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
    }
});

},{"./_export":"1Tgvm","./_string-pad":"7gHpZ","./_user-agent":"9eCfU"}],"4dYUb":[function(require,module,exports) {
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function($trim) {
    return function trimLeft() {
        return $trim(this, 1);
    };
}, 'trimStart');

},{"./_string-trim":"9YCA9"}],"5yndh":[function(require,module,exports) {
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function($trim) {
    return function trimRight() {
        return $trim(this, 2);
    };
}, 'trimEnd');

},{"./_string-trim":"9YCA9"}],"cZhYH":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export = require('./_export');
var defined = require('./_defined');
var toLength = require('./_to-length');
var isRegExp = require('./_is-regexp');
var getFlags = require('./_flags');
var RegExpProto = RegExp.prototype;
var $RegExpStringIterator = function(regexp, string) {
    this._r = regexp;
    this._s = string;
};
require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next() {
    var match = this._r.exec(this._s);
    return {
        value: match,
        done: match === null
    };
});
$export($export.P, 'String', {
    matchAll: function matchAll(regexp) {
        defined(this);
        if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
        var S = String(this);
        var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
        var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
        rx.lastIndex = toLength(regexp.lastIndex);
        return new $RegExpStringIterator(rx, S);
    }
});

},{"./_export":"1Tgvm","./_defined":"4Lj5U","./_to-length":"irYfS","./_is-regexp":"aGcfF","./_flags":"KuZtV","./_iter-create":"eTcx3"}],"8vHXs":[function(require,module,exports) {
require('./_wks-define')('asyncIterator');

},{"./_wks-define":"28rGc"}],"jDpxk":[function(require,module,exports) {
require('./_wks-define')('observable');

},{"./_wks-define":"28rGc"}],"k5woh":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');
$export($export.S, 'Object', {
    getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
        var O = toIObject(object);
        var getDesc = gOPD.f;
        var keys = ownKeys(O);
        var result = {};
        var i = 0;
        var key, desc;
        while(keys.length > i){
            desc = getDesc(O, key = keys[i++]);
            if (desc !== undefined) createProperty(result, key, desc);
        }
        return result;
    }
});

},{"./_export":"1Tgvm","./_own-keys":"h4xsg","./_to-iobject":"f9RCz","./_object-gopd":"4bAUG","./_create-property":"8UZLF"}],"kQJLQ":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);
$export($export.S, 'Object', {
    values: function values(it) {
        return $values(it);
    }
});

},{"./_export":"1Tgvm","./_object-to-array":"1U0IC"}],"1U0IC":[function(require,module,exports) {
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function(isEntries) {
    return function(it) {
        var O = toIObject(it);
        var keys = getKeys(O);
        var length = keys.length;
        var i = 0;
        var result = [];
        var key;
        while(length > i){
            key = keys[i++];
            if (!DESCRIPTORS || isEnum.call(O, key)) result.push(isEntries ? [
                key,
                O[key]
            ] : O[key]);
        }
        return result;
    };
};

},{"./_descriptors":"dr2tY","./_object-keys":"98CC0","./_to-iobject":"f9RCz","./_object-pie":"2aUxV"}],"7zW9M":[function(require,module,exports) {
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);
$export($export.S, 'Object', {
    entries: function entries(it) {
        return $entries(it);
    }
});

},{"./_export":"1Tgvm","./_object-to-array":"1U0IC"}],"92ysW":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');
// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
    __defineGetter__: function __defineGetter__(P, getter) {
        $defineProperty.f(toObject(this), P, {
            get: aFunction(getter),
            enumerable: true,
            configurable: true
        });
    }
});

},{"./_export":"1Tgvm","./_to-object":"7HHXi","./_a-function":"55L9l","./_object-dp":"cLcWd","./_descriptors":"dr2tY","./_object-forced-pam":"9kndE"}],"9kndE":[function(require,module,exports) {
'use strict';
// Forced replacement prototype accessors methods
module.exports = require('./_library') || !require('./_fails')(function() {
    var K = Math.random();
    // In FF throws only define methods
    // eslint-disable-next-line no-undef, no-useless-call
    __defineSetter__.call(null, K, function() {});
    delete require('./_global')[K];
});

},{"./_library":"lmtqY","./_fails":"iAFH1","./_global":"8xCse"}],"emt8A":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');
// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
    __defineSetter__: function __defineSetter__(P, setter) {
        $defineProperty.f(toObject(this), P, {
            set: aFunction(setter),
            enumerable: true,
            configurable: true
        });
    }
});

},{"./_export":"1Tgvm","./_to-object":"7HHXi","./_a-function":"55L9l","./_object-dp":"cLcWd","./_descriptors":"dr2tY","./_object-forced-pam":"9kndE"}],"9LH3Q":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;
// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
    __lookupGetter__: function __lookupGetter__(P) {
        var O = toObject(this);
        var K = toPrimitive(P, true);
        var D;
        do {
            if (D = getOwnPropertyDescriptor(O, K)) return D.get;
        }while (O = getPrototypeOf(O))
    }
});

},{"./_export":"1Tgvm","./_to-object":"7HHXi","./_to-primitive":"4Oubb","./_object-gpo":"4uFAD","./_object-gopd":"4bAUG","./_descriptors":"dr2tY","./_object-forced-pam":"9kndE"}],"kEN8G":[function(require,module,exports) {
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;
// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
    __lookupSetter__: function __lookupSetter__(P) {
        var O = toObject(this);
        var K = toPrimitive(P, true);
        var D;
        do {
            if (D = getOwnPropertyDescriptor(O, K)) return D.set;
        }while (O = getPrototypeOf(O))
    }
});

},{"./_export":"1Tgvm","./_to-object":"7HHXi","./_to-primitive":"4Oubb","./_object-gpo":"4uFAD","./_object-gopd":"4bAUG","./_descriptors":"dr2tY","./_object-forced-pam":"9kndE"}],"7iBxS":[function(require,module,exports) {
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');
$export($export.P + $export.R, 'Map', {
    toJSON: require('./_collection-to-json')('Map')
});

},{"./_export":"1Tgvm","./_collection-to-json":"jHAmP"}],"jHAmP":[function(require,module,exports) {
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function(NAME) {
    return function toJSON() {
        if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
        return from(this);
    };
};

},{"./_classof":"5TIen","./_array-from-iterable":"dANMj"}],"dANMj":[function(require,module,exports) {
var forOf = require('./_for-of');
module.exports = function(iter, ITERATOR) {
    var result = [];
    forOf(iter, false, result.push, result, ITERATOR);
    return result;
};

},{"./_for-of":"9a8I8"}],"exanP":[function(require,module,exports) {
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');
$export($export.P + $export.R, 'Set', {
    toJSON: require('./_collection-to-json')('Set')
});

},{"./_export":"1Tgvm","./_collection-to-json":"jHAmP"}],"dT1Dc":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":"dCQc8"}],"dCQc8":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
module.exports = function(COLLECTION) {
    $export($export.S, COLLECTION, {
        of: function of() {
            var length = arguments.length;
            var A = new Array(length);
            while(length--)A[length] = arguments[length];
            return new this(A);
        }
    });
};

},{"./_export":"1Tgvm"}],"jSRTa":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":"dCQc8"}],"39wfA":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":"dCQc8"}],"ikieO":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
require('./_set-collection-of')('WeakSet');

},{"./_set-collection-of":"dCQc8"}],"2MGKl":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":"5uH1y"}],"5uH1y":[function(require,module,exports) {
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');
module.exports = function(COLLECTION) {
    $export($export.S, COLLECTION, {
        from: function from(source /* , mapFn, thisArg */ ) {
            var mapFn = arguments[1];
            var mapping, A, n, cb;
            aFunction(this);
            mapping = mapFn !== undefined;
            if (mapping) aFunction(mapFn);
            if (source == undefined) return new this();
            A = [];
            if (mapping) {
                n = 0;
                cb = ctx(mapFn, arguments[2], 2);
                forOf(source, false, function(nextItem) {
                    A.push(cb(nextItem, n++));
                });
            } else forOf(source, false, A.push, A);
            return new this(A);
        }
    });
};

},{"./_export":"1Tgvm","./_a-function":"55L9l","./_ctx":"4rQSm","./_for-of":"9a8I8"}],"3AF6v":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":"5uH1y"}],"23jtR":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":"5uH1y"}],"hJc4O":[function(require,module,exports) {
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
require('./_set-collection-from')('WeakSet');

},{"./_set-collection-from":"5uH1y"}],"lshq0":[function(require,module,exports) {
// https://github.com/tc39/proposal-global
var $export = require('./_export');
$export($export.G, {
    global: require('./_global')
});

},{"./_export":"1Tgvm","./_global":"8xCse"}],"aLRNx":[function(require,module,exports) {
// https://github.com/tc39/proposal-global
var $export = require('./_export');
$export($export.S, 'System', {
    global: require('./_global')
});

},{"./_export":"1Tgvm","./_global":"8xCse"}],"3xhVh":[function(require,module,exports) {
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export');
var cof = require('./_cof');
$export($export.S, 'Error', {
    isError: function isError(it) {
        return cof(it) === 'Error';
    }
});

},{"./_export":"1Tgvm","./_cof":"frIbo"}],"bZ0NA":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
$export($export.S, 'Math', {
    clamp: function clamp(x, lower, upper) {
        return Math.min(upper, Math.max(lower, x));
    }
});

},{"./_export":"1Tgvm"}],"gOGEZ":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
$export($export.S, 'Math', {
    DEG_PER_RAD: Math.PI / 180
});

},{"./_export":"1Tgvm"}],"cdQDY":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var RAD_PER_DEG = 180 / Math.PI;
$export($export.S, 'Math', {
    degrees: function degrees(radians) {
        return radians * RAD_PER_DEG;
    }
});

},{"./_export":"1Tgvm"}],"fR5LK":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var scale = require('./_math-scale');
var fround = require('./_math-fround');
$export($export.S, 'Math', {
    fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
        return fround(scale(x, inLow, inHigh, outLow, outHigh));
    }
});

},{"./_export":"1Tgvm","./_math-scale":"6rAjD","./_math-fround":"9TbbN"}],"6rAjD":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
    if (arguments.length === 0 || x != x || inLow != inLow || inHigh != inHigh || outLow != outLow || outHigh != outHigh) return NaN;
    if (x === Infinity || x === -Infinity) return x;
    return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

},{}],"5Jbi2":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');
$export($export.S, 'Math', {
    iaddh: function iaddh(x0, x1, y0, y1) {
        var $x0 = x0 >>> 0;
        var $x1 = x1 >>> 0;
        var $y0 = y0 >>> 0;
        return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
    }
});

},{"./_export":"1Tgvm"}],"hrxFs":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');
$export($export.S, 'Math', {
    isubh: function isubh(x0, x1, y0, y1) {
        var $x0 = x0 >>> 0;
        var $x1 = x1 >>> 0;
        var $y0 = y0 >>> 0;
        return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
    }
});

},{"./_export":"1Tgvm"}],"i4YiT":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');
$export($export.S, 'Math', {
    imulh: function imulh(u, v) {
        var UINT16 = 65535;
        var $u = +u;
        var $v = +v;
        var u0 = $u & UINT16;
        var v0 = $v & UINT16;
        var u1 = $u >> 16;
        var v1 = $v >> 16;
        var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
        return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
    }
});

},{"./_export":"1Tgvm"}],"il4w2":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
$export($export.S, 'Math', {
    RAD_PER_DEG: 180 / Math.PI
});

},{"./_export":"1Tgvm"}],"7RQmX":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var DEG_PER_RAD = Math.PI / 180;
$export($export.S, 'Math', {
    radians: function radians(degrees) {
        return degrees * DEG_PER_RAD;
    }
});

},{"./_export":"1Tgvm"}],"jOPwg":[function(require,module,exports) {
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
$export($export.S, 'Math', {
    scale: require('./_math-scale')
});

},{"./_export":"1Tgvm","./_math-scale":"6rAjD"}],"8NRee":[function(require,module,exports) {
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');
$export($export.S, 'Math', {
    umulh: function umulh(u, v) {
        var UINT16 = 65535;
        var $u = +u;
        var $v = +v;
        var u0 = $u & UINT16;
        var v0 = $v & UINT16;
        var u1 = $u >>> 16;
        var v1 = $v >>> 16;
        var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
        return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
    }
});

},{"./_export":"1Tgvm"}],"ePksm":[function(require,module,exports) {
// http://jfbastien.github.io/papers/Math.signbit.html
var $export = require('./_export');
$export($export.S, 'Math', {
    signbit: function signbit(x) {
        // eslint-disable-next-line no-self-compare
        return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
    }
});

},{"./_export":"1Tgvm"}],"2JMTL":[function(require,module,exports) {
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');
$export($export.P + $export.R, 'Promise', {
    'finally': function(onFinally) {
        var C = speciesConstructor(this, core.Promise || global.Promise);
        var isFunction = typeof onFinally == 'function';
        return this.then(isFunction ? function(x) {
            return promiseResolve(C, onFinally()).then(function() {
                return x;
            });
        } : onFinally, isFunction ? function(e) {
            return promiseResolve(C, onFinally()).then(function() {
                throw e;
            });
        } : onFinally);
    }
});

},{"./_export":"1Tgvm","./_core":"4o9Ko","./_global":"8xCse","./_species-constructor":"8Vo8d","./_promise-resolve":"58Dua"}],"2RsT8":[function(require,module,exports) {
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');
$export($export.S, 'Promise', {
    'try': function(callbackfn) {
        var promiseCapability = newPromiseCapability.f(this);
        var result = perform(callbackfn);
        (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
        return promiseCapability.promise;
    }
});

},{"./_export":"1Tgvm","./_new-promise-capability":"clM6P","./_perform":"7Nx5Z"}],"iQ9qT":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;
metadata.exp({
    defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
        ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
    }
});

},{"./_metadata":"gajc8","./_an-object":"kiL2X"}],"gajc8":[function(require,module,exports) {
var Map = require('./es6.map');
var $export = require('./_export');
var shared = require('./_shared')('metadata');
var store = shared.store || (shared.store = new (require('./es6.weak-map'))());
var getOrCreateMetadataMap = function(target, targetKey, create) {
    var targetMetadata = store.get(target);
    if (!targetMetadata) {
        if (!create) return undefined;
        store.set(target, targetMetadata = new Map());
    }
    var keyMetadata = targetMetadata.get(targetKey);
    if (!keyMetadata) {
        if (!create) return undefined;
        targetMetadata.set(targetKey, keyMetadata = new Map());
    }
    return keyMetadata;
};
var ordinaryHasOwnMetadata = function(MetadataKey, O, P) {
    var metadataMap = getOrCreateMetadataMap(O, P, false);
    return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function(MetadataKey, O, P) {
    var metadataMap = getOrCreateMetadataMap(O, P, false);
    return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P) {
    getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function(target, targetKey) {
    var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
    var keys = [];
    if (metadataMap) metadataMap.forEach(function(_, key) {
        keys.push(key);
    });
    return keys;
};
var toMetaKey = function(it) {
    return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function(O) {
    $export($export.S, 'Reflect', O);
};
module.exports = {
    store: store,
    map: getOrCreateMetadataMap,
    has: ordinaryHasOwnMetadata,
    get: ordinaryGetOwnMetadata,
    set: ordinaryDefineOwnMetadata,
    keys: ordinaryOwnMetadataKeys,
    key: toMetaKey,
    exp: exp
};

},{"./es6.map":"1kXi9","./_export":"1Tgvm","./_shared":"9XC5J","./es6.weak-map":"dAOwL"}],"4glRb":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;
metadata.exp({
    deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */ ) {
        var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
        var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
        if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
        if (metadataMap.size) return true;
        var targetMetadata = store.get(target);
        targetMetadata['delete'](targetKey);
        return !!targetMetadata.size || store['delete'](target);
    }
});

},{"./_metadata":"gajc8","./_an-object":"kiL2X"}],"kmvi8":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;
var ordinaryGetMetadata = function(MetadataKey, O, P) {
    var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
    if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
    var parent = getPrototypeOf(O);
    return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};
metadata.exp({
    getMetadata: function getMetadata(metadataKey, target /* , targetKey */ ) {
        return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
    }
});

},{"./_metadata":"gajc8","./_an-object":"kiL2X","./_object-gpo":"4uFAD"}],"6bA9p":[function(require,module,exports) {
var Set = require('./es6.set');
var from = require('./_array-from-iterable');
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;
var ordinaryMetadataKeys = function(O, P) {
    var oKeys = ordinaryOwnMetadataKeys(O, P);
    var parent = getPrototypeOf(O);
    if (parent === null) return oKeys;
    var pKeys = ordinaryMetadataKeys(parent, P);
    return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};
metadata.exp({
    getMetadataKeys: function getMetadataKeys(target /* , targetKey */ ) {
        return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
    }
});

},{"./es6.set":"61Y2Y","./_array-from-iterable":"dANMj","./_metadata":"gajc8","./_an-object":"kiL2X","./_object-gpo":"4uFAD"}],"jebxh":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;
metadata.exp({
    getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */ ) {
        return ordinaryGetOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
    }
});

},{"./_metadata":"gajc8","./_an-object":"kiL2X"}],"jGnWP":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;
metadata.exp({
    getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */ ) {
        return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
    }
});

},{"./_metadata":"gajc8","./_an-object":"kiL2X"}],"bZiK8":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;
var ordinaryHasMetadata = function(MetadataKey, O, P) {
    var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
    if (hasOwn) return true;
    var parent = getPrototypeOf(O);
    return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};
metadata.exp({
    hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */ ) {
        return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
    }
});

},{"./_metadata":"gajc8","./_an-object":"kiL2X","./_object-gpo":"4uFAD"}],"khZMr":[function(require,module,exports) {
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;
metadata.exp({
    hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */ ) {
        return ordinaryHasOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
    }
});

},{"./_metadata":"gajc8","./_an-object":"kiL2X"}],"dQNHX":[function(require,module,exports) {
var $metadata = require('./_metadata');
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;
$metadata.exp({
    metadata: function metadata(metadataKey, metadataValue) {
        return function decorator(target, targetKey) {
            ordinaryDefineOwnMetadata(metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey));
        };
    }
});

},{"./_metadata":"gajc8","./_an-object":"kiL2X","./_a-function":"55L9l"}],"eXG8y":[function(require,module,exports) {
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = require('./_export');
var microtask = require('./_microtask')();
var process = require('./_global').process;
var isNode = require('./_cof')(process) == 'process';
$export($export.G, {
    asap: function asap(fn) {
        var domain = isNode && process.domain;
        microtask(domain ? domain.bind(fn) : fn);
    }
});

},{"./_export":"1Tgvm","./_microtask":"8lwWF","./_global":"8xCse","./_cof":"frIbo"}],"dqE8O":[function(require,module,exports) {
'use strict';
// https://github.com/zenparsing/es-observable
var $export = require('./_export');
var global = require('./_global');
var core = require('./_core');
var microtask = require('./_microtask')();
var OBSERVABLE = require('./_wks')('observable');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var anInstance = require('./_an-instance');
var redefineAll = require('./_redefine-all');
var hide = require('./_hide');
var forOf = require('./_for-of');
var RETURN = forOf.RETURN;
var getMethod = function(fn) {
    return fn == null ? undefined : aFunction(fn);
};
var cleanupSubscription = function(subscription) {
    var cleanup = subscription._c;
    if (cleanup) {
        subscription._c = undefined;
        cleanup();
    }
};
var subscriptionClosed = function(subscription) {
    return subscription._o === undefined;
};
var closeSubscription = function(subscription) {
    if (!subscriptionClosed(subscription)) {
        subscription._o = undefined;
        cleanupSubscription(subscription);
    }
};
var Subscription = function(observer, subscriber) {
    anObject(observer);
    this._c = undefined;
    this._o = observer;
    observer = new SubscriptionObserver(this);
    try {
        var cleanup = subscriber(observer);
        var subscription = cleanup;
        if (cleanup != null) {
            if (typeof cleanup.unsubscribe === 'function') cleanup = function() {
                subscription.unsubscribe();
            };
            else aFunction(cleanup);
            this._c = cleanup;
        }
    } catch (e) {
        observer.error(e);
        return;
    }
    if (subscriptionClosed(this)) cleanupSubscription(this);
};
Subscription.prototype = redefineAll({}, {
    unsubscribe: function unsubscribe() {
        closeSubscription(this);
    }
});
var SubscriptionObserver = function(subscription) {
    this._s = subscription;
};
SubscriptionObserver.prototype = redefineAll({}, {
    next: function next(value) {
        var subscription = this._s;
        if (!subscriptionClosed(subscription)) {
            var observer = subscription._o;
            try {
                var m = getMethod(observer.next);
                if (m) return m.call(observer, value);
            } catch (e) {
                try {
                    closeSubscription(subscription);
                } finally{
                    throw e;
                }
            }
        }
    },
    error: function error(value) {
        var subscription = this._s;
        if (subscriptionClosed(subscription)) throw value;
        var observer = subscription._o;
        subscription._o = undefined;
        try {
            var m = getMethod(observer.error);
            if (!m) throw value;
            value = m.call(observer, value);
        } catch (e) {
            try {
                cleanupSubscription(subscription);
            } finally{
                throw e;
            }
        }
        cleanupSubscription(subscription);
        return value;
    },
    complete: function complete(value) {
        var subscription = this._s;
        if (!subscriptionClosed(subscription)) {
            var observer = subscription._o;
            subscription._o = undefined;
            try {
                var m = getMethod(observer.complete);
                value = m ? m.call(observer, value) : undefined;
            } catch (e) {
                try {
                    cleanupSubscription(subscription);
                } finally{
                    throw e;
                }
            }
            cleanupSubscription(subscription);
            return value;
        }
    }
});
var $Observable = function Observable(subscriber) {
    anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};
redefineAll($Observable.prototype, {
    subscribe: function subscribe(observer) {
        return new Subscription(observer, this._f);
    },
    forEach: function forEach(fn) {
        var that = this;
        return new (core.Promise || global.Promise)(function(resolve, reject) {
            aFunction(fn);
            var subscription = that.subscribe({
                next: function(value) {
                    try {
                        return fn(value);
                    } catch (e) {
                        reject(e);
                        subscription.unsubscribe();
                    }
                },
                error: reject,
                complete: resolve
            });
        });
    }
});
redefineAll($Observable, {
    from: function from(x) {
        var C = typeof this === 'function' ? this : $Observable;
        var method = getMethod(anObject(x)[OBSERVABLE]);
        if (method) {
            var observable = anObject(method.call(x));
            return observable.constructor === C ? observable : new C(function(observer) {
                return observable.subscribe(observer);
            });
        }
        return new C(function(observer) {
            var done = false;
            microtask(function() {
                if (!done) {
                    try {
                        if (forOf(x, false, function(it) {
                            observer.next(it);
                            if (done) return RETURN;
                        }) === RETURN) return;
                    } catch (e) {
                        if (done) throw e;
                        observer.error(e);
                        return;
                    }
                    observer.complete();
                }
            });
            return function() {
                done = true;
            };
        });
    },
    of: function of() {
        for(var i = 0, l = arguments.length, items = new Array(l); i < l;)items[i] = arguments[i++];
        return new (typeof this === 'function' ? this : $Observable)(function(observer) {
            var done = false;
            microtask(function() {
                if (!done) {
                    for(var j = 0; j < items.length; ++j){
                        observer.next(items[j]);
                        if (done) return;
                    }
                    observer.complete();
                }
            });
            return function() {
                done = true;
            };
        });
    }
});
hide($Observable.prototype, OBSERVABLE, function() {
    return this;
});
$export($export.G, {
    Observable: $Observable
});
require('./_set-species')('Observable');

},{"./_export":"1Tgvm","./_global":"8xCse","./_core":"4o9Ko","./_microtask":"8lwWF","./_wks":"eaoKZ","./_a-function":"55L9l","./_an-object":"kiL2X","./_an-instance":"ivm35","./_redefine-all":"6Mnp5","./_hide":"ddpVq","./_for-of":"9a8I8","./_set-species":"1qQNM"}],"dl3SO":[function(require,module,exports) {
// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var userAgent = require('./_user-agent');
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function(set) {
    return function(fn, time /* , ...args */ ) {
        var boundArgs = arguments.length > 2;
        var args = boundArgs ? slice.call(arguments, 2) : false;
        return set(boundArgs ? function() {
            // eslint-disable-next-line no-new-func
            (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
        } : fn, time);
    };
};
$export($export.G + $export.B + $export.F * MSIE, {
    setTimeout: wrap(global.setTimeout),
    setInterval: wrap(global.setInterval)
});

},{"./_global":"8xCse","./_export":"1Tgvm","./_user-agent":"9eCfU"}],"49tUX":[function(require,module,exports) {
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
    setImmediate: $task.set,
    clearImmediate: $task.clear
});

},{"./_export":"1Tgvm","./_task":"bPiT9"}],"iv8Qo":[function(require,module,exports) {
var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;
var DOMIterables = {
    CSSRuleList: true,
    CSSStyleDeclaration: false,
    CSSValueList: false,
    ClientRectList: false,
    DOMRectList: false,
    DOMStringList: false,
    DOMTokenList: true,
    DataTransferItemList: false,
    FileList: false,
    HTMLAllCollection: false,
    HTMLCollection: false,
    HTMLFormElement: false,
    HTMLSelectElement: false,
    MediaList: true,
    MimeTypeArray: false,
    NamedNodeMap: false,
    NodeList: true,
    PaintRequestList: false,
    Plugin: false,
    PluginArray: false,
    SVGLengthList: false,
    SVGNumberList: false,
    SVGPathSegList: false,
    SVGPointList: false,
    SVGStringList: false,
    SVGTransformList: false,
    SourceBufferList: false,
    StyleSheetList: true,
    TextTrackCueList: false,
    TextTrackList: false,
    TouchList: false
};
for(var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++){
    var NAME = collections[i];
    var explicit = DOMIterables[NAME];
    var Collection = global[NAME];
    var proto = Collection && Collection.prototype;
    var key;
    if (proto) {
        if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
        if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
        Iterators[NAME] = ArrayValues;
        if (explicit) {
            for(key in $iterators)if (!proto[key]) redefine(proto, key, $iterators[key], true);
        }
    }
}

},{"./es6.array.iterator":"1xhrt","./_object-keys":"98CC0","./_redefine":"9vAu7","./_global":"8xCse","./_hide":"ddpVq","./_iterators":"dITQr","./_wks":"eaoKZ"}],"dXNgZ":[function(require,module,exports) {
var global = arguments[3];
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */ !function(global1) {
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    var inModule = true;
    var runtime = global1.regeneratorRuntime;
    if (runtime) {
        if (inModule) // If regeneratorRuntime is defined globally and we're in a module,
        // make the exports object identical to regeneratorRuntime.
        module.exports = runtime;
        // Don't bother evaluating the rest of this file if the runtime was
        // already defined globally.
        return;
    }
    // Define the runtime globally (as expected by generated code) as either
    // module.exports (if we're in a module) or a new, empty object.
    runtime = global1.regeneratorRuntime = inModule ? module.exports : {};
    function wrap(innerFn, outerFn, self, tryLocsList) {
        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        // The ._invoke method unifies the implementations of the .next,
        // .throw, and .return methods.
        generator._invoke = makeInvokeMethod(innerFn, self, context);
        return generator;
    }
    runtime.wrap = wrap;
    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
        try {
            return {
                type: "normal",
                arg: fn.call(obj, arg)
            };
        } catch (err) {
            return {
                type: "throw",
                arg: err
            };
        }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};
    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function() {
        return this;
    };
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
        [
            "next",
            "throw",
            "return"
        ].forEach(function(method) {
            prototype[method] = function(arg) {
                return this._invoke(method, arg);
            };
        });
    }
    runtime.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };
    runtime.mark = function(genFun) {
        if (Object.setPrototypeOf) Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        else {
            genFun.__proto__ = GeneratorFunctionPrototype;
            if (!(toStringTagSymbol in genFun)) genFun[toStringTagSymbol] = "GeneratorFunction";
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
    };
    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    runtime.awrap = function(arg) {
        return {
            __await: arg
        };
    };
    function AsyncIterator(generator) {
        function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if (record.type === "throw") reject(record.arg);
            else {
                var result = record.arg;
                var value1 = result.value;
                if (value1 && typeof value1 === "object" && hasOwn.call(value1, "__await")) return Promise.resolve(value1.__await).then(function(value) {
                    invoke("next", value, resolve, reject);
                }, function(err) {
                    invoke("throw", err, resolve, reject);
                });
                return Promise.resolve(value1).then(function(unwrapped) {
                    // When a yielded Promise is resolved, its final value becomes
                    // the .value of the Promise<{value,done}> result for the
                    // current iteration. If the Promise is rejected, however, the
                    // result for this iteration will be rejected with the same
                    // reason. Note that rejections of yielded Promises are not
                    // thrown back into the generator function, as is the case
                    // when an awaited Promise is rejected. This difference in
                    // behavior between yield and await is important, because it
                    // allows the consumer to decide what to do with the yielded
                    // rejection (swallow it and continue, manually .throw it back
                    // into the generator, abandon iteration, whatever). With
                    // await, by contrast, there is no opportunity to examine the
                    // rejection reason outside the generator function, so the
                    // only option is to throw it from the await expression, and
                    // let the generator function handle the exception.
                    result.value = unwrapped;
                    resolve(result);
                }, reject);
            }
        }
        if (typeof global1.process === "object" && global1.process.domain) invoke = global1.process.domain.bind(invoke);
        var previousPromise;
        function enqueue(method, arg) {
            function callInvokeWithMethodAndArg() {
                return new Promise(function(resolve, reject) {
                    invoke(method, arg, resolve, reject);
                });
            }
            return previousPromise = // If enqueue has been called before, then we want to wait until
            // all previous Promises have been resolved before calling invoke,
            // so that results are always delivered in the correct order. If
            // enqueue has not been called before, then it is important to
            // call invoke immediately, without waiting on a callback to fire,
            // so that the async generator function has the opportunity to do
            // any necessary setup in a predictable way. This predictability
            // is why the Promise constructor synchronously invokes its
            // executor callback, and why async functions synchronously
            // execute code before the first await. Since we implement simple
            // async functions in terms of async generators, it is especially
            // important to get this right, even though it requires care.
            previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
        // Define the unified helper method that is used to implement .next,
        // .throw, and .return (see defineIteratorMethods).
        this._invoke = enqueue;
    }
    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function() {
        return this;
    };
    runtime.AsyncIterator = AsyncIterator;
    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    runtime.async = function(innerFn, outerFn, self, tryLocsList) {
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
        return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
         : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
        });
    };
    function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
            if (state === GenStateExecuting) throw new Error("Generator is already running");
            if (state === GenStateCompleted) {
                if (method === "throw") throw arg;
                // Be forgiving, per 25.3.3.3.3 of the spec:
                // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
                return doneResult();
            }
            context.method = method;
            context.arg = arg;
            while(true){
                var delegate = context.delegate;
                if (delegate) {
                    var delegateResult = maybeInvokeDelegate(delegate, context);
                    if (delegateResult) {
                        if (delegateResult === ContinueSentinel) continue;
                        return delegateResult;
                    }
                }
                if (context.method === "next") // Setting context._sent for legacy support of Babel's
                // function.sent implementation.
                context.sent = context._sent = context.arg;
                else if (context.method === "throw") {
                    if (state === GenStateSuspendedStart) {
                        state = GenStateCompleted;
                        throw context.arg;
                    }
                    context.dispatchException(context.arg);
                } else if (context.method === "return") context.abrupt("return", context.arg);
                state = GenStateExecuting;
                var record = tryCatch(innerFn, self, context);
                if (record.type === "normal") {
                    // If an exception is thrown from innerFn, we leave state ===
                    // GenStateExecuting and loop back for another invocation.
                    state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                    if (record.arg === ContinueSentinel) continue;
                    return {
                        value: record.arg,
                        done: context.done
                    };
                } else if (record.type === "throw") {
                    state = GenStateCompleted;
                    // Dispatch the exception by looping back around to the
                    // context.dispatchException(context.arg) call above.
                    context.method = "throw";
                    context.arg = record.arg;
                }
            }
        };
    }
    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (method === undefined) {
            // A .throw or .return when the delegate iterator has no .throw
            // method always terminates the yield* loop.
            context.delegate = null;
            if (context.method === "throw") {
                if (delegate.iterator.return) {
                    // If the delegate iterator has a return method, give it a
                    // chance to clean up.
                    context.method = "return";
                    context.arg = undefined;
                    maybeInvokeDelegate(delegate, context);
                    if (context.method === "throw") // If maybeInvokeDelegate(context) changed context.method from
                    // "return" to "throw", let that override the TypeError below.
                    return ContinueSentinel;
                }
                context.method = "throw";
                context.arg = new TypeError("The iterator does not provide a 'throw' method");
            }
            return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
            context.method = "throw";
            context.arg = record.arg;
            context.delegate = null;
            return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
            context.method = "throw";
            context.arg = new TypeError("iterator result is not an object");
            context.delegate = null;
            return ContinueSentinel;
        }
        if (info.done) {
            // Assign the result of the finished delegate to the temporary
            // variable specified by delegate.resultName (see delegateYield).
            context[delegate.resultName] = info.value;
            // Resume execution at the desired location (see delegateYield).
            context.next = delegate.nextLoc;
            // If context.method was "throw" but the delegate handled the
            // exception, let the outer generator proceed normally. If
            // context.method was "next", forget context.arg since it has been
            // "consumed" by the delegate iterator. If context.method was
            // "return", allow the original .return call to continue in the
            // outer generator.
            if (context.method !== "return") {
                context.method = "next";
                context.arg = undefined;
            }
        } else // Re-yield the result returned by the delegate method.
        return info;
        // The delegate iterator is finished, so forget it and continue with
        // the outer generator.
        context.delegate = null;
        return ContinueSentinel;
    }
    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);
    Gp[toStringTagSymbol] = "Generator";
    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    Gp[iteratorSymbol] = function() {
        return this;
    };
    Gp.toString = function() {
        return "[object Generator]";
    };
    function pushTryEntry(locs) {
        var entry = {
            tryLoc: locs[0]
        };
        if (1 in locs) entry.catchLoc = locs[1];
        if (2 in locs) {
            entry.finallyLoc = locs[2];
            entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
    }
    function Context(tryLocsList) {
        // The root entry object (effectively a try statement without a catch
        // or a finally block) gives us a place to store values thrown from
        // locations where there is no enclosing try statement.
        this.tryEntries = [
            {
                tryLoc: "root"
            }
        ];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
    }
    runtime.keys = function(object) {
        var keys = [];
        for(var key1 in object)keys.push(key1);
        keys.reverse();
        // Rather than returning an object with a next method, we keep
        // things simple and return the next function itself.
        return function next() {
            while(keys.length){
                var key = keys.pop();
                if (key in object) {
                    next.value = key;
                    next.done = false;
                    return next;
                }
            }
            // To avoid creating an additional object, we just hang the .value
            // and .done properties off the next function object itself. This
            // also ensures that the minifier will not anonymize the function.
            next.done = true;
            return next;
        };
    };
    function values(iterable) {
        if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) return iteratorMethod.call(iterable);
            if (typeof iterable.next === "function") return iterable;
            if (!isNaN(iterable.length)) {
                var i = -1, next1 = function next() {
                    while(++i < iterable.length)if (hasOwn.call(iterable, i)) {
                        next.value = iterable[i];
                        next.done = false;
                        return next;
                    }
                    next.value = undefined;
                    next.done = true;
                    return next;
                };
                return next1.next = next1;
            }
        }
        // Return an iterator with no values.
        return {
            next: doneResult
        };
    }
    runtime.values = values;
    function doneResult() {
        return {
            value: undefined,
            done: true
        };
    }
    Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
            this.prev = 0;
            this.next = 0;
            // Resetting context._sent for legacy support of Babel's
            // function.sent implementation.
            this.sent = this._sent = undefined;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = undefined;
            this.tryEntries.forEach(resetTryEntry);
            if (!skipTempReset) {
                for(var name in this)// Not sure about the optimal order of these conditions:
                if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) this[name] = undefined;
            }
        },
        stop: function() {
            this.done = true;
            var rootEntry = this.tryEntries[0];
            var rootRecord = rootEntry.completion;
            if (rootRecord.type === "throw") throw rootRecord.arg;
            return this.rval;
        },
        dispatchException: function(exception) {
            if (this.done) throw exception;
            var context = this;
            function handle(loc, caught) {
                record.type = "throw";
                record.arg = exception;
                context.next = loc;
                if (caught) {
                    // If the dispatched exception was caught by a catch block,
                    // then let that catch block handle the exception normally.
                    context.method = "next";
                    context.arg = undefined;
                }
                return !!caught;
            }
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                var record = entry.completion;
                if (entry.tryLoc === "root") // Exception thrown outside of any try block that could handle
                // it, so set the completion value of the entire function to
                // throw the exception.
                return handle("end");
                if (entry.tryLoc <= this.prev) {
                    var hasCatch = hasOwn.call(entry, "catchLoc");
                    var hasFinally = hasOwn.call(entry, "finallyLoc");
                    if (hasCatch && hasFinally) {
                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, true);
                        else if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    } else if (hasCatch) {
                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, true);
                    } else if (hasFinally) {
                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    } else throw new Error("try statement without catch or finally");
                }
            }
        },
        abrupt: function(type, arg) {
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                    var finallyEntry = entry;
                    break;
                }
            }
            if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) // Ignore the finally entry if control is not jumping to a
            // location outside the try/catch block.
            finallyEntry = null;
            var record = finallyEntry ? finallyEntry.completion : {};
            record.type = type;
            record.arg = arg;
            if (finallyEntry) {
                this.method = "next";
                this.next = finallyEntry.finallyLoc;
                return ContinueSentinel;
            }
            return this.complete(record);
        },
        complete: function(record, afterLoc) {
            if (record.type === "throw") throw record.arg;
            if (record.type === "break" || record.type === "continue") this.next = record.arg;
            else if (record.type === "return") {
                this.rval = this.arg = record.arg;
                this.method = "return";
                this.next = "end";
            } else if (record.type === "normal" && afterLoc) this.next = afterLoc;
            return ContinueSentinel;
        },
        finish: function(finallyLoc) {
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                if (entry.finallyLoc === finallyLoc) {
                    this.complete(entry.completion, entry.afterLoc);
                    resetTryEntry(entry);
                    return ContinueSentinel;
                }
            }
        },
        "catch": function(tryLoc) {
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                if (entry.tryLoc === tryLoc) {
                    var record = entry.completion;
                    if (record.type === "throw") {
                        var thrown = record.arg;
                        resetTryEntry(entry);
                    }
                    return thrown;
                }
            }
            // The context.catch method must only be called with a location
            // argument that corresponds to a known catch block.
            throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
            this.delegate = {
                iterator: values(iterable),
                resultName: resultName,
                nextLoc: nextLoc
            };
            if (this.method === "next") // Deliberately forget the last sent value so that we don't
            // accidentally pass it on to the delegate.
            this.arg = undefined;
            return ContinueSentinel;
        }
    };
}(// Among the various tricks for obtaining a reference to the global
// object, this seems to be the most reliable technique that does not
// use indirect eval (which violates Content Security Policy).
typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : this);

},{}],"4Rfsd":[function(require,module,exports) {
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;

},{"../../modules/core.regexp.escape":"kwUMR","../../modules/_core":"4o9Ko"}],"kwUMR":[function(require,module,exports) {
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export');
var $re = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');
$export($export.S, 'RegExp', {
    escape: function escape(it) {
        return $re(it);
    }
});

},{"./_export":"1Tgvm","./_replacer":"gaojh"}],"gaojh":[function(require,module,exports) {
module.exports = function(regExp, replace) {
    var replacer = replace === Object(replace) ? function(part) {
        return replace[part];
    } : replace;
    return function(it) {
        return String(it).replace(regExp, replacer);
    };
};

},{}],"8wzUn":[function(require,module,exports) {
var _three = require("three");
_three.Plane.prototype.intersectRay = function(p, r, target) {
    let nr = r.normalize();
    let t = (this.constant - this.normal.dot(p)) / this.normal.dot(nr);
    if (isFinite(t) && t >= 0) return target.copy(p.add(nr.multiplyScalar(t)));
    return false;
};
_three.Triangle.prototype.intersectRay = function(p, ray, result) {
    let ab = new _three.Vector3().subVectors(this.b, this.a);
    let ac = new _three.Vector3().subVectors(this.c, this.a);
    let n = new _three.Vector3().crossVectors(ab, ac);
    let d = ray.dot(n);
    if (d <= 0) return false;
    let ap = new _three.Vector3().subVectors(p, this.a);
    let t = -ap.dot(n);
    if (t < 0) return false;
    let e = new _three.Vector3().crossVectors(ray, ap);
    let u, v, w;
    v = ac.dot(e);
    if (v < 0 || v > d) return false;
    w = -ab.dot(e);
    if (w < 0 || v + w > d) return false;
    let ood = 1 / d;
    t *= ood;
    v *= ood;
    w *= ood;
    u = 1 - v - w;
    let pRay = ray.multiplyScalar(t);
    result.point = pRay.add(p);
    result.normal = new _three.Vector3(u, v, w);
    return true;
};
_three.DirectionalLight.prototype.targetOffset = new _three.Vector3(200, 300, 100);
_three.DirectionalLight.prototype.update = function() {
    this.position.set(this.target.position.x + this.targetOffset.x, this.target.position.y + this.targetOffset.y, this.target.position.z + this.targetOffset.z);
};
Object.completeAssign = function(target, ...sources) {
    sources.forEach((source)=>{
        let descriptors1 = Object.keys(source).reduce((descriptors, key)=>{
            descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
            return descriptors;
        }, {}); // by default, Object.assign copies enumerable Symbols too
        Object.getOwnPropertySymbols(source).forEach((sym)=>{
            let descriptor = Object.getOwnPropertyDescriptor(source, sym);
            if (descriptor.enumerable) descriptors1[sym] = descriptor;
        });
        Object.defineProperties(target, descriptors1);
    });
    return target;
};

},{"three":"ktPTu"}],"ktPTu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ACESFilmicToneMapping", ()=>ACESFilmicToneMapping
);
parcelHelpers.export(exports, "AddEquation", ()=>AddEquation
);
parcelHelpers.export(exports, "AddOperation", ()=>AddOperation
);
parcelHelpers.export(exports, "AdditiveAnimationBlendMode", ()=>AdditiveAnimationBlendMode
);
parcelHelpers.export(exports, "AdditiveBlending", ()=>AdditiveBlending
);
parcelHelpers.export(exports, "AlphaFormat", ()=>AlphaFormat
);
parcelHelpers.export(exports, "AlwaysDepth", ()=>AlwaysDepth
);
parcelHelpers.export(exports, "AlwaysStencilFunc", ()=>AlwaysStencilFunc
);
parcelHelpers.export(exports, "AmbientLight", ()=>AmbientLight
);
parcelHelpers.export(exports, "AmbientLightProbe", ()=>AmbientLightProbe
);
parcelHelpers.export(exports, "AnimationClip", ()=>AnimationClip
);
parcelHelpers.export(exports, "AnimationLoader", ()=>AnimationLoader
);
parcelHelpers.export(exports, "AnimationMixer", ()=>AnimationMixer
);
parcelHelpers.export(exports, "AnimationObjectGroup", ()=>AnimationObjectGroup
);
parcelHelpers.export(exports, "AnimationUtils", ()=>AnimationUtils
);
parcelHelpers.export(exports, "ArcCurve", ()=>ArcCurve
);
parcelHelpers.export(exports, "ArrayCamera", ()=>ArrayCamera
);
parcelHelpers.export(exports, "ArrowHelper", ()=>ArrowHelper
);
parcelHelpers.export(exports, "Audio", ()=>Audio
);
parcelHelpers.export(exports, "AudioAnalyser", ()=>AudioAnalyser
);
parcelHelpers.export(exports, "AudioContext", ()=>AudioContext
);
parcelHelpers.export(exports, "AudioListener", ()=>AudioListener
);
parcelHelpers.export(exports, "AudioLoader", ()=>AudioLoader
);
parcelHelpers.export(exports, "AxesHelper", ()=>AxesHelper
);
parcelHelpers.export(exports, "AxisHelper", ()=>AxisHelper
);
parcelHelpers.export(exports, "BackSide", ()=>BackSide
);
parcelHelpers.export(exports, "BasicDepthPacking", ()=>BasicDepthPacking
);
parcelHelpers.export(exports, "BasicShadowMap", ()=>BasicShadowMap
);
parcelHelpers.export(exports, "BinaryTextureLoader", ()=>BinaryTextureLoader
);
parcelHelpers.export(exports, "Bone", ()=>Bone
);
parcelHelpers.export(exports, "BooleanKeyframeTrack", ()=>BooleanKeyframeTrack
);
parcelHelpers.export(exports, "BoundingBoxHelper", ()=>BoundingBoxHelper
);
parcelHelpers.export(exports, "Box2", ()=>Box2
);
parcelHelpers.export(exports, "Box3", ()=>Box3
);
parcelHelpers.export(exports, "Box3Helper", ()=>Box3Helper
);
parcelHelpers.export(exports, "BoxBufferGeometry", ()=>BoxBufferGeometry
);
parcelHelpers.export(exports, "BoxGeometry", ()=>BoxGeometry
);
parcelHelpers.export(exports, "BoxHelper", ()=>BoxHelper
);
parcelHelpers.export(exports, "BufferAttribute", ()=>BufferAttribute
);
parcelHelpers.export(exports, "BufferGeometry", ()=>BufferGeometry
);
parcelHelpers.export(exports, "BufferGeometryLoader", ()=>BufferGeometryLoader
);
parcelHelpers.export(exports, "ByteType", ()=>ByteType
);
parcelHelpers.export(exports, "Cache", ()=>Cache
);
parcelHelpers.export(exports, "Camera", ()=>Camera
);
parcelHelpers.export(exports, "CameraHelper", ()=>CameraHelper
);
parcelHelpers.export(exports, "CanvasRenderer", ()=>CanvasRenderer
);
parcelHelpers.export(exports, "CanvasTexture", ()=>CanvasTexture
);
parcelHelpers.export(exports, "CatmullRomCurve3", ()=>CatmullRomCurve3
);
parcelHelpers.export(exports, "CineonToneMapping", ()=>CineonToneMapping
);
parcelHelpers.export(exports, "CircleBufferGeometry", ()=>CircleBufferGeometry
);
parcelHelpers.export(exports, "CircleGeometry", ()=>CircleGeometry
);
parcelHelpers.export(exports, "ClampToEdgeWrapping", ()=>ClampToEdgeWrapping
);
parcelHelpers.export(exports, "Clock", ()=>Clock
);
parcelHelpers.export(exports, "ClosedSplineCurve3", ()=>ClosedSplineCurve3
);
parcelHelpers.export(exports, "Color", ()=>Color
);
parcelHelpers.export(exports, "ColorKeyframeTrack", ()=>ColorKeyframeTrack
);
parcelHelpers.export(exports, "CompressedTexture", ()=>CompressedTexture
);
parcelHelpers.export(exports, "CompressedTextureLoader", ()=>CompressedTextureLoader
);
parcelHelpers.export(exports, "ConeBufferGeometry", ()=>ConeBufferGeometry
);
parcelHelpers.export(exports, "ConeGeometry", ()=>ConeGeometry
);
parcelHelpers.export(exports, "CubeCamera", ()=>CubeCamera
);
parcelHelpers.export(exports, "CubeGeometry", ()=>BoxGeometry
);
parcelHelpers.export(exports, "CubeReflectionMapping", ()=>CubeReflectionMapping
);
parcelHelpers.export(exports, "CubeRefractionMapping", ()=>CubeRefractionMapping
);
parcelHelpers.export(exports, "CubeTexture", ()=>CubeTexture
);
parcelHelpers.export(exports, "CubeTextureLoader", ()=>CubeTextureLoader
);
parcelHelpers.export(exports, "CubeUVReflectionMapping", ()=>CubeUVReflectionMapping
);
parcelHelpers.export(exports, "CubeUVRefractionMapping", ()=>CubeUVRefractionMapping
);
parcelHelpers.export(exports, "CubicBezierCurve", ()=>CubicBezierCurve
);
parcelHelpers.export(exports, "CubicBezierCurve3", ()=>CubicBezierCurve3
);
parcelHelpers.export(exports, "CubicInterpolant", ()=>CubicInterpolant
);
parcelHelpers.export(exports, "CullFaceBack", ()=>CullFaceBack
);
parcelHelpers.export(exports, "CullFaceFront", ()=>CullFaceFront
);
parcelHelpers.export(exports, "CullFaceFrontBack", ()=>CullFaceFrontBack
);
parcelHelpers.export(exports, "CullFaceNone", ()=>CullFaceNone
);
parcelHelpers.export(exports, "Curve", ()=>Curve
);
parcelHelpers.export(exports, "CurvePath", ()=>CurvePath
);
parcelHelpers.export(exports, "CustomBlending", ()=>CustomBlending
);
parcelHelpers.export(exports, "CustomToneMapping", ()=>CustomToneMapping
);
parcelHelpers.export(exports, "CylinderBufferGeometry", ()=>CylinderBufferGeometry
);
parcelHelpers.export(exports, "CylinderGeometry", ()=>CylinderGeometry
);
parcelHelpers.export(exports, "Cylindrical", ()=>Cylindrical
);
parcelHelpers.export(exports, "DataTexture", ()=>DataTexture
);
parcelHelpers.export(exports, "DataTexture2DArray", ()=>DataTexture2DArray
);
parcelHelpers.export(exports, "DataTexture3D", ()=>DataTexture3D
);
parcelHelpers.export(exports, "DataTextureLoader", ()=>DataTextureLoader
);
parcelHelpers.export(exports, "DecrementStencilOp", ()=>DecrementStencilOp
);
parcelHelpers.export(exports, "DecrementWrapStencilOp", ()=>DecrementWrapStencilOp
);
parcelHelpers.export(exports, "DefaultLoadingManager", ()=>DefaultLoadingManager
);
parcelHelpers.export(exports, "DepthFormat", ()=>DepthFormat
);
parcelHelpers.export(exports, "DepthStencilFormat", ()=>DepthStencilFormat
);
parcelHelpers.export(exports, "DepthTexture", ()=>DepthTexture
);
parcelHelpers.export(exports, "DirectionalLight", ()=>DirectionalLight
);
parcelHelpers.export(exports, "DirectionalLightHelper", ()=>DirectionalLightHelper
);
parcelHelpers.export(exports, "DirectionalLightShadow", ()=>DirectionalLightShadow
);
parcelHelpers.export(exports, "DiscreteInterpolant", ()=>DiscreteInterpolant
);
parcelHelpers.export(exports, "DodecahedronBufferGeometry", ()=>DodecahedronBufferGeometry
);
parcelHelpers.export(exports, "DodecahedronGeometry", ()=>DodecahedronGeometry
);
parcelHelpers.export(exports, "DoubleSide", ()=>DoubleSide
);
parcelHelpers.export(exports, "DstAlphaFactor", ()=>DstAlphaFactor
);
parcelHelpers.export(exports, "DstColorFactor", ()=>DstColorFactor
);
parcelHelpers.export(exports, "DynamicBufferAttribute", ()=>DynamicBufferAttribute
);
parcelHelpers.export(exports, "DynamicCopyUsage", ()=>DynamicCopyUsage
);
parcelHelpers.export(exports, "DynamicDrawUsage", ()=>DynamicDrawUsage
);
parcelHelpers.export(exports, "DynamicReadUsage", ()=>DynamicReadUsage
);
parcelHelpers.export(exports, "EdgesGeometry", ()=>EdgesGeometry
);
parcelHelpers.export(exports, "EdgesHelper", ()=>EdgesHelper
);
parcelHelpers.export(exports, "EllipseCurve", ()=>EllipseCurve
);
parcelHelpers.export(exports, "EqualDepth", ()=>EqualDepth
);
parcelHelpers.export(exports, "EqualStencilFunc", ()=>EqualStencilFunc
);
parcelHelpers.export(exports, "EquirectangularReflectionMapping", ()=>EquirectangularReflectionMapping
);
parcelHelpers.export(exports, "EquirectangularRefractionMapping", ()=>EquirectangularRefractionMapping
);
parcelHelpers.export(exports, "Euler", ()=>Euler
);
parcelHelpers.export(exports, "EventDispatcher", ()=>EventDispatcher
);
parcelHelpers.export(exports, "ExtrudeBufferGeometry", ()=>ExtrudeBufferGeometry
);
parcelHelpers.export(exports, "ExtrudeGeometry", ()=>ExtrudeGeometry
);
parcelHelpers.export(exports, "Face3", ()=>Face3
);
parcelHelpers.export(exports, "Face4", ()=>Face4
);
parcelHelpers.export(exports, "FaceColors", ()=>FaceColors
);
parcelHelpers.export(exports, "FileLoader", ()=>FileLoader
);
parcelHelpers.export(exports, "FlatShading", ()=>FlatShading
);
parcelHelpers.export(exports, "Float32Attribute", ()=>Float32Attribute
);
parcelHelpers.export(exports, "Float32BufferAttribute", ()=>Float32BufferAttribute
);
parcelHelpers.export(exports, "Float64Attribute", ()=>Float64Attribute
);
parcelHelpers.export(exports, "Float64BufferAttribute", ()=>Float64BufferAttribute
);
parcelHelpers.export(exports, "FloatType", ()=>FloatType
);
parcelHelpers.export(exports, "Fog", ()=>Fog
);
parcelHelpers.export(exports, "FogExp2", ()=>FogExp2
);
parcelHelpers.export(exports, "Font", ()=>Font
);
parcelHelpers.export(exports, "FontLoader", ()=>FontLoader
);
parcelHelpers.export(exports, "FrontFaceDirectionCCW", ()=>FrontFaceDirectionCCW
);
parcelHelpers.export(exports, "FrontFaceDirectionCW", ()=>FrontFaceDirectionCW
);
parcelHelpers.export(exports, "FrontSide", ()=>FrontSide
);
parcelHelpers.export(exports, "Frustum", ()=>Frustum
);
parcelHelpers.export(exports, "GammaEncoding", ()=>GammaEncoding
);
parcelHelpers.export(exports, "Geometry", ()=>Geometry
);
parcelHelpers.export(exports, "GeometryUtils", ()=>GeometryUtils
);
parcelHelpers.export(exports, "GreaterDepth", ()=>GreaterDepth
);
parcelHelpers.export(exports, "GreaterEqualDepth", ()=>GreaterEqualDepth
);
parcelHelpers.export(exports, "GreaterEqualStencilFunc", ()=>GreaterEqualStencilFunc
);
parcelHelpers.export(exports, "GreaterStencilFunc", ()=>GreaterStencilFunc
);
parcelHelpers.export(exports, "GridHelper", ()=>GridHelper
);
parcelHelpers.export(exports, "Group", ()=>Group
);
parcelHelpers.export(exports, "HalfFloatType", ()=>HalfFloatType
);
parcelHelpers.export(exports, "HemisphereLight", ()=>HemisphereLight
);
parcelHelpers.export(exports, "HemisphereLightHelper", ()=>HemisphereLightHelper
);
parcelHelpers.export(exports, "HemisphereLightProbe", ()=>HemisphereLightProbe
);
parcelHelpers.export(exports, "IcosahedronBufferGeometry", ()=>IcosahedronBufferGeometry
);
parcelHelpers.export(exports, "IcosahedronGeometry", ()=>IcosahedronGeometry
);
parcelHelpers.export(exports, "ImageBitmapLoader", ()=>ImageBitmapLoader
);
parcelHelpers.export(exports, "ImageLoader", ()=>ImageLoader
);
parcelHelpers.export(exports, "ImageUtils", ()=>ImageUtils
);
parcelHelpers.export(exports, "ImmediateRenderObject", ()=>ImmediateRenderObject
);
parcelHelpers.export(exports, "IncrementStencilOp", ()=>IncrementStencilOp
);
parcelHelpers.export(exports, "IncrementWrapStencilOp", ()=>IncrementWrapStencilOp
);
parcelHelpers.export(exports, "InstancedBufferAttribute", ()=>InstancedBufferAttribute
);
parcelHelpers.export(exports, "InstancedBufferGeometry", ()=>InstancedBufferGeometry
);
parcelHelpers.export(exports, "InstancedInterleavedBuffer", ()=>InstancedInterleavedBuffer
);
parcelHelpers.export(exports, "InstancedMesh", ()=>InstancedMesh
);
parcelHelpers.export(exports, "Int16Attribute", ()=>Int16Attribute
);
parcelHelpers.export(exports, "Int16BufferAttribute", ()=>Int16BufferAttribute
);
parcelHelpers.export(exports, "Int32Attribute", ()=>Int32Attribute
);
parcelHelpers.export(exports, "Int32BufferAttribute", ()=>Int32BufferAttribute
);
parcelHelpers.export(exports, "Int8Attribute", ()=>Int8Attribute
);
parcelHelpers.export(exports, "Int8BufferAttribute", ()=>Int8BufferAttribute
);
parcelHelpers.export(exports, "IntType", ()=>IntType
);
parcelHelpers.export(exports, "InterleavedBuffer", ()=>InterleavedBuffer
);
parcelHelpers.export(exports, "InterleavedBufferAttribute", ()=>InterleavedBufferAttribute
);
parcelHelpers.export(exports, "Interpolant", ()=>Interpolant
);
parcelHelpers.export(exports, "InterpolateDiscrete", ()=>InterpolateDiscrete
);
parcelHelpers.export(exports, "InterpolateLinear", ()=>InterpolateLinear
);
parcelHelpers.export(exports, "InterpolateSmooth", ()=>InterpolateSmooth
);
parcelHelpers.export(exports, "InvertStencilOp", ()=>InvertStencilOp
);
parcelHelpers.export(exports, "JSONLoader", ()=>JSONLoader
);
parcelHelpers.export(exports, "KeepStencilOp", ()=>KeepStencilOp
);
parcelHelpers.export(exports, "KeyframeTrack", ()=>KeyframeTrack
);
parcelHelpers.export(exports, "LOD", ()=>LOD
);
parcelHelpers.export(exports, "LatheBufferGeometry", ()=>LatheBufferGeometry
);
parcelHelpers.export(exports, "LatheGeometry", ()=>LatheGeometry
);
parcelHelpers.export(exports, "Layers", ()=>Layers
);
parcelHelpers.export(exports, "LensFlare", ()=>LensFlare
);
parcelHelpers.export(exports, "LessDepth", ()=>LessDepth
);
parcelHelpers.export(exports, "LessEqualDepth", ()=>LessEqualDepth
);
parcelHelpers.export(exports, "LessEqualStencilFunc", ()=>LessEqualStencilFunc
);
parcelHelpers.export(exports, "LessStencilFunc", ()=>LessStencilFunc
);
parcelHelpers.export(exports, "Light", ()=>Light
);
parcelHelpers.export(exports, "LightProbe", ()=>LightProbe
);
parcelHelpers.export(exports, "LightShadow", ()=>LightShadow
);
parcelHelpers.export(exports, "Line", ()=>Line
);
parcelHelpers.export(exports, "Line3", ()=>Line3
);
parcelHelpers.export(exports, "LineBasicMaterial", ()=>LineBasicMaterial
);
parcelHelpers.export(exports, "LineCurve", ()=>LineCurve
);
parcelHelpers.export(exports, "LineCurve3", ()=>LineCurve3
);
parcelHelpers.export(exports, "LineDashedMaterial", ()=>LineDashedMaterial
);
parcelHelpers.export(exports, "LineLoop", ()=>LineLoop
);
parcelHelpers.export(exports, "LinePieces", ()=>LinePieces
);
parcelHelpers.export(exports, "LineSegments", ()=>LineSegments
);
parcelHelpers.export(exports, "LineStrip", ()=>LineStrip
);
parcelHelpers.export(exports, "LinearEncoding", ()=>LinearEncoding
);
parcelHelpers.export(exports, "LinearFilter", ()=>LinearFilter
);
parcelHelpers.export(exports, "LinearInterpolant", ()=>LinearInterpolant
);
parcelHelpers.export(exports, "LinearMipMapLinearFilter", ()=>LinearMipMapLinearFilter
);
parcelHelpers.export(exports, "LinearMipMapNearestFilter", ()=>LinearMipMapNearestFilter
);
parcelHelpers.export(exports, "LinearMipmapLinearFilter", ()=>LinearMipmapLinearFilter
);
parcelHelpers.export(exports, "LinearMipmapNearestFilter", ()=>LinearMipmapNearestFilter
);
parcelHelpers.export(exports, "LinearToneMapping", ()=>LinearToneMapping
);
parcelHelpers.export(exports, "Loader", ()=>Loader
);
parcelHelpers.export(exports, "LoaderUtils", ()=>LoaderUtils
);
parcelHelpers.export(exports, "LoadingManager", ()=>LoadingManager
);
parcelHelpers.export(exports, "LogLuvEncoding", ()=>LogLuvEncoding
);
parcelHelpers.export(exports, "LoopOnce", ()=>LoopOnce
);
parcelHelpers.export(exports, "LoopPingPong", ()=>LoopPingPong
);
parcelHelpers.export(exports, "LoopRepeat", ()=>LoopRepeat
);
parcelHelpers.export(exports, "LuminanceAlphaFormat", ()=>LuminanceAlphaFormat
);
parcelHelpers.export(exports, "LuminanceFormat", ()=>LuminanceFormat
);
parcelHelpers.export(exports, "MOUSE", ()=>MOUSE
);
parcelHelpers.export(exports, "Material", ()=>Material
);
parcelHelpers.export(exports, "MaterialLoader", ()=>MaterialLoader
);
parcelHelpers.export(exports, "Math", ()=>MathUtils
);
parcelHelpers.export(exports, "MathUtils", ()=>MathUtils
);
parcelHelpers.export(exports, "Matrix3", ()=>Matrix3
);
parcelHelpers.export(exports, "Matrix4", ()=>Matrix4
);
parcelHelpers.export(exports, "MaxEquation", ()=>MaxEquation
);
parcelHelpers.export(exports, "Mesh", ()=>Mesh
);
parcelHelpers.export(exports, "MeshBasicMaterial", ()=>MeshBasicMaterial
);
parcelHelpers.export(exports, "MeshDepthMaterial", ()=>MeshDepthMaterial
);
parcelHelpers.export(exports, "MeshDistanceMaterial", ()=>MeshDistanceMaterial
);
parcelHelpers.export(exports, "MeshFaceMaterial", ()=>MeshFaceMaterial
);
parcelHelpers.export(exports, "MeshLambertMaterial", ()=>MeshLambertMaterial
);
parcelHelpers.export(exports, "MeshMatcapMaterial", ()=>MeshMatcapMaterial
);
parcelHelpers.export(exports, "MeshNormalMaterial", ()=>MeshNormalMaterial
);
parcelHelpers.export(exports, "MeshPhongMaterial", ()=>MeshPhongMaterial
);
parcelHelpers.export(exports, "MeshPhysicalMaterial", ()=>MeshPhysicalMaterial
);
parcelHelpers.export(exports, "MeshStandardMaterial", ()=>MeshStandardMaterial
);
parcelHelpers.export(exports, "MeshToonMaterial", ()=>MeshToonMaterial
);
parcelHelpers.export(exports, "MinEquation", ()=>MinEquation
);
parcelHelpers.export(exports, "MirroredRepeatWrapping", ()=>MirroredRepeatWrapping
);
parcelHelpers.export(exports, "MixOperation", ()=>MixOperation
);
parcelHelpers.export(exports, "MultiMaterial", ()=>MultiMaterial
);
parcelHelpers.export(exports, "MultiplyBlending", ()=>MultiplyBlending
);
parcelHelpers.export(exports, "MultiplyOperation", ()=>MultiplyOperation
);
parcelHelpers.export(exports, "NearestFilter", ()=>NearestFilter
);
parcelHelpers.export(exports, "NearestMipMapLinearFilter", ()=>NearestMipMapLinearFilter
);
parcelHelpers.export(exports, "NearestMipMapNearestFilter", ()=>NearestMipMapNearestFilter
);
parcelHelpers.export(exports, "NearestMipmapLinearFilter", ()=>NearestMipmapLinearFilter
);
parcelHelpers.export(exports, "NearestMipmapNearestFilter", ()=>NearestMipmapNearestFilter
);
parcelHelpers.export(exports, "NeverDepth", ()=>NeverDepth
);
parcelHelpers.export(exports, "NeverStencilFunc", ()=>NeverStencilFunc
);
parcelHelpers.export(exports, "NoBlending", ()=>NoBlending
);
parcelHelpers.export(exports, "NoColors", ()=>NoColors
);
parcelHelpers.export(exports, "NoToneMapping", ()=>NoToneMapping
);
parcelHelpers.export(exports, "NormalAnimationBlendMode", ()=>NormalAnimationBlendMode
);
parcelHelpers.export(exports, "NormalBlending", ()=>NormalBlending
);
parcelHelpers.export(exports, "NotEqualDepth", ()=>NotEqualDepth
);
parcelHelpers.export(exports, "NotEqualStencilFunc", ()=>NotEqualStencilFunc
);
parcelHelpers.export(exports, "NumberKeyframeTrack", ()=>NumberKeyframeTrack
);
parcelHelpers.export(exports, "Object3D", ()=>Object3D
);
parcelHelpers.export(exports, "ObjectLoader", ()=>ObjectLoader
);
parcelHelpers.export(exports, "ObjectSpaceNormalMap", ()=>ObjectSpaceNormalMap
);
parcelHelpers.export(exports, "OctahedronBufferGeometry", ()=>OctahedronBufferGeometry
);
parcelHelpers.export(exports, "OctahedronGeometry", ()=>OctahedronGeometry
);
parcelHelpers.export(exports, "OneFactor", ()=>OneFactor
);
parcelHelpers.export(exports, "OneMinusDstAlphaFactor", ()=>OneMinusDstAlphaFactor
);
parcelHelpers.export(exports, "OneMinusDstColorFactor", ()=>OneMinusDstColorFactor
);
parcelHelpers.export(exports, "OneMinusSrcAlphaFactor", ()=>OneMinusSrcAlphaFactor
);
parcelHelpers.export(exports, "OneMinusSrcColorFactor", ()=>OneMinusSrcColorFactor
);
parcelHelpers.export(exports, "OrthographicCamera", ()=>OrthographicCamera
);
parcelHelpers.export(exports, "PCFShadowMap", ()=>PCFShadowMap
);
parcelHelpers.export(exports, "PCFSoftShadowMap", ()=>PCFSoftShadowMap
);
parcelHelpers.export(exports, "PMREMGenerator", ()=>PMREMGenerator
);
parcelHelpers.export(exports, "ParametricBufferGeometry", ()=>ParametricBufferGeometry
);
parcelHelpers.export(exports, "ParametricGeometry", ()=>ParametricGeometry
);
parcelHelpers.export(exports, "Particle", ()=>Particle
);
parcelHelpers.export(exports, "ParticleBasicMaterial", ()=>ParticleBasicMaterial
);
parcelHelpers.export(exports, "ParticleSystem", ()=>ParticleSystem
);
parcelHelpers.export(exports, "ParticleSystemMaterial", ()=>ParticleSystemMaterial
);
parcelHelpers.export(exports, "Path", ()=>Path
);
parcelHelpers.export(exports, "PerspectiveCamera", ()=>PerspectiveCamera
);
parcelHelpers.export(exports, "Plane", ()=>Plane
);
parcelHelpers.export(exports, "PlaneBufferGeometry", ()=>PlaneBufferGeometry
);
parcelHelpers.export(exports, "PlaneGeometry", ()=>PlaneGeometry
);
parcelHelpers.export(exports, "PlaneHelper", ()=>PlaneHelper
);
parcelHelpers.export(exports, "PointCloud", ()=>PointCloud
);
parcelHelpers.export(exports, "PointCloudMaterial", ()=>PointCloudMaterial
);
parcelHelpers.export(exports, "PointLight", ()=>PointLight
);
parcelHelpers.export(exports, "PointLightHelper", ()=>PointLightHelper
);
parcelHelpers.export(exports, "Points", ()=>Points
);
parcelHelpers.export(exports, "PointsMaterial", ()=>PointsMaterial
);
parcelHelpers.export(exports, "PolarGridHelper", ()=>PolarGridHelper
);
parcelHelpers.export(exports, "PolyhedronBufferGeometry", ()=>PolyhedronBufferGeometry
);
parcelHelpers.export(exports, "PolyhedronGeometry", ()=>PolyhedronGeometry
);
parcelHelpers.export(exports, "PositionalAudio", ()=>PositionalAudio
);
parcelHelpers.export(exports, "PropertyBinding", ()=>PropertyBinding
);
parcelHelpers.export(exports, "PropertyMixer", ()=>PropertyMixer
);
parcelHelpers.export(exports, "QuadraticBezierCurve", ()=>QuadraticBezierCurve
);
parcelHelpers.export(exports, "QuadraticBezierCurve3", ()=>QuadraticBezierCurve3
);
parcelHelpers.export(exports, "Quaternion", ()=>Quaternion
);
parcelHelpers.export(exports, "QuaternionKeyframeTrack", ()=>QuaternionKeyframeTrack
);
parcelHelpers.export(exports, "QuaternionLinearInterpolant", ()=>QuaternionLinearInterpolant
);
parcelHelpers.export(exports, "REVISION", ()=>REVISION
);
parcelHelpers.export(exports, "RGBADepthPacking", ()=>RGBADepthPacking
);
parcelHelpers.export(exports, "RGBAFormat", ()=>RGBAFormat
);
parcelHelpers.export(exports, "RGBAIntegerFormat", ()=>RGBAIntegerFormat
);
parcelHelpers.export(exports, "RGBA_ASTC_10x10_Format", ()=>RGBA_ASTC_10x10_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_10x5_Format", ()=>RGBA_ASTC_10x5_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_10x6_Format", ()=>RGBA_ASTC_10x6_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_10x8_Format", ()=>RGBA_ASTC_10x8_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_12x10_Format", ()=>RGBA_ASTC_12x10_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_12x12_Format", ()=>RGBA_ASTC_12x12_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_4x4_Format", ()=>RGBA_ASTC_4x4_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_5x4_Format", ()=>RGBA_ASTC_5x4_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_5x5_Format", ()=>RGBA_ASTC_5x5_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_6x5_Format", ()=>RGBA_ASTC_6x5_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_6x6_Format", ()=>RGBA_ASTC_6x6_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_8x5_Format", ()=>RGBA_ASTC_8x5_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_8x6_Format", ()=>RGBA_ASTC_8x6_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_8x8_Format", ()=>RGBA_ASTC_8x8_Format
);
parcelHelpers.export(exports, "RGBA_BPTC_Format", ()=>RGBA_BPTC_Format
);
parcelHelpers.export(exports, "RGBA_ETC2_EAC_Format", ()=>RGBA_ETC2_EAC_Format
);
parcelHelpers.export(exports, "RGBA_PVRTC_2BPPV1_Format", ()=>RGBA_PVRTC_2BPPV1_Format
);
parcelHelpers.export(exports, "RGBA_PVRTC_4BPPV1_Format", ()=>RGBA_PVRTC_4BPPV1_Format
);
parcelHelpers.export(exports, "RGBA_S3TC_DXT1_Format", ()=>RGBA_S3TC_DXT1_Format
);
parcelHelpers.export(exports, "RGBA_S3TC_DXT3_Format", ()=>RGBA_S3TC_DXT3_Format
);
parcelHelpers.export(exports, "RGBA_S3TC_DXT5_Format", ()=>RGBA_S3TC_DXT5_Format
);
parcelHelpers.export(exports, "RGBDEncoding", ()=>RGBDEncoding
);
parcelHelpers.export(exports, "RGBEEncoding", ()=>RGBEEncoding
);
parcelHelpers.export(exports, "RGBEFormat", ()=>RGBEFormat
);
parcelHelpers.export(exports, "RGBFormat", ()=>RGBFormat
);
parcelHelpers.export(exports, "RGBIntegerFormat", ()=>RGBIntegerFormat
);
parcelHelpers.export(exports, "RGBM16Encoding", ()=>RGBM16Encoding
);
parcelHelpers.export(exports, "RGBM7Encoding", ()=>RGBM7Encoding
);
parcelHelpers.export(exports, "RGB_ETC1_Format", ()=>RGB_ETC1_Format
);
parcelHelpers.export(exports, "RGB_ETC2_Format", ()=>RGB_ETC2_Format
);
parcelHelpers.export(exports, "RGB_PVRTC_2BPPV1_Format", ()=>RGB_PVRTC_2BPPV1_Format
);
parcelHelpers.export(exports, "RGB_PVRTC_4BPPV1_Format", ()=>RGB_PVRTC_4BPPV1_Format
);
parcelHelpers.export(exports, "RGB_S3TC_DXT1_Format", ()=>RGB_S3TC_DXT1_Format
);
parcelHelpers.export(exports, "RGFormat", ()=>RGFormat
);
parcelHelpers.export(exports, "RGIntegerFormat", ()=>RGIntegerFormat
);
parcelHelpers.export(exports, "RawShaderMaterial", ()=>RawShaderMaterial
);
parcelHelpers.export(exports, "Ray", ()=>Ray
);
parcelHelpers.export(exports, "Raycaster", ()=>Raycaster
);
parcelHelpers.export(exports, "RectAreaLight", ()=>RectAreaLight
);
parcelHelpers.export(exports, "RedFormat", ()=>RedFormat
);
parcelHelpers.export(exports, "RedIntegerFormat", ()=>RedIntegerFormat
);
parcelHelpers.export(exports, "ReinhardToneMapping", ()=>ReinhardToneMapping
);
parcelHelpers.export(exports, "RepeatWrapping", ()=>RepeatWrapping
);
parcelHelpers.export(exports, "ReplaceStencilOp", ()=>ReplaceStencilOp
);
parcelHelpers.export(exports, "ReverseSubtractEquation", ()=>ReverseSubtractEquation
);
parcelHelpers.export(exports, "RingBufferGeometry", ()=>RingBufferGeometry
);
parcelHelpers.export(exports, "RingGeometry", ()=>RingGeometry
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_10x10_Format", ()=>SRGB8_ALPHA8_ASTC_10x10_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_10x5_Format", ()=>SRGB8_ALPHA8_ASTC_10x5_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_10x6_Format", ()=>SRGB8_ALPHA8_ASTC_10x6_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_10x8_Format", ()=>SRGB8_ALPHA8_ASTC_10x8_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_12x10_Format", ()=>SRGB8_ALPHA8_ASTC_12x10_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_12x12_Format", ()=>SRGB8_ALPHA8_ASTC_12x12_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_4x4_Format", ()=>SRGB8_ALPHA8_ASTC_4x4_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_5x4_Format", ()=>SRGB8_ALPHA8_ASTC_5x4_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_5x5_Format", ()=>SRGB8_ALPHA8_ASTC_5x5_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_6x5_Format", ()=>SRGB8_ALPHA8_ASTC_6x5_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_6x6_Format", ()=>SRGB8_ALPHA8_ASTC_6x6_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_8x5_Format", ()=>SRGB8_ALPHA8_ASTC_8x5_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_8x6_Format", ()=>SRGB8_ALPHA8_ASTC_8x6_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_8x8_Format", ()=>SRGB8_ALPHA8_ASTC_8x8_Format
);
parcelHelpers.export(exports, "Scene", ()=>Scene
);
parcelHelpers.export(exports, "SceneUtils", ()=>SceneUtils
);
parcelHelpers.export(exports, "ShaderChunk", ()=>ShaderChunk
);
parcelHelpers.export(exports, "ShaderLib", ()=>ShaderLib
);
parcelHelpers.export(exports, "ShaderMaterial", ()=>ShaderMaterial
);
parcelHelpers.export(exports, "ShadowMaterial", ()=>ShadowMaterial
);
parcelHelpers.export(exports, "Shape", ()=>Shape
);
parcelHelpers.export(exports, "ShapeBufferGeometry", ()=>ShapeBufferGeometry
);
parcelHelpers.export(exports, "ShapeGeometry", ()=>ShapeGeometry
);
parcelHelpers.export(exports, "ShapePath", ()=>ShapePath
);
parcelHelpers.export(exports, "ShapeUtils", ()=>ShapeUtils
);
parcelHelpers.export(exports, "ShortType", ()=>ShortType
);
parcelHelpers.export(exports, "Skeleton", ()=>Skeleton
);
parcelHelpers.export(exports, "SkeletonHelper", ()=>SkeletonHelper
);
parcelHelpers.export(exports, "SkinnedMesh", ()=>SkinnedMesh
);
parcelHelpers.export(exports, "SmoothShading", ()=>SmoothShading
);
parcelHelpers.export(exports, "Sphere", ()=>Sphere
);
parcelHelpers.export(exports, "SphereBufferGeometry", ()=>SphereBufferGeometry
);
parcelHelpers.export(exports, "SphereGeometry", ()=>SphereGeometry
);
parcelHelpers.export(exports, "Spherical", ()=>Spherical
);
parcelHelpers.export(exports, "SphericalHarmonics3", ()=>SphericalHarmonics3
);
parcelHelpers.export(exports, "Spline", ()=>Spline
);
parcelHelpers.export(exports, "SplineCurve", ()=>SplineCurve
);
parcelHelpers.export(exports, "SplineCurve3", ()=>SplineCurve3
);
parcelHelpers.export(exports, "SpotLight", ()=>SpotLight
);
parcelHelpers.export(exports, "SpotLightHelper", ()=>SpotLightHelper
);
parcelHelpers.export(exports, "SpotLightShadow", ()=>SpotLightShadow
);
parcelHelpers.export(exports, "Sprite", ()=>Sprite
);
parcelHelpers.export(exports, "SpriteMaterial", ()=>SpriteMaterial
);
parcelHelpers.export(exports, "SrcAlphaFactor", ()=>SrcAlphaFactor
);
parcelHelpers.export(exports, "SrcAlphaSaturateFactor", ()=>SrcAlphaSaturateFactor
);
parcelHelpers.export(exports, "SrcColorFactor", ()=>SrcColorFactor
);
parcelHelpers.export(exports, "StaticCopyUsage", ()=>StaticCopyUsage
);
parcelHelpers.export(exports, "StaticDrawUsage", ()=>StaticDrawUsage
);
parcelHelpers.export(exports, "StaticReadUsage", ()=>StaticReadUsage
);
parcelHelpers.export(exports, "StereoCamera", ()=>StereoCamera
);
parcelHelpers.export(exports, "StreamCopyUsage", ()=>StreamCopyUsage
);
parcelHelpers.export(exports, "StreamDrawUsage", ()=>StreamDrawUsage
);
parcelHelpers.export(exports, "StreamReadUsage", ()=>StreamReadUsage
);
parcelHelpers.export(exports, "StringKeyframeTrack", ()=>StringKeyframeTrack
);
parcelHelpers.export(exports, "SubtractEquation", ()=>SubtractEquation
);
parcelHelpers.export(exports, "SubtractiveBlending", ()=>SubtractiveBlending
);
parcelHelpers.export(exports, "TOUCH", ()=>TOUCH
);
parcelHelpers.export(exports, "TangentSpaceNormalMap", ()=>TangentSpaceNormalMap
);
parcelHelpers.export(exports, "TetrahedronBufferGeometry", ()=>TetrahedronBufferGeometry
);
parcelHelpers.export(exports, "TetrahedronGeometry", ()=>TetrahedronGeometry
);
parcelHelpers.export(exports, "TextBufferGeometry", ()=>TextBufferGeometry
);
parcelHelpers.export(exports, "TextGeometry", ()=>TextGeometry
);
parcelHelpers.export(exports, "Texture", ()=>Texture
);
parcelHelpers.export(exports, "TextureLoader", ()=>TextureLoader
);
parcelHelpers.export(exports, "TorusBufferGeometry", ()=>TorusBufferGeometry
);
parcelHelpers.export(exports, "TorusGeometry", ()=>TorusGeometry
);
parcelHelpers.export(exports, "TorusKnotBufferGeometry", ()=>TorusKnotBufferGeometry
);
parcelHelpers.export(exports, "TorusKnotGeometry", ()=>TorusKnotGeometry
);
parcelHelpers.export(exports, "Triangle", ()=>Triangle
);
parcelHelpers.export(exports, "TriangleFanDrawMode", ()=>TriangleFanDrawMode
);
parcelHelpers.export(exports, "TriangleStripDrawMode", ()=>TriangleStripDrawMode
);
parcelHelpers.export(exports, "TrianglesDrawMode", ()=>TrianglesDrawMode
);
parcelHelpers.export(exports, "TubeBufferGeometry", ()=>TubeBufferGeometry
);
parcelHelpers.export(exports, "TubeGeometry", ()=>TubeGeometry
);
parcelHelpers.export(exports, "UVMapping", ()=>UVMapping
);
parcelHelpers.export(exports, "Uint16Attribute", ()=>Uint16Attribute
);
parcelHelpers.export(exports, "Uint16BufferAttribute", ()=>Uint16BufferAttribute
);
parcelHelpers.export(exports, "Uint32Attribute", ()=>Uint32Attribute
);
parcelHelpers.export(exports, "Uint32BufferAttribute", ()=>Uint32BufferAttribute
);
parcelHelpers.export(exports, "Uint8Attribute", ()=>Uint8Attribute
);
parcelHelpers.export(exports, "Uint8BufferAttribute", ()=>Uint8BufferAttribute
);
parcelHelpers.export(exports, "Uint8ClampedAttribute", ()=>Uint8ClampedAttribute
);
parcelHelpers.export(exports, "Uint8ClampedBufferAttribute", ()=>Uint8ClampedBufferAttribute
);
parcelHelpers.export(exports, "Uniform", ()=>Uniform
);
parcelHelpers.export(exports, "UniformsLib", ()=>UniformsLib
);
parcelHelpers.export(exports, "UniformsUtils", ()=>UniformsUtils
);
parcelHelpers.export(exports, "UnsignedByteType", ()=>UnsignedByteType
);
parcelHelpers.export(exports, "UnsignedInt248Type", ()=>UnsignedInt248Type
);
parcelHelpers.export(exports, "UnsignedIntType", ()=>UnsignedIntType
);
parcelHelpers.export(exports, "UnsignedShort4444Type", ()=>UnsignedShort4444Type
);
parcelHelpers.export(exports, "UnsignedShort5551Type", ()=>UnsignedShort5551Type
);
parcelHelpers.export(exports, "UnsignedShort565Type", ()=>UnsignedShort565Type
);
parcelHelpers.export(exports, "UnsignedShortType", ()=>UnsignedShortType
);
parcelHelpers.export(exports, "VSMShadowMap", ()=>VSMShadowMap
);
parcelHelpers.export(exports, "Vector2", ()=>Vector2
);
parcelHelpers.export(exports, "Vector3", ()=>Vector3
);
parcelHelpers.export(exports, "Vector4", ()=>Vector4
);
parcelHelpers.export(exports, "VectorKeyframeTrack", ()=>VectorKeyframeTrack
);
parcelHelpers.export(exports, "Vertex", ()=>Vertex
);
parcelHelpers.export(exports, "VertexColors", ()=>VertexColors
);
parcelHelpers.export(exports, "VideoTexture", ()=>VideoTexture
);
parcelHelpers.export(exports, "WebGL1Renderer", ()=>WebGL1Renderer
);
parcelHelpers.export(exports, "WebGLCubeRenderTarget", ()=>WebGLCubeRenderTarget
);
parcelHelpers.export(exports, "WebGLMultisampleRenderTarget", ()=>WebGLMultisampleRenderTarget
);
parcelHelpers.export(exports, "WebGLRenderTarget", ()=>WebGLRenderTarget
);
parcelHelpers.export(exports, "WebGLRenderTargetCube", ()=>WebGLRenderTargetCube
);
parcelHelpers.export(exports, "WebGLRenderer", ()=>WebGLRenderer
);
parcelHelpers.export(exports, "WebGLUtils", ()=>WebGLUtils
);
parcelHelpers.export(exports, "WireframeGeometry", ()=>WireframeGeometry
);
parcelHelpers.export(exports, "WireframeHelper", ()=>WireframeHelper
);
parcelHelpers.export(exports, "WrapAroundEnding", ()=>WrapAroundEnding
);
parcelHelpers.export(exports, "XHRLoader", ()=>XHRLoader
);
parcelHelpers.export(exports, "ZeroCurvatureEnding", ()=>ZeroCurvatureEnding
);
parcelHelpers.export(exports, "ZeroFactor", ()=>ZeroFactor
);
parcelHelpers.export(exports, "ZeroSlopeEnding", ()=>ZeroSlopeEnding
);
parcelHelpers.export(exports, "ZeroStencilOp", ()=>ZeroStencilOp
);
parcelHelpers.export(exports, "sRGBEncoding", ()=>sRGBEncoding
);
// Polyfills
if (Number.EPSILON === undefined) Number.EPSILON = Math.pow(2, -52);
if (Number.isInteger === undefined) // Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
Number.isInteger = function(value) {
    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
};
//
if (Math.sign === undefined) // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
Math.sign = function(x) {
    return x < 0 ? -1 : x > 0 ? 1 : +x;
};
if ('name' in Function.prototype === false) // Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
Object.defineProperty(Function.prototype, 'name', {
    get: function() {
        return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    }
});
if (Object.assign === undefined) // Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
Object.assign = function(target) {
    if (target === undefined || target === null) throw new TypeError('Cannot convert undefined or null to object');
    const output = Object(target);
    for(let index = 1; index < arguments.length; index++){
        const source = arguments[index];
        if (source !== undefined && source !== null) {
            for(const nextKey in source)if (Object.prototype.hasOwnProperty.call(source, nextKey)) output[nextKey] = source[nextKey];
        }
    }
    return output;
};
const REVISION = '118';
const MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
};
const TOUCH = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
};
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const FrontFaceDirectionCW = 0;
const FrontFaceDirectionCCW = 1;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const SmoothShading = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const CubeUVRefractionMapping = 307;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedShort565Type = 1019;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const RGBEFormat = RGBAFormat;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const GammaEncoding = 3007;
const RGBEEncoding = 3002;
const LogLuvEncoding = 3003;
const RGBM7Encoding = 3004;
const RGBM16Encoding = 3005;
const RGBDEncoding = 3006;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;
const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;
const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */ function EventDispatcher() {}
Object.assign(EventDispatcher.prototype, {
    addEventListener: function(type, listener) {
        if (this._listeners === undefined) this._listeners = {};
        const listeners = this._listeners;
        if (listeners[type] === undefined) listeners[type] = [];
        if (listeners[type].indexOf(listener) === -1) listeners[type].push(listener);
    },
    hasEventListener: function(type, listener) {
        if (this._listeners === undefined) return false;
        const listeners = this._listeners;
        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
    },
    removeEventListener: function(type, listener) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== undefined) {
            const index = listenerArray.indexOf(listener);
            if (index !== -1) listenerArray.splice(index, 1);
        }
    },
    dispatchEvent: function(event) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            // Make a copy, in case listeners are removed while iterating.
            const array = listenerArray.slice(0);
            for(let i1 = 0, l = array.length; i1 < l; i1++)array[i1].call(this, event);
        }
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author thezwap
 */ const _lut = [];
for(let i = 0; i < 256; i++)_lut[i] = (i < 16 ? '0' : '') + i.toString(16);
const MathUtils = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
        const d0 = Math.random() * 4294967295 | 0;
        const d1 = Math.random() * 4294967295 | 0;
        const d2 = Math.random() * 4294967295 | 0;
        const d3 = Math.random() * 4294967295 | 0;
        const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + '-' + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + '-' + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + '-' + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + '-' + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
        // .toUpperCase() here flattens concatenated strings to save heap memory space.
        return uuid.toUpperCase();
    },
    clamp: function(value, min, max) {
        return Math.max(min, Math.min(max, value));
    },
    // compute euclidian modulo of m % n
    // https://en.wikipedia.org/wiki/Modulo_operation
    euclideanModulo: function(n, m) {
        return (n % m + m) % m;
    },
    // Linear mapping from range <a1, a2> to range <b1, b2>
    mapLinear: function(x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
    },
    // https://en.wikipedia.org/wiki/Linear_interpolation
    lerp: function(x, y, t) {
        return (1 - t) * x + t * y;
    },
    // http://en.wikipedia.org/wiki/Smoothstep
    smoothstep: function(x, min, max) {
        if (x <= min) return 0;
        if (x >= max) return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
    },
    smootherstep: function(x, min, max) {
        if (x <= min) return 0;
        if (x >= max) return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
    },
    // Random integer from <low, high> interval
    randInt: function(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
    },
    // Random float from <low, high> interval
    randFloat: function(low, high) {
        return low + Math.random() * (high - low);
    },
    // Random float from <-range/2, range/2> interval
    randFloatSpread: function(range) {
        return range * (0.5 - Math.random());
    },
    degToRad: function(degrees) {
        return degrees * MathUtils.DEG2RAD;
    },
    radToDeg: function(radians) {
        return radians * MathUtils.RAD2DEG;
    },
    isPowerOfTwo: function(value) {
        return (value & value - 1) === 0 && value !== 0;
    },
    ceilPowerOfTwo: function(value) {
        return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
    },
    floorPowerOfTwo: function(value) {
        return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
    },
    setQuaternionFromProperEuler: function(q, a, b, c, order) {
        // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
        // rotations are applied to the axes in the order specified by 'order'
        // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
        // angles are in radians
        const cos = Math.cos;
        const sin = Math.sin;
        const c2 = cos(b / 2);
        const s2 = sin(b / 2);
        const c13 = cos((a + c) / 2);
        const s13 = sin((a + c) / 2);
        const c1_3 = cos((a - c) / 2);
        const s1_3 = sin((a - c) / 2);
        const c3_1 = cos((c - a) / 2);
        const s3_1 = sin((c - a) / 2);
        switch(order){
            case 'XYX':
                q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
                break;
            case 'YZY':
                q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
                break;
            case 'ZXZ':
                q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
                break;
            case 'XZX':
                q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
                break;
            case 'YXY':
                q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
                break;
            case 'ZYZ':
                q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
                break;
            default:
                console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
        }
    }
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */ function Vector2(x = 0, y = 0) {
    this.x = x;
    this.y = y;
}
Object.defineProperties(Vector2.prototype, {
    "width": {
        get: function() {
            return this.x;
        },
        set: function(value) {
            this.x = value;
        }
    },
    "height": {
        get: function() {
            return this.y;
        },
        set: function(value) {
            this.y = value;
        }
    }
});
Object.assign(Vector2.prototype, {
    isVector2: true,
    set: function(x, y) {
        this.x = x;
        this.y = y;
        return this;
    },
    setScalar: function(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
    },
    setX: function(x) {
        this.x = x;
        return this;
    },
    setY: function(y) {
        this.y = y;
        return this;
    },
    setComponent: function(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    },
    getComponent: function(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error('index is out of range: ' + index);
        }
    },
    clone: function() {
        return new this.constructor(this.x, this.y);
    },
    copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    },
    add: function(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
    },
    addScalar: function(s) {
        this.x += s;
        this.y += s;
        return this;
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    },
    addScaledVector: function(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    },
    sub: function(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
    },
    subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        return this;
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
    },
    multiply: function(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    },
    multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
    },
    divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
    },
    divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
    },
    applyMatrix3: function(m) {
        const x = this.x, y = this.y;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6];
        this.y = e[1] * x + e[4] * y + e[7];
        return this;
    },
    min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
    },
    max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
    },
    clamp: function(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
    },
    clampScalar: function(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
    },
    clampLength: function(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    },
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    },
    roundToZero: function() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
    },
    negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    },
    dot: function(v) {
        return this.x * v.x + this.y * v.y;
    },
    cross: function(v) {
        return this.x * v.y - this.y * v.x;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y);
    },
    normalize: function() {
        return this.divideScalar(this.length() || 1);
    },
    angle: function() {
        // computes the angle in radians with respect to the positive x-axis
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
    },
    distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function(v) {
        const dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
    },
    manhattanDistanceTo: function(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    },
    setLength: function(length) {
        return this.normalize().multiplyScalar(length);
    },
    lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
    },
    lerpVectors: function(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
    },
    equals: function(v) {
        return v.x === this.x && v.y === this.y;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
    },
    fromBufferAttribute: function(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
    },
    rotateAround: function(center, angle) {
        const c = Math.cos(angle), s = Math.sin(angle);
        const x = this.x - center.x;
        const y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
    },
    random: function() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */ function Matrix3() {
    this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
    ];
    if (arguments.length > 0) console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
}
Object.assign(Matrix3.prototype, {
    isMatrix3: true,
    set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        const te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
    },
    identity: function() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
    },
    clone: function() {
        return new this.constructor().fromArray(this.elements);
    },
    copy: function(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
    },
    extractBasis: function(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
    },
    setFromMatrix4: function(m) {
        const me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
    },
    multiply: function(m) {
        return this.multiplyMatrices(this, m);
    },
    premultiply: function(m) {
        return this.multiplyMatrices(m, this);
    },
    multiplyMatrices: function(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[3], a13 = ae[6];
        const a21 = ae[1], a22 = ae[4], a23 = ae[7];
        const a31 = ae[2], a32 = ae[5], a33 = ae[8];
        const b11 = be[0], b12 = be[3], b13 = be[6];
        const b21 = be[1], b22 = be[4], b23 = be[7];
        const b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
    },
    multiplyScalar: function(s) {
        const te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
    },
    determinant: function() {
        const te = this.elements;
        const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];
        return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;
    },
    getInverse: function(matrix, throwOnDegenerate) {
        if (throwOnDegenerate !== undefined) console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
        const me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
    },
    transpose: function() {
        let tmp1;
        const m = this.elements;
        tmp1 = m[1];
        m[1] = m[3];
        m[3] = tmp1;
        tmp1 = m[2];
        m[2] = m[6];
        m[6] = tmp1;
        tmp1 = m[5];
        m[5] = m[7];
        m[7] = tmp1;
        return this;
    },
    getNormalMatrix: function(matrix4) {
        return this.setFromMatrix4(matrix4).getInverse(this).transpose();
    },
    transposeIntoArray: function(r) {
        const m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
    },
    setUvTransform: function(tx, ty, sx, sy, rotation, cx, cy) {
        const c = Math.cos(rotation);
        const s = Math.sin(rotation);
        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
    },
    scale: function(sx, sy) {
        const te = this.elements;
        te[0] *= sx;
        te[3] *= sx;
        te[6] *= sx;
        te[1] *= sy;
        te[4] *= sy;
        te[7] *= sy;
        return this;
    },
    rotate: function(theta) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        const te = this.elements;
        const a11 = te[0], a12 = te[3], a13 = te[6];
        const a21 = te[1], a22 = te[4], a23 = te[7];
        te[0] = c * a11 + s * a21;
        te[3] = c * a12 + s * a22;
        te[6] = c * a13 + s * a23;
        te[1] = -s * a11 + c * a21;
        te[4] = -s * a12 + c * a22;
        te[7] = -s * a13 + c * a23;
        return this;
    },
    translate: function(tx, ty) {
        const te = this.elements;
        te[0] += tx * te[2];
        te[3] += tx * te[5];
        te[6] += tx * te[8];
        te[1] += ty * te[2];
        te[4] += ty * te[5];
        te[7] += ty * te[8];
        return this;
    },
    equals: function(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i3 = 0; i3 < 9; i3++){
            if (te[i3] !== me[i3]) return false;
        }
        return true;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        for(let i4 = 0; i4 < 9; i4++)this.elements[i4] = array[i4 + offset];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */ let _canvas;
const ImageUtils = {
    getDataURL: function(image) {
        if (/^data:/i.test(image.src)) return image.src;
        if (typeof HTMLCanvasElement == 'undefined') return image.src;
        let canvas;
        if (image instanceof HTMLCanvasElement) canvas = image;
        else {
            if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            _canvas.width = image.width;
            _canvas.height = image.height;
            const context = _canvas.getContext('2d');
            if (image instanceof ImageData) context.putImageData(image, 0, 0);
            else context.drawImage(image, 0, 0, image.width, image.height);
            canvas = _canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) return canvas.toDataURL('image/jpeg', 0.6);
        else return canvas.toDataURL('image/png');
    }
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */ let textureId = 0;
function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    Object.defineProperty(this, 'id', {
        value: textureId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
    this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
    this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;
    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
    this.format = format !== undefined ? format : RGBAFormat;
    this.internalFormat = null;
    this.type = type !== undefined ? type : UnsignedByteType;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
    // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
    //
    // Also changing the encoding after already used by a Material will not automatically make the Material
    // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
    this.encoding = encoding !== undefined ? encoding : LinearEncoding;
    this.version = 0;
    this.onUpdate = null;
}
Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Texture,
    isTexture: true,
    updateMatrix: function() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.name = source.name;
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        return this;
    },
    toJSON: function(meta) {
        const isRootObject = meta === undefined || typeof meta === 'string';
        if (!isRootObject && meta.textures[this.uuid] !== undefined) return meta.textures[this.uuid];
        const output = {
            metadata: {
                version: 4.5,
                type: 'Texture',
                generator: 'Texture.toJSON'
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [
                this.repeat.x,
                this.repeat.y
            ],
            offset: [
                this.offset.x,
                this.offset.y
            ],
            center: [
                this.center.x,
                this.center.y
            ],
            rotation: this.rotation,
            wrap: [
                this.wrapS,
                this.wrapT
            ],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        if (this.image !== undefined) {
            // TODO: Move to THREE.Image
            const image = this.image;
            if (image.uuid === undefined) image.uuid = MathUtils.generateUUID(); // UGH
            if (!isRootObject && meta.images[image.uuid] === undefined) {
                let url;
                if (Array.isArray(image)) {
                    // process array of images e.g. CubeTexture
                    url = [];
                    for(let i5 = 0, l = image.length; i5 < l; i5++)url.push(ImageUtils.getDataURL(image[i5]));
                } else // process single image
                url = ImageUtils.getDataURL(image);
                meta.images[image.uuid] = {
                    uuid: image.uuid,
                    url: url
                };
            }
            output.image = image.uuid;
        }
        if (!isRootObject) meta.textures[this.uuid] = output;
        return output;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    },
    transformUv: function(uv) {
        if (this.mapping !== UVMapping) return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) switch(this.wrapS){
            case RepeatWrapping:
                uv.x = uv.x - Math.floor(uv.x);
                break;
            case ClampToEdgeWrapping:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) uv.x = Math.ceil(uv.x) - uv.x;
                else uv.x = uv.x - Math.floor(uv.x);
                break;
        }
        if (uv.y < 0 || uv.y > 1) switch(this.wrapT){
            case RepeatWrapping:
                uv.y = uv.y - Math.floor(uv.y);
                break;
            case ClampToEdgeWrapping:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) uv.y = Math.ceil(uv.y) - uv.y;
                else uv.y = uv.y - Math.floor(uv.y);
                break;
        }
        if (this.flipY) uv.y = 1 - uv.y;
        return uv;
    }
});
Object.defineProperty(Texture.prototype, "needsUpdate", {
    set: function(value) {
        if (value === true) this.version++;
    }
});
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */ function Vector4(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
}
Object.defineProperties(Vector4.prototype, {
    "width": {
        get: function() {
            return this.z;
        },
        set: function(value) {
            this.z = value;
        }
    },
    "height": {
        get: function() {
            return this.w;
        },
        set: function(value) {
            this.w = value;
        }
    }
});
Object.assign(Vector4.prototype, {
    isVector4: true,
    set: function(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    },
    setScalar: function(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
    },
    setX: function(x) {
        this.x = x;
        return this;
    },
    setY: function(y) {
        this.y = y;
        return this;
    },
    setZ: function(z) {
        this.z = z;
        return this;
    },
    setW: function(w) {
        this.w = w;
        return this;
    },
    setComponent: function(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    },
    getComponent: function(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error('index is out of range: ' + index);
        }
    },
    clone: function() {
        return new this.constructor(this.x, this.y, this.z, this.w);
    },
    copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== undefined ? v.w : 1;
        return this;
    },
    add: function(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
    },
    addScalar: function(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
    },
    addScaledVector: function(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
    },
    sub: function(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
    },
    subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
    },
    multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
    },
    applyMatrix4: function(m) {
        const x = this.x, y = this.y, z = this.z, w = this.w;
        const e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
    },
    divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
    },
    setAxisAngleFromQuaternion: function(q) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
        // q is assumed to be normalized
        this.w = 2 * Math.acos(q.w);
        const s = Math.sqrt(1 - q.w * q.w);
        if (s < 0.0001) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
        } else {
            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;
        }
        return this;
    },
    setAxisAngleFromRotationMatrix: function(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        let angle, x, y, z; // variables for result
        const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            // singularity found
            // first check for identity matrix which must have +1 for all terms
            // in leading diagonal and zero in other terms
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                // this singularity is identity matrix so angle = 0
                this.set(1, 0, 0, 0);
                return this; // zero angle, arbitrary axis
            }
            // otherwise this singularity is angle = 180
            angle = Math.PI;
            const xx = (m11 + 1) / 2;
            const yy = (m22 + 1) / 2;
            const zz = (m33 + 1) / 2;
            const xy = (m12 + m21) / 4;
            const xz = (m13 + m31) / 4;
            const yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
                // m11 is the largest diagonal term
                if (xx < epsilon) {
                    x = 0;
                    y = 0.707106781;
                    z = 0.707106781;
                } else {
                    x = Math.sqrt(xx);
                    y = xy / x;
                    z = xz / x;
                }
            } else if (yy > zz) {
                // m22 is the largest diagonal term
                if (yy < epsilon) {
                    x = 0.707106781;
                    y = 0;
                    z = 0.707106781;
                } else {
                    y = Math.sqrt(yy);
                    x = xy / y;
                    z = yz / y;
                }
            } else // m33 is the largest diagonal term so base result on this
            if (zz < epsilon) {
                x = 0.707106781;
                y = 0.707106781;
                z = 0;
            } else {
                z = Math.sqrt(zz);
                x = xz / z;
                y = yz / z;
            }
            this.set(x, y, z, angle);
            return this; // return 180 deg rotation
        }
        // as we have reached here there are no singularities so we can handle normally
        let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize
        if (Math.abs(s) < 0.001) s = 1;
        // prevent divide by zero, should not happen if matrix is orthogonal and should be
        // caught by singularity test above, but I've left it in just in case
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
    },
    min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
    },
    max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
    },
    clamp: function(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
    },
    clampScalar: function(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        this.w = Math.max(minVal, Math.min(maxVal, this.w));
        return this;
    },
    clampLength: function(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    },
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
    },
    roundToZero: function() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
    },
    negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    },
    dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    },
    manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    },
    normalize: function() {
        return this.divideScalar(this.length() || 1);
    },
    setLength: function(length) {
        return this.normalize().multiplyScalar(length);
    },
    lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
    },
    lerpVectors: function(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
    },
    equals: function(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
    },
    fromBufferAttribute: function(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        this.w = attribute.getW(index);
        return this;
    },
    random: function() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
    }
});
/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */ /*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/ function WebGLRenderTarget(width, height, options) {
    this.width = width;
    this.height = height;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    options = options || {};
    this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.image = {};
    this.texture.image.width = width;
    this.texture.image.height = height;
    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
    this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
}
WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: WebGLRenderTarget,
    isWebGLRenderTarget: true,
    setSize: function(width, height) {
        if (this.width !== width || this.height !== height) {
            this.width = width;
            this.height = height;
            this.texture.image.width = width;
            this.texture.image.height = height;
            this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.width = source.width;
        this.height = source.height;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
/**
 * @author Mugen87 / https://github.com/Mugen87
 * @author Matt DesLauriers / @mattdesl
 */ function WebGLMultisampleRenderTarget(width, height, options) {
    WebGLRenderTarget.call(this, width, height, options);
    this.samples = 4;
}
WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
    constructor: WebGLMultisampleRenderTarget,
    isWebGLMultisampleRenderTarget: true,
    copy: function(source) {
        WebGLRenderTarget.prototype.copy.call(this, source);
        this.samples = source.samples;
        return this;
    }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */ function Quaternion(x = 0, y = 0, z = 0, w = 1) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
}
Object.assign(Quaternion, {
    slerp: function(qa, qb, qm, t) {
        return qm.copy(qa).slerp(qb, t);
    },
    slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        // fuzz-free, array-based Quaternion SLERP operation
        let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
            let s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            // Skip the Slerp for tiny steps to avoid numeric problems:
            if (sqrSin > Number.EPSILON) {
                const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                s = Math.sin(s * len) / sin;
                t = Math.sin(t * len) / sin;
            }
            const tDir = t * dir;
            x0 = x0 * s + x1 * tDir;
            y0 = y0 * s + y1 * tDir;
            z0 = z0 * s + z1 * tDir;
            w0 = w0 * s + w1 * tDir;
            // Normalize in case we just did a lerp:
            if (s === 1 - t) {
                const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                x0 *= f;
                y0 *= f;
                z0 *= f;
                w0 *= f;
            }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
    },
    multiplyQuaternionsFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
        const x0 = src0[srcOffset0];
        const y0 = src0[srcOffset0 + 1];
        const z0 = src0[srcOffset0 + 2];
        const w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1];
        const y1 = src1[srcOffset1 + 1];
        const z1 = src1[srcOffset1 + 2];
        const w1 = src1[srcOffset1 + 3];
        dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
        dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
        dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
        dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
        return dst;
    }
});
Object.defineProperties(Quaternion.prototype, {
    x: {
        get: function() {
            return this._x;
        },
        set: function(value) {
            this._x = value;
            this._onChangeCallback();
        }
    },
    y: {
        get: function() {
            return this._y;
        },
        set: function(value) {
            this._y = value;
            this._onChangeCallback();
        }
    },
    z: {
        get: function() {
            return this._z;
        },
        set: function(value) {
            this._z = value;
            this._onChangeCallback();
        }
    },
    w: {
        get: function() {
            return this._w;
        },
        set: function(value) {
            this._w = value;
            this._onChangeCallback();
        }
    }
});
Object.assign(Quaternion.prototype, {
    isQuaternion: true,
    set: function(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onChangeCallback();
        return this;
    },
    clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._w);
    },
    copy: function(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
    },
    setFromEuler: function(euler, update) {
        if (!(euler && euler.isEuler)) throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
        const x = euler._x, y = euler._y, z = euler._z, order = euler.order;
        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        //	content/SpinCalc.m
        const cos = Math.cos;
        const sin = Math.sin;
        const c1 = cos(x / 2);
        const c2 = cos(y / 2);
        const c3 = cos(z / 2);
        const s1 = sin(x / 2);
        const s2 = sin(y / 2);
        const s3 = sin(z / 2);
        switch(order){
            case 'XYZ':
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case 'YXZ':
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            case 'ZXY':
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case 'ZYX':
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            case 'YZX':
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case 'XZY':
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            default:
                console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
        }
        if (update !== false) this._onChangeCallback();
        return this;
    },
    setFromAxisAngle: function(axis, angle) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
        // assumes axis is normalized
        const halfAngle = angle / 2, s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
    },
    setFromRotationMatrix: function(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        if (trace > 0) {
            const s = 0.5 / Math.sqrt(trace + 1);
            this._w = 0.25 / s;
            this._x = (m32 - m23) * s;
            this._y = (m13 - m31) * s;
            this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
            const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this._w = (m32 - m23) / s;
            this._x = 0.25 * s;
            this._y = (m12 + m21) / s;
            this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
            const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this._w = (m13 - m31) / s;
            this._x = (m12 + m21) / s;
            this._y = 0.25 * s;
            this._z = (m23 + m32) / s;
        } else {
            const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this._w = (m21 - m12) / s;
            this._x = (m13 + m31) / s;
            this._y = (m23 + m32) / s;
            this._z = 0.25 * s;
        }
        this._onChangeCallback();
        return this;
    },
    setFromUnitVectors: function(vFrom, vTo) {
        // assumes direction vectors vFrom and vTo are normalized
        const EPS = 0.000001;
        let r = vFrom.dot(vTo) + 1;
        if (r < EPS) {
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                this._x = -vFrom.y;
                this._y = vFrom.x;
                this._z = 0;
                this._w = r;
            } else {
                this._x = 0;
                this._y = -vFrom.z;
                this._z = vFrom.y;
                this._w = r;
            }
        } else {
            // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
            this._w = r;
        }
        return this.normalize();
    },
    angleTo: function(q) {
        return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
    },
    rotateTowards: function(q, step) {
        const angle = this.angleTo(q);
        if (angle === 0) return this;
        const t = Math.min(1, step / angle);
        this.slerp(q, t);
        return this;
    },
    inverse: function() {
        // quaternion is assumed to have unit length
        return this.conjugate();
    },
    conjugate: function() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
    },
    dot: function(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    },
    lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    },
    length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    },
    normalize: function() {
        let l = this.length();
        if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
        } else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
        }
        this._onChangeCallback();
        return this;
    },
    multiply: function(q, p) {
        if (p !== undefined) {
            console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
            return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
    },
    premultiply: function(q) {
        return this.multiplyQuaternions(q, this);
    },
    multiplyQuaternions: function(a, b) {
        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
        const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
    },
    slerp: function(qb, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(qb);
        const x = this._x, y = this._y, z = this._z, w = this._w;
        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
        let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
        } else this.copy(qb);
        if (cosHalfTheta >= 1) {
            this._w = w;
            this._x = x;
            this._y = y;
            this._z = z;
            return this;
        }
        const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
            const s = 1 - t;
            this._w = s * w + t * this._w;
            this._x = s * x + t * this._x;
            this._y = s * y + t * this._y;
            this._z = s * z + t * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
        }
        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = w * ratioA + this._w * ratioB;
        this._x = x * ratioA + this._x * ratioB;
        this._y = y * ratioA + this._y * ratioB;
        this._z = z * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
    },
    equals: function(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onChangeCallback();
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
    },
    fromBufferAttribute: function(attribute, index) {
        this._x = attribute.getX(index);
        this._y = attribute.getY(index);
        this._z = attribute.getZ(index);
        this._w = attribute.getW(index);
        return this;
    },
    _onChange: function(callback) {
        this._onChangeCallback = callback;
        return this;
    },
    _onChangeCallback: function() {}
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */ const _vector = new Vector3();
const _quaternion = new Quaternion();
function Vector3(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
}
Object.assign(Vector3.prototype, {
    isVector3: true,
    set: function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    },
    setScalar: function(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
    },
    setX: function(x) {
        this.x = x;
        return this;
    },
    setY: function(y) {
        this.y = y;
        return this;
    },
    setZ: function(z) {
        this.z = z;
        return this;
    },
    setComponent: function(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    },
    getComponent: function(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error('index is out of range: ' + index);
        }
    },
    clone: function() {
        return new this.constructor(this.x, this.y, this.z);
    },
    copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    },
    add: function(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
    },
    addScalar: function(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
    },
    addScaledVector: function(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
    },
    sub: function(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
    },
    subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
    },
    multiply: function(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
            return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
    },
    multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
    },
    multiplyVectors: function(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
    },
    applyEuler: function(euler) {
        if (!(euler && euler.isEuler)) console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
        return this.applyQuaternion(_quaternion.setFromEuler(euler));
    },
    applyAxisAngle: function(axis, angle) {
        return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
    },
    applyMatrix3: function(m) {
        const x = this.x, y = this.y, z = this.z;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
    },
    applyNormalMatrix: function(m) {
        return this.applyMatrix3(m).normalize();
    },
    applyMatrix4: function(m) {
        const x = this.x, y = this.y, z = this.z;
        const e = m.elements;
        const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
        return this;
    },
    applyQuaternion: function(q) {
        const x = this.x, y = this.y, z = this.z;
        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        // calculate quat * vector
        const ix = qw * x + qy * z - qz * y;
        const iy = qw * y + qz * x - qx * z;
        const iz = qw * z + qx * y - qy * x;
        const iw = -qx * x - qy * y - qz * z;
        // calculate result * inverse quat
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
    },
    project: function(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    },
    unproject: function(camera) {
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    },
    transformDirection: function(m) {
        // input: THREE.Matrix4 affine matrix
        // vector interpreted as a direction
        const x = this.x, y = this.y, z = this.z;
        const e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        return this.normalize();
    },
    divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
    },
    divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
    },
    min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
    },
    max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
    },
    clamp: function(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
    },
    clampScalar: function(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        return this;
    },
    clampLength: function(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    },
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    },
    roundToZero: function() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
    },
    negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    },
    dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    },
    // TODO lengthSquared?
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    manhattanLength: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function() {
        return this.divideScalar(this.length() || 1);
    },
    setLength: function(length) {
        return this.normalize().multiplyScalar(length);
    },
    lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
    },
    lerpVectors: function(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
    },
    cross: function(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
            return this.crossVectors(v, w);
        }
        return this.crossVectors(this, v);
    },
    crossVectors: function(a, b) {
        const ax = a.x, ay = a.y, az = a.z;
        const bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
    },
    projectOnVector: function(v) {
        const denominator = v.lengthSq();
        if (denominator === 0) return this.set(0, 0, 0);
        const scalar = v.dot(this) / denominator;
        return this.copy(v).multiplyScalar(scalar);
    },
    projectOnPlane: function(planeNormal) {
        _vector.copy(this).projectOnVector(planeNormal);
        return this.sub(_vector);
    },
    reflect: function(normal) {
        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length
        return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
    },
    angleTo: function(v) {
        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0) return Math.PI / 2;
        const theta = this.dot(v) / denominator;
        // clamp, to handle numerical problems
        return Math.acos(MathUtils.clamp(theta, -1, 1));
    },
    distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function(v) {
        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    },
    manhattanDistanceTo: function(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    },
    setFromSpherical: function(s) {
        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    },
    setFromSphericalCoords: function(radius, phi, theta) {
        const sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
    },
    setFromCylindrical: function(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    },
    setFromCylindricalCoords: function(radius, theta, y) {
        this.x = radius * Math.sin(theta);
        this.y = y;
        this.z = radius * Math.cos(theta);
        return this;
    },
    setFromMatrixPosition: function(m) {
        const e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        return this;
    },
    setFromMatrixScale: function(m) {
        const sx = this.setFromMatrixColumn(m, 0).length();
        const sy = this.setFromMatrixColumn(m, 1).length();
        const sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
    },
    setFromMatrixColumn: function(m, index) {
        return this.fromArray(m.elements, index * 4);
    },
    setFromMatrix3Column: function(m, index) {
        return this.fromArray(m.elements, index * 3);
    },
    equals: function(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
    },
    fromBufferAttribute: function(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        return this;
    },
    random: function() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
    }
});
const _v1 = new Vector3();
const _m1 = new Matrix4();
const _zero = new Vector3(0, 0, 0);
const _one = new Vector3(1, 1, 1);
const _x = new Vector3();
const _y = new Vector3();
const _z = new Vector3();
/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */ function Matrix4() {
    this.elements = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
    if (arguments.length > 0) console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
}
Object.assign(Matrix4.prototype, {
    isMatrix4: true,
    set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        const te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
    },
    identity: function() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    },
    clone: function() {
        return new Matrix4().fromArray(this.elements);
    },
    copy: function(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
    },
    copyPosition: function(m) {
        const te = this.elements, me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
    },
    extractBasis: function(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
    },
    makeBasis: function(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
    },
    extractRotation: function(m) {
        // this method does not support reflection matrices
        const te = this.elements;
        const me = m.elements;
        const scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();
        const scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();
        const scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    },
    makeRotationFromEuler: function(euler) {
        if (!(euler && euler.isEuler)) console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        const te = this.elements;
        const x = euler.x, y = euler.y, z = euler.z;
        const a = Math.cos(x), b = Math.sin(x);
        const c = Math.cos(y), d = Math.sin(y);
        const e = Math.cos(z), f = Math.sin(z);
        if (euler.order === 'XYZ') {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
        } else if (euler.order === 'YXZ') {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
        } else if (euler.order === 'ZXY') {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce - df * b;
            te[4] = -a * f;
            te[8] = de + cf * b;
            te[1] = cf + de * b;
            te[5] = a * e;
            te[9] = df - ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
        } else if (euler.order === 'ZYX') {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c * f;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
        } else if (euler.order === 'YZX') {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
        } else if (euler.order === 'XZY') {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = ac * f + bd;
            te[5] = a * e;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b * e;
            te[10] = bd * f + ac;
        }
        // bottom row
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        // last column
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    },
    makeRotationFromQuaternion: function(q) {
        return this.compose(_zero, q, _one);
    },
    lookAt: function(eye, target, up) {
        const te = this.elements;
        _z.subVectors(eye, target);
        if (_z.lengthSq() === 0) // eye and target are in the same position
        _z.z = 1;
        _z.normalize();
        _x.crossVectors(up, _z);
        if (_x.lengthSq() === 0) {
            // up and z are parallel
            if (Math.abs(up.z) === 1) _z.x += 0.0001;
            else _z.z += 0.0001;
            _z.normalize();
            _x.crossVectors(up, _z);
        }
        _x.normalize();
        _y.crossVectors(_z, _x);
        te[0] = _x.x;
        te[4] = _y.x;
        te[8] = _z.x;
        te[1] = _x.y;
        te[5] = _y.y;
        te[9] = _z.y;
        te[2] = _x.z;
        te[6] = _y.z;
        te[10] = _z.z;
        return this;
    },
    multiply: function(m, n) {
        if (n !== undefined) {
            console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
            return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
    },
    premultiply: function(m) {
        return this.multiplyMatrices(m, this);
    },
    multiplyMatrices: function(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
    },
    multiplyScalar: function(s) {
        const te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
    },
    determinant: function() {
        const te = this.elements;
        const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        //TODO: make this more efficient
        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    },
    transpose: function() {
        const te = this.elements;
        let tmp2;
        tmp2 = te[1];
        te[1] = te[4];
        te[4] = tmp2;
        tmp2 = te[2];
        te[2] = te[8];
        te[8] = tmp2;
        tmp2 = te[6];
        te[6] = te[9];
        te[9] = tmp2;
        tmp2 = te[3];
        te[3] = te[12];
        te[12] = tmp2;
        tmp2 = te[7];
        te[7] = te[13];
        te[13] = tmp2;
        tmp2 = te[11];
        te[11] = te[14];
        te[14] = tmp2;
        return this;
    },
    setPosition: function(x, y, z) {
        const te = this.elements;
        if (x.isVector3) {
            te[12] = x.x;
            te[13] = x.y;
            te[14] = x.z;
        } else {
            te[12] = x;
            te[13] = y;
            te[14] = z;
        }
        return this;
    },
    getInverse: function(m, throwOnDegenerate) {
        if (throwOnDegenerate !== undefined) console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        const te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
    },
    scale: function(v) {
        const te = this.elements;
        const x = v.x, y = v.y, z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        return this;
    },
    getMaxScaleOnAxis: function() {
        const te = this.elements;
        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    },
    makeTranslation: function(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
    },
    makeRotationX: function(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
    },
    makeRotationY: function(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
    },
    makeRotationZ: function(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    },
    makeRotationAxis: function(axis, angle) {
        // Based on http://www.gamedev.net/reference/articles/article1199.asp
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const t = 1 - c;
        const x = axis.x, y = axis.y, z = axis.z;
        const tx = t * x, ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
    },
    makeScale: function(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
    },
    makeShear: function(x, y, z) {
        this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
        return this;
    },
    compose: function(position, quaternion, scale) {
        const te = this.elements;
        const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        const x2 = x + x, y2 = y + y, z2 = z + z;
        const xx = x * x2, xy = x * y2, xz = x * z2;
        const yy = y * y2, yz = y * z2, zz = z * z2;
        const wx = w * x2, wy = w * y2, wz = w * z2;
        const sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
    },
    decompose: function(position, quaternion, scale) {
        const te = this.elements;
        let sx = _v1.set(te[0], te[1], te[2]).length();
        let sy = _v1.set(te[4], te[5], te[6]).length();
        let sz = _v1.set(te[8], te[9], te[10]).length();
        // if determine is negative, we need to invert one scale
        const det = this.determinant();
        if (det < 0) sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        // scale the rotation part
        _m1.copy(this);
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;
        _m1.elements[0] *= invSX;
        _m1.elements[1] *= invSX;
        _m1.elements[2] *= invSX;
        _m1.elements[4] *= invSY;
        _m1.elements[5] *= invSY;
        _m1.elements[6] *= invSY;
        _m1.elements[8] *= invSZ;
        _m1.elements[9] *= invSZ;
        _m1.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(_m1);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
    },
    makePerspective: function(left, right, top, bottom, near, far) {
        if (far === undefined) console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
        const te = this.elements;
        const x = 2 * near / (right - left);
        const y = 2 * near / (top - bottom);
        const a = (right + left) / (right - left);
        const b = (top + bottom) / (top - bottom);
        const c = -(far + near) / (far - near);
        const d = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
    },
    makeOrthographic: function(left, right, top, bottom, near, far) {
        const te = this.elements;
        const w = 1 / (right - left);
        const h = 1 / (top - bottom);
        const p = 1 / (far - near);
        const x = (right + left) * w;
        const y = (top + bottom) * h;
        const z = (far + near) * p;
        te[0] = 2 * w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
    },
    equals: function(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i6 = 0; i6 < 16; i6++){
            if (te[i6] !== me[i6]) return false;
        }
        return true;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        for(let i7 = 0; i7 < 16; i7++)this.elements[i7] = array[i7 + offset];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */ const _matrix = new Matrix4();
const _quaternion$1 = new Quaternion();
function Euler(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
}
Euler.RotationOrders = [
    'XYZ',
    'YZX',
    'ZXY',
    'XZY',
    'YXZ',
    'ZYX'
];
Euler.DefaultOrder = 'XYZ';
Object.defineProperties(Euler.prototype, {
    x: {
        get: function() {
            return this._x;
        },
        set: function(value) {
            this._x = value;
            this._onChangeCallback();
        }
    },
    y: {
        get: function() {
            return this._y;
        },
        set: function(value) {
            this._y = value;
            this._onChangeCallback();
        }
    },
    z: {
        get: function() {
            return this._z;
        },
        set: function(value) {
            this._z = value;
            this._onChangeCallback();
        }
    },
    order: {
        get: function() {
            return this._order;
        },
        set: function(value) {
            this._order = value;
            this._onChangeCallback();
        }
    }
});
Object.assign(Euler.prototype, {
    isEuler: true,
    set: function(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        this._onChangeCallback();
        return this;
    },
    clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._order);
    },
    copy: function(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
    },
    setFromRotationMatrix: function(m, order, update) {
        const clamp = MathUtils.clamp;
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        const te = m.elements;
        const m11 = te[0], m12 = te[4], m13 = te[8];
        const m21 = te[1], m22 = te[5], m23 = te[9];
        const m31 = te[2], m32 = te[6], m33 = te[10];
        order = order || this._order;
        switch(order){
            case 'XYZ':
                this._y = Math.asin(clamp(m13, -1, 1));
                if (Math.abs(m13) < 0.9999999) {
                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                } else {
                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                }
                break;
            case 'YXZ':
                this._x = Math.asin(-clamp(m23, -1, 1));
                if (Math.abs(m23) < 0.9999999) {
                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                } else {
                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                }
                break;
            case 'ZXY':
                this._x = Math.asin(clamp(m32, -1, 1));
                if (Math.abs(m32) < 0.9999999) {
                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                } else {
                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                }
                break;
            case 'ZYX':
                this._y = Math.asin(-clamp(m31, -1, 1));
                if (Math.abs(m31) < 0.9999999) {
                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                } else {
                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                }
                break;
            case 'YZX':
                this._z = Math.asin(clamp(m21, -1, 1));
                if (Math.abs(m21) < 0.9999999) {
                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                } else {
                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                }
                break;
            case 'XZY':
                this._z = Math.asin(-clamp(m12, -1, 1));
                if (Math.abs(m12) < 0.9999999) {
                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                } else {
                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                }
                break;
            default:
                console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
        }
        this._order = order;
        if (update !== false) this._onChangeCallback();
        return this;
    },
    setFromQuaternion: function(q, order, update) {
        _matrix.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(_matrix, order, update);
    },
    setFromVector3: function(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
    },
    reorder: function(newOrder) {
        // WARNING: this discards revolution information -bhouston
        _quaternion$1.setFromEuler(this);
        return this.setFromQuaternion(_quaternion$1, newOrder);
    },
    equals: function(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    },
    fromArray: function(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined) this._order = array[3];
        this._onChangeCallback();
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
    },
    toVector3: function(optionalResult) {
        if (optionalResult) return optionalResult.set(this._x, this._y, this._z);
        else return new Vector3(this._x, this._y, this._z);
    },
    _onChange: function(callback) {
        this._onChangeCallback = callback;
        return this;
    },
    _onChangeCallback: function() {}
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function Layers() {
    this.mask = 1;
}
Object.assign(Layers.prototype, {
    set: function(channel) {
        this.mask = 1 << channel | 0;
    },
    enable: function(channel) {
        this.mask |= 1 << channel | 0;
    },
    enableAll: function() {
        this.mask = -1;
    },
    toggle: function(channel) {
        this.mask ^= 1 << channel | 0;
    },
    disable: function(channel) {
        this.mask &= ~(1 << channel | 0);
    },
    disableAll: function() {
        this.mask = 0;
    },
    test: function(layers) {
        return (this.mask & layers.mask) !== 0;
    }
});
let _object3DId = 0;
const _v1$1 = new Vector3();
const _q1 = new Quaternion();
const _m1$1 = new Matrix4();
const _target = new Vector3();
const _position = new Vector3();
const _scale = new Vector3();
const _quaternion$2 = new Quaternion();
const _xAxis = new Vector3(1, 0, 0);
const _yAxis = new Vector3(0, 1, 0);
const _zAxis = new Vector3(0, 0, 1);
const _addedEvent = {
    type: 'added'
};
const _removedEvent = {
    type: 'removed'
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */ function Object3D() {
    Object.defineProperty(this, 'id', {
        value: _object3DId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'Object3D';
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, undefined, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
        position: {
            configurable: true,
            enumerable: true,
            value: position
        },
        rotation: {
            configurable: true,
            enumerable: true,
            value: rotation
        },
        quaternion: {
            configurable: true,
            enumerable: true,
            value: quaternion
        },
        scale: {
            configurable: true,
            enumerable: true,
            value: scale
        },
        modelViewMatrix: {
            value: new Matrix4()
        },
        normalMatrix: {
            value: new Matrix3()
        }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.userData = {};
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Object3D,
    isObject3D: true,
    onBeforeRender: function() {},
    onAfterRender: function() {},
    applyMatrix4: function(matrix) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function(q) {
        this.quaternion.premultiply(q);
        return this;
    },
    setRotationFromAxisAngle: function(axis, angle) {
        // assumes axis is normalized
        this.quaternion.setFromAxisAngle(axis, angle);
    },
    setRotationFromEuler: function(euler) {
        this.quaternion.setFromEuler(euler, true);
    },
    setRotationFromMatrix: function(m) {
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        this.quaternion.setFromRotationMatrix(m);
    },
    setRotationFromQuaternion: function(q) {
        // assumes q is normalized
        this.quaternion.copy(q);
    },
    rotateOnAxis: function(axis, angle) {
        // rotate object on axis in object space
        // axis is assumed to be normalized
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(_q1);
        return this;
    },
    rotateOnWorldAxis: function(axis, angle) {
        // rotate object on axis in world space
        // axis is assumed to be normalized
        // method assumes no rotated parent
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply(_q1);
        return this;
    },
    rotateX: function(angle) {
        return this.rotateOnAxis(_xAxis, angle);
    },
    rotateY: function(angle) {
        return this.rotateOnAxis(_yAxis, angle);
    },
    rotateZ: function(angle) {
        return this.rotateOnAxis(_zAxis, angle);
    },
    translateOnAxis: function(axis, distance) {
        // translate object by distance along axis in object space
        // axis is assumed to be normalized
        _v1$1.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(_v1$1.multiplyScalar(distance));
        return this;
    },
    translateX: function(distance) {
        return this.translateOnAxis(_xAxis, distance);
    },
    translateY: function(distance) {
        return this.translateOnAxis(_yAxis, distance);
    },
    translateZ: function(distance) {
        return this.translateOnAxis(_zAxis, distance);
    },
    localToWorld: function(vector) {
        return vector.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function(vector) {
        return vector.applyMatrix4(_m1$1.getInverse(this.matrixWorld));
    },
    lookAt: function(x, y, z) {
        // This method does not support objects having non-uniformly-scaled parent(s)
        if (x.isVector3) _target.copy(x);
        else _target.set(x, y, z);
        const parent = this.parent;
        this.updateWorldMatrix(true, false);
        _position.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) _m1$1.lookAt(_position, _target, this.up);
        else _m1$1.lookAt(_target, _position, this.up);
        this.quaternion.setFromRotationMatrix(_m1$1);
        if (parent) {
            _m1$1.extractRotation(parent.matrixWorld);
            _q1.setFromRotationMatrix(_m1$1);
            this.quaternion.premultiply(_q1.inverse());
        }
    },
    add: function(object) {
        if (arguments.length > 1) {
            for(let i8 = 0; i8 < arguments.length; i8++)this.add(arguments[i8]);
            return this;
        }
        if (object === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
            return this;
        }
        if (object && object.isObject3D) {
            if (object.parent !== null) object.parent.remove(object);
            object.parent = this;
            this.children.push(object);
            object.dispatchEvent(_addedEvent);
        } else console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        return this;
    },
    remove: function(object) {
        if (arguments.length > 1) {
            for(let i9 = 0; i9 < arguments.length; i9++)this.remove(arguments[i9]);
            return this;
        }
        const index = this.children.indexOf(object);
        if (index !== -1) {
            object.parent = null;
            this.children.splice(index, 1);
            object.dispatchEvent(_removedEvent);
        }
        return this;
    },
    attach: function(object) {
        // adds object as a child of this, while maintaining the object's world transform
        this.updateWorldMatrix(true, false);
        _m1$1.getInverse(this.matrixWorld);
        if (object.parent !== null) {
            object.parent.updateWorldMatrix(true, false);
            _m1$1.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix4(_m1$1);
        object.updateWorldMatrix(false, false);
        this.add(object);
        return this;
    },
    getObjectById: function(id) {
        return this.getObjectByProperty('id', id);
    },
    getObjectByName: function(name) {
        return this.getObjectByProperty('name', name);
    },
    getObjectByProperty: function(name, value) {
        if (this[name] === value) return this;
        for(let i10 = 0, l = this.children.length; i10 < l; i10++){
            const child = this.children[i10];
            const object = child.getObjectByProperty(name, value);
            if (object !== undefined) return object;
        }
        return undefined;
    },
    getWorldPosition: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldPosition() target is now required');
            target = new Vector3();
        }
        this.updateMatrixWorld(true);
        return target.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
            target = new Quaternion();
        }
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(_position, target, _scale);
        return target;
    },
    getWorldScale: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldScale() target is now required');
            target = new Vector3();
        }
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(_position, _quaternion$2, target);
        return target;
    },
    getWorldDirection: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldDirection() target is now required');
            target = new Vector3();
        }
        this.updateMatrixWorld(true);
        const e = this.matrixWorld.elements;
        return target.set(e[8], e[9], e[10]).normalize();
    },
    raycast: function() {},
    traverse: function(callback) {
        callback(this);
        const children = this.children;
        for(let i11 = 0, l = children.length; i11 < l; i11++)children[i11].traverse(callback);
    },
    traverseVisible: function(callback) {
        if (this.visible === false) return;
        callback(this);
        const children = this.children;
        for(let i12 = 0, l = children.length; i12 < l; i12++)children[i12].traverseVisible(callback);
    },
    traverseAncestors: function(callback) {
        const parent = this.parent;
        if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
        }
    },
    updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
    },
    updateMatrixWorld: function(force) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) this.matrixWorld.copy(this.matrix);
            else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }
        // update children
        const children = this.children;
        for(let i13 = 0, l = children.length; i13 < l; i13++)children[i13].updateMatrixWorld(force);
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
        const parent = this.parent;
        if (updateParents === true && parent !== null) parent.updateWorldMatrix(true, false);
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.parent === null) this.matrixWorld.copy(this.matrix);
        else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        // update children
        if (updateChildren === true) {
            const children = this.children;
            for(let i14 = 0, l = children.length; i14 < l; i14++)children[i14].updateWorldMatrix(false, true);
        }
    },
    toJSON: function(meta) {
        // meta is a string when called from JSON.stringify
        const isRootObject = meta === undefined || typeof meta === 'string';
        const output = {};
        // meta is a hash used to collect geometries, materials.
        // not providing it implies that this is the root object
        // being serialized.
        if (isRootObject) {
            // initialize meta obj
            meta = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            };
            output.metadata = {
                version: 4.5,
                type: 'Object',
                generator: 'Object3D.toJSON'
            };
        }
        // standard Object3D serialization
        const object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== '') object.name = this.name;
        if (this.castShadow === true) object.castShadow = true;
        if (this.receiveShadow === true) object.receiveShadow = true;
        if (this.visible === false) object.visible = false;
        if (this.frustumCulled === false) object.frustumCulled = false;
        if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
        if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
        // object specific properties
        if (this.isInstancedMesh) {
            object.type = 'InstancedMesh';
            object.count = this.count;
            object.instanceMatrix = this.instanceMatrix.toJSON();
        }
        //
        function serialize(library, element) {
            if (library[element.uuid] === undefined) library[element.uuid] = element.toJSON(meta);
            return element.uuid;
        }
        if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            const parameters = this.geometry.parameters;
            if (parameters !== undefined && parameters.shapes !== undefined) {
                const shapes = parameters.shapes;
                if (Array.isArray(shapes)) for(let i15 = 0, l = shapes.length; i15 < l; i15++){
                    const shape = shapes[i15];
                    serialize(meta.shapes, shape);
                }
                else serialize(meta.shapes, shapes);
            }
        }
        if (this.material !== undefined) {
            if (Array.isArray(this.material)) {
                const uuids = [];
                for(let i16 = 0, l = this.material.length; i16 < l; i16++)uuids.push(serialize(meta.materials, this.material[i16]));
                object.material = uuids;
            } else object.material = serialize(meta.materials, this.material);
        }
        //
        if (this.children.length > 0) {
            object.children = [];
            for(let i17 = 0; i17 < this.children.length; i17++)object.children.push(this.children[i17].toJSON(meta).object);
        }
        if (isRootObject) {
            const geometries = extractFromCache(meta.geometries);
            const materials = extractFromCache(meta.materials);
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            const shapes = extractFromCache(meta.shapes);
            if (geometries.length > 0) output.geometries = geometries;
            if (materials.length > 0) output.materials = materials;
            if (textures.length > 0) output.textures = textures;
            if (images.length > 0) output.images = images;
            if (shapes.length > 0) output.shapes = shapes;
        }
        output.object = object;
        return output;
        // extract data from the cache hash
        // remove metadata on each item
        // and return as array
        function extractFromCache(cache) {
            const values = [];
            for(const key in cache){
                const data = cache[key];
                delete data.metadata;
                values.push(data);
            }
            return values;
        }
    },
    clone: function(recursive) {
        return new this.constructor().copy(this, recursive);
    },
    copy: function(source, recursive) {
        if (recursive === undefined) recursive = true;
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) for(let i18 = 0; i18 < source.children.length; i18++){
            const child = source.children[i18];
            this.add(child.clone());
        }
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function Scene() {
    Object3D.call(this);
    this.type = 'Scene';
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true; // checked by the renderer
    if (typeof __THREE_DEVTOOLS__ !== 'undefined') __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: this
    })); // eslint-disable-line no-undef
}
Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Scene,
    isScene: true,
    copy: function(source, recursive) {
        Object3D.prototype.copy.call(this, source, recursive);
        if (source.background !== null) this.background = source.background.clone();
        if (source.environment !== null) this.environment = source.environment.clone();
        if (source.fog !== null) this.fog = source.fog.clone();
        if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
    },
    toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        if (this.background !== null) data.object.background = this.background.toJSON(meta);
        if (this.environment !== null) data.object.environment = this.environment.toJSON(meta);
        if (this.fog !== null) data.object.fog = this.fog.toJSON();
        return data;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
const _points = [
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3()
];
const _vector$1 = new Vector3();
const _box = new Box3();
// triangle centered vertices
const _v0 = new Vector3();
const _v1$2 = new Vector3();
const _v2 = new Vector3();
// triangle edge vectors
const _f0 = new Vector3();
const _f1 = new Vector3();
const _f2 = new Vector3();
const _center = new Vector3();
const _extents = new Vector3();
const _triangleNormal = new Vector3();
const _testAxis = new Vector3();
/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */ function Box3(min, max) {
    this.min = min !== undefined ? min : new Vector3(Infinity, Infinity, Infinity);
    this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
}
Object.assign(Box3.prototype, {
    isBox3: true,
    set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    },
    setFromArray: function(array) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i19 = 0, l = array.length; i19 < l; i19 += 3){
            const x = array[i19];
            const y = array[i19 + 1];
            const z = array[i19 + 2];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (z < minZ) minZ = z;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            if (z > maxZ) maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    },
    setFromBufferAttribute: function(attribute) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i20 = 0, l = attribute.count; i20 < l; i20++){
            const x = attribute.getX(i20);
            const y = attribute.getY(i20);
            const z = attribute.getZ(i20);
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (z < minZ) minZ = z;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            if (z > maxZ) maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    },
    setFromPoints: function(points) {
        this.makeEmpty();
        for(let i21 = 0, il = points.length; i21 < il; i21++)this.expandByPoint(points[i21]);
        return this;
    },
    setFromCenterAndSize: function(center, size) {
        const halfSize = _vector$1.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
    },
    setFromObject: function(object) {
        this.makeEmpty();
        return this.expandByObject(object);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    },
    makeEmpty: function() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
    },
    isEmpty: function() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    },
    getCenter: function(target) {
        if (target === undefined) {
            console.warn('THREE.Box3: .getCenter() target is now required');
            target = new Vector3();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(target) {
        if (target === undefined) {
            console.warn('THREE.Box3: .getSize() target is now required');
            target = new Vector3();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    },
    expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    },
    expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    },
    expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    },
    expandByObject: function(object) {
        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms
        object.updateWorldMatrix(false, false);
        const geometry = object.geometry;
        if (geometry !== undefined) {
            if (geometry.boundingBox === null) geometry.computeBoundingBox();
            _box.copy(geometry.boundingBox);
            _box.applyMatrix4(object.matrixWorld);
            this.union(_box);
        }
        const children = object.children;
        for(let i22 = 0, l = children.length; i22 < l; i22++)this.expandByObject(children[i22]);
        return this;
    },
    containsPoint: function(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    },
    containsBox: function(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    },
    getParameter: function(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        if (target === undefined) {
            console.warn('THREE.Box3: .getParameter() target is now required');
            target = new Vector3();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    },
    intersectsBox: function(box) {
        // using 6 splitting planes to rule out intersections.
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    },
    intersectsSphere: function(sphere) {
        // Find the point on the AABB closest to the sphere center.
        this.clampPoint(sphere.center, _vector$1);
        // If that point is inside the sphere, the AABB and sphere intersect.
        return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    },
    intersectsPlane: function(plane) {
        // We compute the minimum and maximum dot product values. If those values
        // are on the same side (back or front) of the plane, then there is no intersection.
        let min, max;
        if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
        } else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
        } else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
        } else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
        }
        return min <= -plane.constant && max >= -plane.constant;
    },
    intersectsTriangle: function(triangle) {
        if (this.isEmpty()) return false;
        // compute box center and extents
        this.getCenter(_center);
        _extents.subVectors(this.max, _center);
        // translate triangle to aabb origin
        _v0.subVectors(triangle.a, _center);
        _v1$2.subVectors(triangle.b, _center);
        _v2.subVectors(triangle.c, _center);
        // compute edge vectors for triangle
        _f0.subVectors(_v1$2, _v0);
        _f1.subVectors(_v2, _v1$2);
        _f2.subVectors(_v0, _v2);
        // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
        // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
        // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
        let axes = [
            0,
            -_f0.z,
            _f0.y,
            0,
            -_f1.z,
            _f1.y,
            0,
            -_f2.z,
            _f2.y,
            _f0.z,
            0,
            -_f0.x,
            _f1.z,
            0,
            -_f1.x,
            _f2.z,
            0,
            -_f2.x,
            -_f0.y,
            _f0.x,
            0,
            -_f1.y,
            _f1.x,
            0,
            -_f2.y,
            _f2.x,
            0
        ];
        if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) return false;
        // test 3 face normals from the aabb
        axes = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ];
        if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) return false;
        // finally testing the face normal of the triangle
        // use already existing triangle edge vectors here
        _triangleNormal.crossVectors(_f0, _f1);
        axes = [
            _triangleNormal.x,
            _triangleNormal.y,
            _triangleNormal.z
        ];
        return satForAxes(axes, _v0, _v1$2, _v2, _extents);
    },
    clampPoint: function(point, target) {
        if (target === undefined) {
            console.warn('THREE.Box3: .clampPoint() target is now required');
            target = new Vector3();
        }
        return target.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function(point) {
        const clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    },
    getBoundingSphere: function(target) {
        if (target === undefined) console.error('THREE.Box3: .getBoundingSphere() target is now required');
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$1).length() * 0.5;
        return target;
    },
    intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
        if (this.isEmpty()) this.makeEmpty();
        return this;
    },
    union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    },
    applyMatrix4: function(matrix) {
        // transform of empty box is an empty box.
        if (this.isEmpty()) return this;
        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
        this.setFromPoints(_points);
        return this;
    },
    translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    },
    equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
});
function satForAxes(axes, v0, v1, v2, extents) {
    for(let i23 = 0, j = axes.length - 3; i23 <= j; i23 += 3){
        _testAxis.fromArray(axes, i23);
        // project the aabb onto the seperating axis
        const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
        // project all 3 vertices of the triangle onto the seperating axis
        const p0 = v0.dot(_testAxis);
        const p1 = v1.dot(_testAxis);
        const p2 = v2.dot(_testAxis);
        // actual test, basically see if either of the most extreme of the triangle points intersects r
        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) // points of the projected triangle are outside the projected half-length of the aabb
        // the axis is seperating and we can exit
        return false;
    }
    return true;
}
const _box$1 = new Box3();
/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */ function Sphere(center, radius) {
    this.center = center !== undefined ? center : new Vector3();
    this.radius = radius !== undefined ? radius : -1;
}
Object.assign(Sphere.prototype, {
    set: function(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
    },
    setFromPoints: function(points, optionalCenter) {
        const center = this.center;
        if (optionalCenter !== undefined) center.copy(optionalCenter);
        else _box$1.setFromPoints(points).getCenter(center);
        let maxRadiusSq = 0;
        for(let i24 = 0, il = points.length; i24 < il; i24++)maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i24]));
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
    },
    isEmpty: function() {
        return this.radius < 0;
    },
    makeEmpty: function() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
    },
    containsPoint: function(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function(point) {
        return point.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function(sphere) {
        const radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    },
    intersectsBox: function(box) {
        return box.intersectsSphere(this);
    },
    intersectsPlane: function(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    },
    clampPoint: function(point, target) {
        const deltaLengthSq = this.center.distanceToSquared(point);
        if (target === undefined) {
            console.warn('THREE.Sphere: .clampPoint() target is now required');
            target = new Vector3();
        }
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
    },
    getBoundingBox: function(target) {
        if (target === undefined) {
            console.warn('THREE.Sphere: .getBoundingBox() target is now required');
            target = new Box3();
        }
        if (this.isEmpty()) {
            // Empty sphere produces empty bounding box
            target.makeEmpty();
            return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
    },
    applyMatrix4: function(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
    },
    translate: function(offset) {
        this.center.add(offset);
        return this;
    },
    equals: function(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
});
const _vector$2 = new Vector3();
const _segCenter = new Vector3();
const _segDir = new Vector3();
const _diff = new Vector3();
const _edge1 = new Vector3();
const _edge2 = new Vector3();
const _normal = new Vector3();
/**
 * @author bhouston / http://clara.io
 */ function Ray(origin, direction) {
    this.origin = origin !== undefined ? origin : new Vector3();
    this.direction = direction !== undefined ? direction : new Vector3(0, 0, -1);
}
Object.assign(Ray.prototype, {
    set: function(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
    },
    at: function(t, target) {
        if (target === undefined) {
            console.warn('THREE.Ray: .at() target is now required');
            target = new Vector3();
        }
        return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    },
    lookAt: function(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
    },
    recast: function(t) {
        this.origin.copy(this.at(t, _vector$2));
        return this;
    },
    closestPointToPoint: function(point, target) {
        if (target === undefined) {
            console.warn('THREE.Ray: .closestPointToPoint() target is now required');
            target = new Vector3();
        }
        target.subVectors(point, this.origin);
        const directionDistance = target.dot(this.direction);
        if (directionDistance < 0) return target.copy(this.origin);
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    },
    distanceToPoint: function(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
    },
    distanceSqToPoint: function(point) {
        const directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction);
        // point behind the ray
        if (directionDistance < 0) return this.origin.distanceToSquared(point);
        _vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return _vector$2.distanceToSquared(point);
    },
    distanceSqToSegment: function(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
        // It returns the min distance between the ray and the segment
        // defined by v0 and v1
        // It can also set two optional targets :
        // - The closest point on the ray
        // - The closest point on the segment
        _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        _segDir.copy(v1).sub(v0).normalize();
        _diff.copy(this.origin).sub(_segCenter);
        const segExtent = v0.distanceTo(v1) * 0.5;
        const a01 = -this.direction.dot(_segDir);
        const b0 = _diff.dot(this.direction);
        const b1 = -_diff.dot(_segDir);
        const c = _diff.lengthSq();
        const det = Math.abs(1 - a01 * a01);
        let s0, s1, sqrDist, extDet;
        if (det > 0) {
            // The ray and segment are not parallel.
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
                if (s1 >= -extDet) {
                    if (s1 <= extDet) {
                        // region 0
                        // Minimum at interior points of ray and segment.
                        const invDet = 1 / det;
                        s0 *= invDet;
                        s1 *= invDet;
                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                    } else {
                        // region 1
                        s1 = segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                } else {
                    // region 5
                    s1 = -segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            } else {
                if (s1 <= -extDet) {
                    // region 4
                    s0 = Math.max(0, -(-a01 * segExtent + b0));
                    s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                } else if (s1 <= extDet) {
                    // region 3
                    s0 = 0;
                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = s1 * (s1 + 2 * b1) + c;
                } else {
                    // region 2
                    s0 = Math.max(0, -(a01 * segExtent + b0));
                    s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            }
        } else {
            // Ray and segment are parallel.
            s1 = a01 > 0 ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        if (optionalPointOnSegment) optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
        return sqrDist;
    },
    intersectSphere: function(sphere, target) {
        _vector$2.subVectors(sphere.center, this.origin);
        const tca = _vector$2.dot(this.direction);
        const d2 = _vector$2.dot(_vector$2) - tca * tca;
        const radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2) return null;
        const thc = Math.sqrt(radius2 - d2);
        // t0 = first intersect point - entrance on front of sphere
        const t0 = tca - thc;
        // t1 = second intersect point - exit point on back of sphere
        const t1 = tca + thc;
        // test to see if both t0 and t1 are behind the ray - if so, return null
        if (t0 < 0 && t1 < 0) return null;
        // test to see if t0 is behind the ray:
        // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
        // in order to always return an intersect point that is in front of the ray.
        if (t0 < 0) return this.at(t1, target);
        // else t0 is in front of the ray, so return the first collision point scaled by t0
        return this.at(t0, target);
    },
    intersectsSphere: function(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    },
    distanceToPlane: function(plane) {
        const denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (plane.distanceToPoint(this.origin) === 0) return 0;
            // Null is preferable to undefined since undefined means.... it is undefined
            return null;
        }
        const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        // Return if the ray never intersects the plane
        return t >= 0 ? t : null;
    },
    intersectPlane: function(plane, target) {
        const t = this.distanceToPlane(plane);
        if (t === null) return null;
        return this.at(t, target);
    },
    intersectsPlane: function(plane) {
        // check if the ray lies on the plane first
        const distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) return true;
        const denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) return true;
        // ray origin is behind the plane (and is pointing behind it)
        return false;
    },
    intersectBox: function(box, target) {
        let tmin, tmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        const origin = this.origin;
        if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
        } else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
        } else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax) return null;
        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN
        if (tymin > tmin || tmin !== tmin) tmin = tymin;
        if (tymax < tmax || tmax !== tmax) tmax = tymax;
        if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
        } else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax) return null;
        if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
        //return point closest to the ray (positive side)
        if (tmax < 0) return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
    },
    intersectsBox: function(box) {
        return this.intersectBox(box, _vector$2) !== null;
    },
    intersectTriangle: function(a, b, c, backfaceCulling, target) {
        // Compute the offset origin, edges, and normal.
        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
        _edge1.subVectors(b, a);
        _edge2.subVectors(c, a);
        _normal.crossVectors(_edge1, _edge2);
        // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
        // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
        //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
        //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
        //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
        let DdN = this.direction.dot(_normal);
        let sign1;
        if (DdN > 0) {
            if (backfaceCulling) return null;
            sign1 = 1;
        } else if (DdN < 0) {
            sign1 = -1;
            DdN = -DdN;
        } else return null;
        _diff.subVectors(this.origin, a);
        const DdQxE2 = sign1 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        // b1 < 0, no intersection
        if (DdQxE2 < 0) return null;
        const DdE1xQ = sign1 * this.direction.dot(_edge1.cross(_diff));
        // b2 < 0, no intersection
        if (DdE1xQ < 0) return null;
        // b1+b2 > 1, no intersection
        if (DdQxE2 + DdE1xQ > DdN) return null;
        // Line intersects triangle, check if ray does.
        const QdN = -sign1 * _diff.dot(_normal);
        // t < 0, no intersection
        if (QdN < 0) return null;
        // Ray intersects triangle.
        return this.at(QdN / DdN, target);
    },
    applyMatrix4: function(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
    },
    equals: function(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
});
/**
 * @author bhouston / http://clara.io
 */ const _vector1 = new Vector3();
const _vector2 = new Vector3();
const _normalMatrix = new Matrix3();
function Plane(normal, constant) {
    // normal is assumed to be normalized
    this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
    this.constant = constant !== undefined ? constant : 0;
}
Object.assign(Plane.prototype, {
    isPlane: true,
    set: function(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
    },
    setComponents: function(x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
    },
    setFromNormalAndCoplanarPoint: function(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
    },
    setFromCoplanarPoints: function(a, b, c) {
        const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
        // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
        this.setFromNormalAndCoplanarPoint(normal, a);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
    },
    normalize: function() {
        // Note: will lead to a divide by zero if the plane is invalid.
        const inverseNormalLength = 1 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
    },
    negate: function() {
        this.constant *= -1;
        this.normal.negate();
        return this;
    },
    distanceToPoint: function(point) {
        return this.normal.dot(point) + this.constant;
    },
    distanceToSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
    },
    projectPoint: function(point, target) {
        if (target === undefined) {
            console.warn('THREE.Plane: .projectPoint() target is now required');
            target = new Vector3();
        }
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    },
    intersectLine: function(line, target) {
        if (target === undefined) {
            console.warn('THREE.Plane: .intersectLine() target is now required');
            target = new Vector3();
        }
        const direction = line.delta(_vector1);
        const denominator = this.normal.dot(direction);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (this.distanceToPoint(line.start) === 0) return target.copy(line.start);
            // Unsure if this is the correct method to handle this case.
            return undefined;
        }
        const t = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t < 0 || t > 1) return undefined;
        return target.copy(direction).multiplyScalar(t).add(line.start);
    },
    intersectsLine: function(line) {
        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
        const startSign = this.distanceToPoint(line.start);
        const endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    },
    intersectsBox: function(box) {
        return box.intersectsPlane(this);
    },
    intersectsSphere: function(sphere) {
        return sphere.intersectsPlane(this);
    },
    coplanarPoint: function(target) {
        if (target === undefined) {
            console.warn('THREE.Plane: .coplanarPoint() target is now required');
            target = new Vector3();
        }
        return target.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function(matrix, optionalNormalMatrix) {
        const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
        const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
        const normal = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal);
        return this;
    },
    translate: function(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
    },
    equals: function(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
});
/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */ const _v0$1 = new Vector3();
const _v1$3 = new Vector3();
const _v2$1 = new Vector3();
const _v3 = new Vector3();
const _vab = new Vector3();
const _vac = new Vector3();
const _vbc = new Vector3();
const _vap = new Vector3();
const _vbp = new Vector3();
const _vcp = new Vector3();
function Triangle(a, b, c) {
    this.a = a !== undefined ? a : new Vector3();
    this.b = b !== undefined ? b : new Vector3();
    this.c = c !== undefined ? c : new Vector3();
}
Object.assign(Triangle, {
    getNormal: function(a, b, c, target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .getNormal() target is now required');
            target = new Vector3();
        }
        target.subVectors(c, b);
        _v0$1.subVectors(a, b);
        target.cross(_v0$1);
        const targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        return target.set(0, 0, 0);
    },
    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    getBarycoord: function(point, a, b, c, target) {
        _v0$1.subVectors(c, a);
        _v1$3.subVectors(b, a);
        _v2$1.subVectors(point, a);
        const dot00 = _v0$1.dot(_v0$1);
        const dot01 = _v0$1.dot(_v1$3);
        const dot02 = _v0$1.dot(_v2$1);
        const dot11 = _v1$3.dot(_v1$3);
        const dot12 = _v1$3.dot(_v2$1);
        const denom = dot00 * dot11 - dot01 * dot01;
        if (target === undefined) {
            console.warn('THREE.Triangle: .getBarycoord() target is now required');
            target = new Vector3();
        }
        // collinear or singular triangle
        if (denom === 0) // arbitrary location outside of triangle?
        // not sure if this is the best idea, maybe should be returning undefined
        return target.set(-2, -1, -1);
        const invDenom = 1 / denom;
        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        // barycentric coordinates must always sum to 1
        return target.set(1 - u - v, v, u);
    },
    containsPoint: function(point, a, b, c) {
        Triangle.getBarycoord(point, a, b, c, _v3);
        return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
    },
    getUV: function(point, p1, p2, p3, uv1, uv2, uv3, target) {
        this.getBarycoord(point, p1, p2, p3, _v3);
        target.set(0, 0);
        target.addScaledVector(uv1, _v3.x);
        target.addScaledVector(uv2, _v3.y);
        target.addScaledVector(uv3, _v3.z);
        return target;
    },
    isFrontFacing: function(a, b, c, direction) {
        _v0$1.subVectors(c, b);
        _v1$3.subVectors(a, b);
        // strictly front facing
        return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
    }
});
Object.assign(Triangle.prototype, {
    set: function(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
    },
    setFromPointsAndIndices: function(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
    },
    getArea: function() {
        _v0$1.subVectors(this.c, this.b);
        _v1$3.subVectors(this.a, this.b);
        return _v0$1.cross(_v1$3).length() * 0.5;
    },
    getMidpoint: function(target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .getMidpoint() target is now required');
            target = new Vector3();
        }
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    getNormal: function(target) {
        return Triangle.getNormal(this.a, this.b, this.c, target);
    },
    getPlane: function(target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .getPlane() target is now required');
            target = new Plane();
        }
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    getBarycoord: function(point, target) {
        return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    },
    getUV: function(point, uv1, uv2, uv3, target) {
        return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
    },
    containsPoint: function(point) {
        return Triangle.containsPoint(point, this.a, this.b, this.c);
    },
    isFrontFacing: function(direction) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    },
    intersectsBox: function(box) {
        return box.intersectsTriangle(this);
    },
    closestPointToPoint: function(p, target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
            target = new Vector3();
        }
        const a = this.a, b = this.b, c = this.c;
        let v, w;
        // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
        // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
        // under the accompanying license; see chapter 5.1.5 for detailed explanation.
        // basically, we're distinguishing which of the voronoi regions of the triangle
        // the point lies in with the minimum amount of redundant computation.
        _vab.subVectors(b, a);
        _vac.subVectors(c, a);
        _vap.subVectors(p, a);
        const d1 = _vab.dot(_vap);
        const d2 = _vac.dot(_vap);
        if (d1 <= 0 && d2 <= 0) // vertex region of A; barycentric coords (1, 0, 0)
        return target.copy(a);
        _vbp.subVectors(p, b);
        const d3 = _vab.dot(_vbp);
        const d4 = _vac.dot(_vbp);
        if (d3 >= 0 && d4 <= d3) // vertex region of B; barycentric coords (0, 1, 0)
        return target.copy(b);
        const vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
            v = d1 / (d1 - d3);
            // edge region of AB; barycentric coords (1-v, v, 0)
            return target.copy(a).addScaledVector(_vab, v);
        }
        _vcp.subVectors(p, c);
        const d5 = _vab.dot(_vcp);
        const d6 = _vac.dot(_vcp);
        if (d6 >= 0 && d5 <= d6) // vertex region of C; barycentric coords (0, 0, 1)
        return target.copy(c);
        const vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
            w = d2 / (d2 - d6);
            // edge region of AC; barycentric coords (1-w, 0, w)
            return target.copy(a).addScaledVector(_vac, w);
        }
        const va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
            _vbc.subVectors(c, b);
            w = (d4 - d3) / (d4 - d3 + (d5 - d6));
            // edge region of BC; barycentric coords (0, 1-w, w)
            return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
        }
        // face region
        const denom = 1 / (va + vb + vc);
        // u = va * denom
        v = vb * denom;
        w = vc * denom;
        return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
    },
    equals: function(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ const _colorKeywords = {
    'aliceblue': 15792383,
    'antiquewhite': 16444375,
    'aqua': 65535,
    'aquamarine': 8388564,
    'azure': 15794175,
    'beige': 16119260,
    'bisque': 16770244,
    'black': 0,
    'blanchedalmond': 16772045,
    'blue': 255,
    'blueviolet': 9055202,
    'brown': 10824234,
    'burlywood': 14596231,
    'cadetblue': 6266528,
    'chartreuse': 8388352,
    'chocolate': 13789470,
    'coral': 16744272,
    'cornflowerblue': 6591981,
    'cornsilk': 16775388,
    'crimson': 14423100,
    'cyan': 65535,
    'darkblue': 139,
    'darkcyan': 35723,
    'darkgoldenrod': 12092939,
    'darkgray': 11119017,
    'darkgreen': 25600,
    'darkgrey': 11119017,
    'darkkhaki': 12433259,
    'darkmagenta': 9109643,
    'darkolivegreen': 5597999,
    'darkorange': 16747520,
    'darkorchid': 10040012,
    'darkred': 9109504,
    'darksalmon': 15308410,
    'darkseagreen': 9419919,
    'darkslateblue': 4734347,
    'darkslategray': 3100495,
    'darkslategrey': 3100495,
    'darkturquoise': 52945,
    'darkviolet': 9699539,
    'deeppink': 16716947,
    'deepskyblue': 49151,
    'dimgray': 6908265,
    'dimgrey': 6908265,
    'dodgerblue': 2003199,
    'firebrick': 11674146,
    'floralwhite': 16775920,
    'forestgreen': 2263842,
    'fuchsia': 16711935,
    'gainsboro': 14474460,
    'ghostwhite': 16316671,
    'gold': 16766720,
    'goldenrod': 14329120,
    'gray': 8421504,
    'green': 32768,
    'greenyellow': 11403055,
    'grey': 8421504,
    'honeydew': 15794160,
    'hotpink': 16738740,
    'indianred': 13458524,
    'indigo': 4915330,
    'ivory': 16777200,
    'khaki': 15787660,
    'lavender': 15132410,
    'lavenderblush': 16773365,
    'lawngreen': 8190976,
    'lemonchiffon': 16775885,
    'lightblue': 11393254,
    'lightcoral': 15761536,
    'lightcyan': 14745599,
    'lightgoldenrodyellow': 16448210,
    'lightgray': 13882323,
    'lightgreen': 9498256,
    'lightgrey': 13882323,
    'lightpink': 16758465,
    'lightsalmon': 16752762,
    'lightseagreen': 2142890,
    'lightskyblue': 8900346,
    'lightslategray': 7833753,
    'lightslategrey': 7833753,
    'lightsteelblue': 11584734,
    'lightyellow': 16777184,
    'lime': 65280,
    'limegreen': 3329330,
    'linen': 16445670,
    'magenta': 16711935,
    'maroon': 8388608,
    'mediumaquamarine': 6737322,
    'mediumblue': 205,
    'mediumorchid': 12211667,
    'mediumpurple': 9662683,
    'mediumseagreen': 3978097,
    'mediumslateblue': 8087790,
    'mediumspringgreen': 64154,
    'mediumturquoise': 4772300,
    'mediumvioletred': 13047173,
    'midnightblue': 1644912,
    'mintcream': 16121850,
    'mistyrose': 16770273,
    'moccasin': 16770229,
    'navajowhite': 16768685,
    'navy': 128,
    'oldlace': 16643558,
    'olive': 8421376,
    'olivedrab': 7048739,
    'orange': 16753920,
    'orangered': 16729344,
    'orchid': 14315734,
    'palegoldenrod': 15657130,
    'palegreen': 10025880,
    'paleturquoise': 11529966,
    'palevioletred': 14381203,
    'papayawhip': 16773077,
    'peachpuff': 16767673,
    'peru': 13468991,
    'pink': 16761035,
    'plum': 14524637,
    'powderblue': 11591910,
    'purple': 8388736,
    'rebeccapurple': 6697881,
    'red': 16711680,
    'rosybrown': 12357519,
    'royalblue': 4286945,
    'saddlebrown': 9127187,
    'salmon': 16416882,
    'sandybrown': 16032864,
    'seagreen': 3050327,
    'seashell': 16774638,
    'sienna': 10506797,
    'silver': 12632256,
    'skyblue': 8900331,
    'slateblue': 6970061,
    'slategray': 7372944,
    'slategrey': 7372944,
    'snow': 16775930,
    'springgreen': 65407,
    'steelblue': 4620980,
    'tan': 13808780,
    'teal': 32896,
    'thistle': 14204888,
    'tomato': 16737095,
    'turquoise': 4251856,
    'violet': 15631086,
    'wheat': 16113331,
    'white': 16777215,
    'whitesmoke': 16119285,
    'yellow': 16776960,
    'yellowgreen': 10145074
};
const _hslA = {
    h: 0,
    s: 0,
    l: 0
};
const _hslB = {
    h: 0,
    s: 0,
    l: 0
};
function Color(r, g, b) {
    if (g === undefined && b === undefined) // r is THREE.Color, hex or string
    return this.set(r);
    return this.setRGB(r, g, b);
}
function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 0.5) return q;
    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
    return p;
}
function SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
    return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
Object.assign(Color.prototype, {
    isColor: true,
    r: 1,
    g: 1,
    b: 1,
    set: function(value) {
        if (value && value.isColor) this.copy(value);
        else if (typeof value === 'number') this.setHex(value);
        else if (typeof value === 'string') this.setStyle(value);
        return this;
    },
    setScalar: function(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
    },
    setHex: function(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
    },
    setRGB: function(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
    },
    setHSL: function(h, s, l) {
        // h,s,l ranges are in 0.0 - 1.0
        h = MathUtils.euclideanModulo(h, 1);
        s = MathUtils.clamp(s, 0, 1);
        l = MathUtils.clamp(l, 0, 1);
        if (s === 0) this.r = this.g = this.b = l;
        else {
            const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
            const q = 2 * l - p;
            this.r = hue2rgb(q, p, h + 1 / 3);
            this.g = hue2rgb(q, p, h);
            this.b = hue2rgb(q, p, h - 1 / 3);
        }
        return this;
    },
    setStyle: function(style) {
        function handleAlpha(string) {
            if (string === undefined) return;
            if (parseFloat(string) < 1) console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
        }
        let m;
        if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
            // rgb / hsl
            let color;
            const name = m[1];
            const components = m[2];
            switch(name){
                case 'rgb':
                case 'rgba':
                    if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        // rgb(255,0,0) rgba(255,0,0,0.5)
                        this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                        this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                        this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                        handleAlpha(color[5]);
                        return this;
                    }
                    if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                        this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                        this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                        this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                        handleAlpha(color[5]);
                        return this;
                    }
                    break;
                case 'hsl':
                case 'hsla':
                    if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                        const h = parseFloat(color[1]) / 360;
                        const s = parseInt(color[2], 10) / 100;
                        const l = parseInt(color[3], 10) / 100;
                        handleAlpha(color[5]);
                        return this.setHSL(h, s, l);
                    }
                    break;
            }
        } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
            // hex color
            const hex = m[1];
            const size = hex.length;
            if (size === 3) {
                // #ff0
                this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                return this;
            } else if (size === 6) {
                // #ff0000
                this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                return this;
            }
        }
        if (style && style.length > 0) return this.setColorName(style);
        return this;
    },
    setColorName: function(style) {
        // color keywords
        const hex = _colorKeywords[style];
        if (hex !== undefined) // red
        this.setHex(hex);
        else // unknown color
        console.warn('THREE.Color: Unknown color ' + style);
        return this;
    },
    clone: function() {
        return new this.constructor(this.r, this.g, this.b);
    },
    copy: function(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
    },
    copyGammaToLinear: function(color, gammaFactor) {
        if (gammaFactor === undefined) gammaFactor = 2;
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
    },
    copyLinearToGamma: function(color, gammaFactor) {
        if (gammaFactor === undefined) gammaFactor = 2;
        const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
    },
    convertGammaToLinear: function(gammaFactor) {
        this.copyGammaToLinear(this, gammaFactor);
        return this;
    },
    convertLinearToGamma: function(gammaFactor) {
        this.copyLinearToGamma(this, gammaFactor);
        return this;
    },
    copySRGBToLinear: function(color) {
        this.r = SRGBToLinear(color.r);
        this.g = SRGBToLinear(color.g);
        this.b = SRGBToLinear(color.b);
        return this;
    },
    copyLinearToSRGB: function(color) {
        this.r = LinearToSRGB(color.r);
        this.g = LinearToSRGB(color.g);
        this.b = LinearToSRGB(color.b);
        return this;
    },
    convertSRGBToLinear: function() {
        this.copySRGBToLinear(this);
        return this;
    },
    convertLinearToSRGB: function() {
        this.copyLinearToSRGB(this);
        return this;
    },
    getHex: function() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    },
    getHexString: function() {
        return ('000000' + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(target) {
        // h,s,l ranges are in 0.0 - 1.0
        if (target === undefined) {
            console.warn('THREE.Color: .getHSL() target is now required');
            target = {
                h: 0,
                s: 0,
                l: 0
            };
        }
        const r = this.r, g = this.g, b = this.b;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let hue, saturation;
        const lightness = (min + max) / 2;
        if (min === max) {
            hue = 0;
            saturation = 0;
        } else {
            const delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch(max){
                case r:
                    hue = (g - b) / delta + (g < b ? 6 : 0);
                    break;
                case g:
                    hue = (b - r) / delta + 2;
                    break;
                case b:
                    hue = (r - g) / delta + 4;
                    break;
            }
            hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
    },
    getStyle: function() {
        return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
    },
    offsetHSL: function(h, s, l) {
        this.getHSL(_hslA);
        _hslA.h += h;
        _hslA.s += s;
        _hslA.l += l;
        this.setHSL(_hslA.h, _hslA.s, _hslA.l);
        return this;
    },
    add: function(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
    },
    addColors: function(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
    },
    addScalar: function(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
    },
    sub: function(color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
    },
    multiply: function(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
    },
    multiplyScalar: function(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
    },
    lerp: function(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
    },
    lerpHSL: function(color, alpha) {
        this.getHSL(_hslA);
        color.getHSL(_hslB);
        const h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
        const s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
        const l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
        this.setHSL(h, s, l);
        return this;
    },
    equals: function(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
    },
    fromBufferAttribute: function(attribute, index) {
        this.r = attribute.getX(index);
        this.g = attribute.getY(index);
        this.b = attribute.getZ(index);
        if (attribute.normalized === true) {
            // assuming Uint8Array
            this.r /= 255;
            this.g /= 255;
            this.b /= 255;
        }
        return this;
    },
    toJSON: function() {
        return this.getHex();
    }
});
Color.NAMES = _colorKeywords;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */ function Face3(a, b, c, normal, color, materialIndex) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = normal && normal.isVector3 ? normal : new Vector3();
    this.vertexNormals = Array.isArray(normal) ? normal : [];
    this.color = color && color.isColor ? color : new Color();
    this.vertexColors = Array.isArray(color) ? color : [];
    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
}
Object.assign(Face3.prototype, {
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.a = source.a;
        this.b = source.b;
        this.c = source.c;
        this.normal.copy(source.normal);
        this.color.copy(source.color);
        this.materialIndex = source.materialIndex;
        for(let i26 = 0, il = source.vertexNormals.length; i26 < il; i26++)this.vertexNormals[i26] = source.vertexNormals[i26].clone();
        for(let i25 = 0, il1 = source.vertexColors.length; i25 < il1; i25++)this.vertexColors[i25] = source.vertexColors[i25].clone();
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */ let materialId = 0;
function Material() {
    Object.defineProperty(this, 'id', {
        value: materialId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'Material';
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.flatShading = false;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null; // override the renderer's default precision for this material
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaTest = 0;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
}
Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Material,
    isMaterial: true,
    onBeforeCompile: function() {},
    customProgramCacheKey: function() {
        return this.onBeforeCompile.toString();
    },
    setValues: function(values) {
        if (values === undefined) return;
        for(const key in values){
            const newValue = values[key];
            if (newValue === undefined) {
                console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                continue;
            }
            // for backward compatability if shading is set in the constructor
            if (key === 'shading') {
                console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                this.flatShading = newValue === FlatShading ? true : false;
                continue;
            }
            const currentValue = this[key];
            if (currentValue === undefined) {
                console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                continue;
            }
            if (currentValue && currentValue.isColor) currentValue.set(newValue);
            else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) currentValue.copy(newValue);
            else this[key] = newValue;
        }
    },
    toJSON: function(meta) {
        const isRoot = meta === undefined || typeof meta === 'string';
        if (isRoot) meta = {
            textures: {},
            images: {}
        };
        const data1 = {
            metadata: {
                version: 4.5,
                type: 'Material',
                generator: 'Material.toJSON'
            }
        };
        // standard Material serialization
        data1.uuid = this.uuid;
        data1.type = this.type;
        if (this.name !== '') data1.name = this.name;
        if (this.color && this.color.isColor) data1.color = this.color.getHex();
        if (this.roughness !== undefined) data1.roughness = this.roughness;
        if (this.metalness !== undefined) data1.metalness = this.metalness;
        if (this.sheen && this.sheen.isColor) data1.sheen = this.sheen.getHex();
        if (this.emissive && this.emissive.isColor) data1.emissive = this.emissive.getHex();
        if (this.emissiveIntensity && this.emissiveIntensity !== 1) data1.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor) data1.specular = this.specular.getHex();
        if (this.shininess !== undefined) data1.shininess = this.shininess;
        if (this.clearcoat !== undefined) data1.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== undefined) data1.clearcoatRoughness = this.clearcoatRoughness;
        if (this.clearcoatMap && this.clearcoatMap.isTexture) data1.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) data1.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            data1.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
            data1.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.map && this.map.isTexture) data1.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture) data1.matcap = this.matcap.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture) data1.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture) data1.lightMap = this.lightMap.toJSON(meta).uuid;
        if (this.aoMap && this.aoMap.isTexture) {
            data1.aoMap = this.aoMap.toJSON(meta).uuid;
            data1.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
            data1.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data1.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
            data1.normalMap = this.normalMap.toJSON(meta).uuid;
            data1.normalMapType = this.normalMapType;
            data1.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
            data1.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data1.displacementScale = this.displacementScale;
            data1.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture) data1.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture) data1.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture) data1.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture) data1.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
            data1.envMap = this.envMap.toJSON(meta).uuid;
            data1.reflectivity = this.reflectivity; // Scale behind envMap
            data1.refractionRatio = this.refractionRatio;
            if (this.combine !== undefined) data1.combine = this.combine;
            if (this.envMapIntensity !== undefined) data1.envMapIntensity = this.envMapIntensity;
        }
        if (this.gradientMap && this.gradientMap.isTexture) data1.gradientMap = this.gradientMap.toJSON(meta).uuid;
        if (this.size !== undefined) data1.size = this.size;
        if (this.sizeAttenuation !== undefined) data1.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== NormalBlending) data1.blending = this.blending;
        if (this.flatShading === true) data1.flatShading = this.flatShading;
        if (this.side !== FrontSide) data1.side = this.side;
        if (this.vertexColors) data1.vertexColors = true;
        if (this.opacity < 1) data1.opacity = this.opacity;
        if (this.transparent === true) data1.transparent = this.transparent;
        data1.depthFunc = this.depthFunc;
        data1.depthTest = this.depthTest;
        data1.depthWrite = this.depthWrite;
        data1.stencilWrite = this.stencilWrite;
        data1.stencilWriteMask = this.stencilWriteMask;
        data1.stencilFunc = this.stencilFunc;
        data1.stencilRef = this.stencilRef;
        data1.stencilFuncMask = this.stencilFuncMask;
        data1.stencilFail = this.stencilFail;
        data1.stencilZFail = this.stencilZFail;
        data1.stencilZPass = this.stencilZPass;
        // rotation (SpriteMaterial)
        if (this.rotation && this.rotation !== 0) data1.rotation = this.rotation;
        if (this.polygonOffset === true) data1.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0) data1.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0) data1.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth && this.linewidth !== 1) data1.linewidth = this.linewidth;
        if (this.dashSize !== undefined) data1.dashSize = this.dashSize;
        if (this.gapSize !== undefined) data1.gapSize = this.gapSize;
        if (this.scale !== undefined) data1.scale = this.scale;
        if (this.dithering === true) data1.dithering = true;
        if (this.alphaTest > 0) data1.alphaTest = this.alphaTest;
        if (this.premultipliedAlpha === true) data1.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true) data1.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1) data1.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== 'round') data1.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== 'round') data1.wireframeLinejoin = this.wireframeLinejoin;
        if (this.morphTargets === true) data1.morphTargets = true;
        if (this.morphNormals === true) data1.morphNormals = true;
        if (this.skinning === true) data1.skinning = true;
        if (this.visible === false) data1.visible = false;
        if (this.toneMapped === false) data1.toneMapped = false;
        if (JSON.stringify(this.userData) !== '{}') data1.userData = this.userData;
        // TODO: Copied from Object3D.toJSON
        function extractFromCache(cache) {
            const values = [];
            for(const key in cache){
                const data = cache[key];
                delete data.metadata;
                values.push(data);
            }
            return values;
        }
        if (isRoot) {
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            if (textures.length > 0) data1.textures = textures;
            if (images.length > 0) data1.images = images;
        }
        return data1;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.name = source.name;
        this.fog = source.fog;
        this.blending = source.blending;
        this.side = source.side;
        this.flatShading = source.flatShading;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        const srcPlanes = source.clippingPlanes;
        let dstPlanes = null;
        if (srcPlanes !== null) {
            const n = srcPlanes.length;
            dstPlanes = new Array(n);
            for(let i27 = 0; i27 !== n; ++i27)dstPlanes[i27] = srcPlanes[i27].clone();
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
Object.defineProperty(Material.prototype, 'needsUpdate', {
    set: function(value) {
        if (value === true) this.version++;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */ function MeshBasicMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshBasicMaterial';
    this.color = new Color(16777215); // emissive
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.setValues(parameters);
}
MeshBasicMaterial.prototype = Object.create(Material.prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
MeshBasicMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ const _vector$3 = new Vector3();
const _vector2$1 = new Vector2();
function BufferAttribute(array, itemSize, normalized) {
    if (Array.isArray(array)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    this.name = '';
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0;
}
Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
    set: function(value) {
        if (value === true) this.version++;
    }
});
Object.assign(BufferAttribute.prototype, {
    isBufferAttribute: true,
    onUploadCallback: function() {},
    setUsage: function(value) {
        this.usage = value;
        return this;
    },
    copy: function(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        return this;
    },
    copyAt: function(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for(let i28 = 0, l = this.itemSize; i28 < l; i28++)this.array[index1 + i28] = attribute.array[index2 + i28];
        return this;
    },
    copyArray: function(array) {
        this.array.set(array);
        return this;
    },
    copyColorsArray: function(colors) {
        const array = this.array;
        let offset = 0;
        for(let i29 = 0, l = colors.length; i29 < l; i29++){
            let color = colors[i29];
            if (color === undefined) {
                console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i29);
                color = new Color();
            }
            array[offset++] = color.r;
            array[offset++] = color.g;
            array[offset++] = color.b;
        }
        return this;
    },
    copyVector2sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i30 = 0, l = vectors.length; i30 < l; i30++){
            let vector = vectors[i30];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i30);
                vector = new Vector2();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
        }
        return this;
    },
    copyVector3sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i31 = 0, l = vectors.length; i31 < l; i31++){
            let vector = vectors[i31];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i31);
                vector = new Vector3();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
        }
        return this;
    },
    copyVector4sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i32 = 0, l = vectors.length; i32 < l; i32++){
            let vector = vectors[i32];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i32);
                vector = new Vector4();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
            array[offset++] = vector.w;
        }
        return this;
    },
    applyMatrix3: function(m) {
        if (this.itemSize === 2) for(let i34 = 0, l = this.count; i34 < l; i34++){
            _vector2$1.fromBufferAttribute(this, i34);
            _vector2$1.applyMatrix3(m);
            this.setXY(i34, _vector2$1.x, _vector2$1.y);
        }
        else if (this.itemSize === 3) for(let i33 = 0, l1 = this.count; i33 < l1; i33++){
            _vector$3.fromBufferAttribute(this, i33);
            _vector$3.applyMatrix3(m);
            this.setXYZ(i33, _vector$3.x, _vector$3.y, _vector$3.z);
        }
        return this;
    },
    applyMatrix4: function(m) {
        for(let i35 = 0, l = this.count; i35 < l; i35++){
            _vector$3.x = this.getX(i35);
            _vector$3.y = this.getY(i35);
            _vector$3.z = this.getZ(i35);
            _vector$3.applyMatrix4(m);
            this.setXYZ(i35, _vector$3.x, _vector$3.y, _vector$3.z);
        }
        return this;
    },
    applyNormalMatrix: function(m) {
        for(let i36 = 0, l = this.count; i36 < l; i36++){
            _vector$3.x = this.getX(i36);
            _vector$3.y = this.getY(i36);
            _vector$3.z = this.getZ(i36);
            _vector$3.applyNormalMatrix(m);
            this.setXYZ(i36, _vector$3.x, _vector$3.y, _vector$3.z);
        }
        return this;
    },
    transformDirection: function(m) {
        for(let i37 = 0, l = this.count; i37 < l; i37++){
            _vector$3.x = this.getX(i37);
            _vector$3.y = this.getY(i37);
            _vector$3.z = this.getZ(i37);
            _vector$3.transformDirection(m);
            this.setXYZ(i37, _vector$3.x, _vector$3.y, _vector$3.z);
        }
        return this;
    },
    set: function(value, offset) {
        if (offset === undefined) offset = 0;
        this.array.set(value, offset);
        return this;
    },
    getX: function(index) {
        return this.array[index * this.itemSize];
    },
    setX: function(index, x) {
        this.array[index * this.itemSize] = x;
        return this;
    },
    getY: function(index) {
        return this.array[index * this.itemSize + 1];
    },
    setY: function(index, y) {
        this.array[index * this.itemSize + 1] = y;
        return this;
    },
    getZ: function(index) {
        return this.array[index * this.itemSize + 2];
    },
    setZ: function(index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
    },
    getW: function(index) {
        return this.array[index * this.itemSize + 3];
    },
    setW: function(index, w) {
        this.array[index * this.itemSize + 3] = w;
        return this;
    },
    setXY: function(index, x, y) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        return this;
    },
    setXYZ: function(index, x, y, z) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
    },
    setXYZW: function(index, x, y, z, w) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
    },
    onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
    },
    clone: function() {
        return new this.constructor(this.array, this.itemSize).copy(this);
    },
    toJSON: function() {
        return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
        };
    }
});
//
function Int8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}
Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}
Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}
Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}
Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}
Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}
Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}
Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
/**
 * @author mrdoob / http://mrdoob.com/
 */ function DirectGeometry() {
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    // this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    // update flags
    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;
}
Object.assign(DirectGeometry.prototype, {
    computeGroups: function(geometry) {
        const groups = [];
        let group, i38;
        let materialIndex = undefined;
        const faces = geometry.faces;
        for(i38 = 0; i38 < faces.length; i38++){
            const face = faces[i38];
            // materials
            if (face.materialIndex !== materialIndex) {
                materialIndex = face.materialIndex;
                if (group !== undefined) {
                    group.count = i38 * 3 - group.start;
                    groups.push(group);
                }
                group = {
                    start: i38 * 3,
                    materialIndex: materialIndex
                };
            }
        }
        if (group !== undefined) {
            group.count = i38 * 3 - group.start;
            groups.push(group);
        }
        this.groups = groups;
    },
    fromGeometry: function(geometry) {
        const faces = geometry.faces;
        const vertices = geometry.vertices;
        const faceVertexUvs = geometry.faceVertexUvs;
        const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
        const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
        // morphs
        const morphTargets = geometry.morphTargets;
        const morphTargetsLength = morphTargets.length;
        let morphTargetsPosition;
        if (morphTargetsLength > 0) {
            morphTargetsPosition = [];
            for(let i39 = 0; i39 < morphTargetsLength; i39++)morphTargetsPosition[i39] = {
                name: morphTargets[i39].name,
                data: []
            };
            this.morphTargets.position = morphTargetsPosition;
        }
        const morphNormals = geometry.morphNormals;
        const morphNormalsLength = morphNormals.length;
        let morphTargetsNormal;
        if (morphNormalsLength > 0) {
            morphTargetsNormal = [];
            for(let i40 = 0; i40 < morphNormalsLength; i40++)morphTargetsNormal[i40] = {
                name: morphNormals[i40].name,
                data: []
            };
            this.morphTargets.normal = morphTargetsNormal;
        }
        // skins
        const skinIndices = geometry.skinIndices;
        const skinWeights = geometry.skinWeights;
        const hasSkinIndices = skinIndices.length === vertices.length;
        const hasSkinWeights = skinWeights.length === vertices.length;
        //
        if (vertices.length > 0 && faces.length === 0) console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
        for(let i41 = 0; i41 < faces.length; i41++){
            const face = faces[i41];
            this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
            const vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
            else {
                const normal = face.normal;
                this.normals.push(normal, normal, normal);
            }
            const vertexColors = face.vertexColors;
            if (vertexColors.length === 3) this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
            else {
                const color = face.color;
                this.colors.push(color, color, color);
            }
            if (hasFaceVertexUv === true) {
                const vertexUvs = faceVertexUvs[0][i41];
                if (vertexUvs !== undefined) this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                else {
                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i41);
                    this.uvs.push(new Vector2(), new Vector2(), new Vector2());
                }
            }
            if (hasFaceVertexUv2 === true) {
                const vertexUvs = faceVertexUvs[1][i41];
                if (vertexUvs !== undefined) this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                else {
                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i41);
                    this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
                }
            }
            // morphs
            for(let j = 0; j < morphTargetsLength; j++){
                const morphTarget = morphTargets[j].vertices;
                morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
            }
            for(let j1 = 0; j1 < morphNormalsLength; j1++){
                const morphNormal = morphNormals[j1].vertexNormals[i41];
                morphTargetsNormal[j1].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
            }
            // skins
            if (hasSkinIndices) this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
            if (hasSkinWeights) this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
        }
        this.computeGroups(geometry);
        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;
        if (geometry.boundingSphere !== null) this.boundingSphere = geometry.boundingSphere.clone();
        if (geometry.boundingBox !== null) this.boundingBox = geometry.boundingBox.clone();
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function arrayMax(array) {
    if (array.length === 0) return -Infinity;
    let max = array[0];
    for(let i42 = 1, l = array.length; i42 < l; ++i42)if (array[i42] > max) max = array[i42];
    return max;
}
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */ let _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id
const _m1$2 = new Matrix4();
const _obj = new Object3D();
const _offset = new Vector3();
const _box$2 = new Box3();
const _boxMorphTargets = new Box3();
const _vector$4 = new Vector3();
function BufferGeometry() {
    Object.defineProperty(this, 'id', {
        value: _bufferGeometryId += 2
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'BufferGeometry';
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = {
        start: 0,
        count: Infinity
    };
    this.userData = {};
}
BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: BufferGeometry,
    isBufferGeometry: true,
    getIndex: function() {
        return this.index;
    },
    setIndex: function(index) {
        if (Array.isArray(index)) this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
        else this.index = index;
    },
    getAttribute: function(name) {
        return this.attributes[name];
    },
    setAttribute: function(name, attribute) {
        this.attributes[name] = attribute;
        return this;
    },
    deleteAttribute: function(name) {
        delete this.attributes[name];
        return this;
    },
    addGroup: function(start, count, materialIndex) {
        this.groups.push({
            start: start,
            count: count,
            materialIndex: materialIndex !== undefined ? materialIndex : 0
        });
    },
    clearGroups: function() {
        this.groups = [];
    },
    setDrawRange: function(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
    },
    applyMatrix4: function(matrix) {
        const position = this.attributes.position;
        if (position !== undefined) {
            position.applyMatrix4(matrix);
            position.needsUpdate = true;
        }
        const normal = this.attributes.normal;
        if (normal !== undefined) {
            const normalMatrix = new Matrix3().getNormalMatrix(matrix);
            normal.applyNormalMatrix(normalMatrix);
            normal.needsUpdate = true;
        }
        const tangent = this.attributes.tangent;
        if (tangent !== undefined) {
            tangent.transformDirection(matrix);
            tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) this.computeBoundingBox();
        if (this.boundingSphere !== null) this.computeBoundingSphere();
        return this;
    },
    rotateX: function(angle) {
        // rotate geometry around world x-axis
        _m1$2.makeRotationX(angle);
        this.applyMatrix4(_m1$2);
        return this;
    },
    rotateY: function(angle) {
        // rotate geometry around world y-axis
        _m1$2.makeRotationY(angle);
        this.applyMatrix4(_m1$2);
        return this;
    },
    rotateZ: function(angle) {
        // rotate geometry around world z-axis
        _m1$2.makeRotationZ(angle);
        this.applyMatrix4(_m1$2);
        return this;
    },
    translate: function(x, y, z) {
        // translate geometry
        _m1$2.makeTranslation(x, y, z);
        this.applyMatrix4(_m1$2);
        return this;
    },
    scale: function(x, y, z) {
        // scale geometry
        _m1$2.makeScale(x, y, z);
        this.applyMatrix4(_m1$2);
        return this;
    },
    lookAt: function(vector) {
        _obj.lookAt(vector);
        _obj.updateMatrix();
        this.applyMatrix4(_obj.matrix);
        return this;
    },
    center: function() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset).negate();
        this.translate(_offset.x, _offset.y, _offset.z);
        return this;
    },
    setFromObject: function(object) {
        // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
        const geometry = object.geometry;
        if (object.isPoints || object.isLine) {
            const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
            const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
            this.setAttribute('position', positions.copyVector3sArray(geometry.vertices));
            this.setAttribute('color', colors.copyColorsArray(geometry.colors));
            if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
                this.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
            }
            if (geometry.boundingSphere !== null) this.boundingSphere = geometry.boundingSphere.clone();
            if (geometry.boundingBox !== null) this.boundingBox = geometry.boundingBox.clone();
        } else if (object.isMesh) {
            if (geometry && geometry.isGeometry) this.fromGeometry(geometry);
        }
        return this;
    },
    setFromPoints: function(points) {
        const position = [];
        for(let i43 = 0, l = points.length; i43 < l; i43++){
            const point = points[i43];
            position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute('position', new Float32BufferAttribute(position, 3));
        return this;
    },
    updateFromObject: function(object) {
        let geometry = object.geometry;
        if (object.isMesh) {
            let direct = geometry.__directGeometry;
            if (geometry.elementsNeedUpdate === true) {
                direct = undefined;
                geometry.elementsNeedUpdate = false;
            }
            if (direct === undefined) return this.fromGeometry(geometry);
            direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
            direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
            direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
            direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
            direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
            geometry.verticesNeedUpdate = false;
            geometry.normalsNeedUpdate = false;
            geometry.colorsNeedUpdate = false;
            geometry.uvsNeedUpdate = false;
            geometry.groupsNeedUpdate = false;
            geometry = direct;
        }
        if (geometry.verticesNeedUpdate === true) {
            const attribute = this.attributes.position;
            if (attribute !== undefined) {
                attribute.copyVector3sArray(geometry.vertices);
                attribute.needsUpdate = true;
            }
            geometry.verticesNeedUpdate = false;
        }
        if (geometry.normalsNeedUpdate === true) {
            const attribute = this.attributes.normal;
            if (attribute !== undefined) {
                attribute.copyVector3sArray(geometry.normals);
                attribute.needsUpdate = true;
            }
            geometry.normalsNeedUpdate = false;
        }
        if (geometry.colorsNeedUpdate === true) {
            const attribute = this.attributes.color;
            if (attribute !== undefined) {
                attribute.copyColorsArray(geometry.colors);
                attribute.needsUpdate = true;
            }
            geometry.colorsNeedUpdate = false;
        }
        if (geometry.uvsNeedUpdate) {
            const attribute = this.attributes.uv;
            if (attribute !== undefined) {
                attribute.copyVector2sArray(geometry.uvs);
                attribute.needsUpdate = true;
            }
            geometry.uvsNeedUpdate = false;
        }
        if (geometry.lineDistancesNeedUpdate) {
            const attribute = this.attributes.lineDistance;
            if (attribute !== undefined) {
                attribute.copyArray(geometry.lineDistances);
                attribute.needsUpdate = true;
            }
            geometry.lineDistancesNeedUpdate = false;
        }
        if (geometry.groupsNeedUpdate) {
            geometry.computeGroups(object.geometry);
            this.groups = geometry.groups;
            geometry.groupsNeedUpdate = false;
        }
        return this;
    },
    fromGeometry: function(geometry) {
        geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
        return this.fromDirectGeometry(geometry.__directGeometry);
    },
    fromDirectGeometry: function(geometry) {
        const positions = new Float32Array(geometry.vertices.length * 3);
        this.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
        if (geometry.normals.length > 0) {
            const normals = new Float32Array(geometry.normals.length * 3);
            this.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
        }
        if (geometry.colors.length > 0) {
            const colors = new Float32Array(geometry.colors.length * 3);
            this.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
        }
        if (geometry.uvs.length > 0) {
            const uvs = new Float32Array(geometry.uvs.length * 2);
            this.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
        }
        if (geometry.uvs2.length > 0) {
            const uvs2 = new Float32Array(geometry.uvs2.length * 2);
            this.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
        }
        // groups
        this.groups = geometry.groups;
        // morphs
        for(const name in geometry.morphTargets){
            const array = [];
            const morphTargets = geometry.morphTargets[name];
            for(let i44 = 0, l = morphTargets.length; i44 < l; i44++){
                const morphTarget = morphTargets[i44];
                const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
                attribute.name = morphTarget.name;
                array.push(attribute.copyVector3sArray(morphTarget.data));
            }
            this.morphAttributes[name] = array;
        }
        // skinning
        if (geometry.skinIndices.length > 0) {
            const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
            this.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
        }
        if (geometry.skinWeights.length > 0) {
            const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
            this.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
        }
        //
        if (geometry.boundingSphere !== null) this.boundingSphere = geometry.boundingSphere.clone();
        if (geometry.boundingBox !== null) this.boundingBox = geometry.boundingBox.clone();
        return this;
    },
    computeBoundingBox: function() {
        if (this.boundingBox === null) this.boundingBox = new Box3();
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position !== undefined) {
            this.boundingBox.setFromBufferAttribute(position);
            // process morph attributes if present
            if (morphAttributesPosition) for(let i45 = 0, il = morphAttributesPosition.length; i45 < il; i45++){
                const morphAttribute = morphAttributesPosition[i45];
                _box$2.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                    _vector$4.addVectors(this.boundingBox.min, _box$2.min);
                    this.boundingBox.expandByPoint(_vector$4);
                    _vector$4.addVectors(this.boundingBox.max, _box$2.max);
                    this.boundingBox.expandByPoint(_vector$4);
                } else {
                    this.boundingBox.expandByPoint(_box$2.min);
                    this.boundingBox.expandByPoint(_box$2.max);
                }
            }
        } else this.boundingBox.makeEmpty();
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    },
    computeBoundingSphere: function() {
        if (this.boundingSphere === null) this.boundingSphere = new Sphere();
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position) {
            // first, find the center of the bounding sphere
            const center = this.boundingSphere.center;
            _box$2.setFromBufferAttribute(position);
            // process morph attributes if present
            if (morphAttributesPosition) for(let i48 = 0, il = morphAttributesPosition.length; i48 < il; i48++){
                const morphAttribute = morphAttributesPosition[i48];
                _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                    _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);
                    _box$2.expandByPoint(_vector$4);
                    _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);
                    _box$2.expandByPoint(_vector$4);
                } else {
                    _box$2.expandByPoint(_boxMorphTargets.min);
                    _box$2.expandByPoint(_boxMorphTargets.max);
                }
            }
            _box$2.getCenter(center);
            // second, try to find a boundingSphere with a radius smaller than the
            // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
            let maxRadiusSq = 0;
            for(let i46 = 0, il2 = position.count; i46 < il2; i46++){
                _vector$4.fromBufferAttribute(position, i46);
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
            }
            // process morph attributes if present
            if (morphAttributesPosition) for(let i47 = 0, il3 = morphAttributesPosition.length; i47 < il3; i47++){
                const morphAttribute = morphAttributesPosition[i47];
                const morphTargetsRelative = this.morphTargetsRelative;
                for(let j = 0, jl = morphAttribute.count; j < jl; j++){
                    _vector$4.fromBufferAttribute(morphAttribute, j);
                    if (morphTargetsRelative) {
                        _offset.fromBufferAttribute(position, j);
                        _vector$4.add(_offset);
                    }
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
                }
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
    },
    computeFaceNormals: function() {
    // backwards compatibility
    },
    computeVertexNormals: function() {
        const index = this.index;
        const positionAttribute = this.getAttribute('position');
        if (positionAttribute !== undefined) {
            let normalAttribute = this.getAttribute('normal');
            if (normalAttribute === undefined) {
                normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
                this.setAttribute('normal', normalAttribute);
            } else // reset existing normals to zero
            for(let i51 = 0, il = normalAttribute.count; i51 < il; i51++)normalAttribute.setXYZ(i51, 0, 0, 0);
            const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
            const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
            const cb = new Vector3(), ab = new Vector3();
            // indexed elements
            if (index) for(let i49 = 0, il4 = index.count; i49 < il4; i49 += 3){
                const vA = index.getX(i49 + 0);
                const vB = index.getX(i49 + 1);
                const vC = index.getX(i49 + 2);
                pA.fromBufferAttribute(positionAttribute, vA);
                pB.fromBufferAttribute(positionAttribute, vB);
                pC.fromBufferAttribute(positionAttribute, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                nA.fromBufferAttribute(normalAttribute, vA);
                nB.fromBufferAttribute(normalAttribute, vB);
                nC.fromBufferAttribute(normalAttribute, vC);
                nA.add(cb);
                nB.add(cb);
                nC.add(cb);
                normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
            }
            else // non-indexed elements (unconnected triangle soup)
            for(let i50 = 0, il5 = positionAttribute.count; i50 < il5; i50 += 3){
                pA.fromBufferAttribute(positionAttribute, i50 + 0);
                pB.fromBufferAttribute(positionAttribute, i50 + 1);
                pC.fromBufferAttribute(positionAttribute, i50 + 2);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normalAttribute.setXYZ(i50 + 0, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i50 + 1, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i50 + 2, cb.x, cb.y, cb.z);
            }
            this.normalizeNormals();
            normalAttribute.needsUpdate = true;
        }
    },
    merge: function(geometry, offset) {
        if (!(geometry && geometry.isBufferGeometry)) {
            console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
            return;
        }
        if (offset === undefined) {
            offset = 0;
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
        }
        const attributes = this.attributes;
        for(const key in attributes){
            if (geometry.attributes[key] === undefined) continue;
            const attribute1 = attributes[key];
            const attributeArray1 = attribute1.array;
            const attribute2 = geometry.attributes[key];
            const attributeArray2 = attribute2.array;
            const attributeOffset = attribute2.itemSize * offset;
            const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
            for(let i52 = 0, j = attributeOffset; i52 < length; i52++, j++)attributeArray1[j] = attributeArray2[i52];
        }
        return this;
    },
    normalizeNormals: function() {
        const normals = this.attributes.normal;
        for(let i53 = 0, il = normals.count; i53 < il; i53++){
            _vector$4.fromBufferAttribute(normals, i53);
            _vector$4.normalize();
            normals.setXYZ(i53, _vector$4.x, _vector$4.y, _vector$4.z);
        }
    },
    toNonIndexed: function() {
        function convertBufferAttribute(attribute, indices) {
            const array = attribute.array;
            const itemSize = attribute.itemSize;
            const normalized = attribute.normalized;
            const array2 = new array.constructor(indices.length * itemSize);
            let index = 0, index2 = 0;
            for(let i55 = 0, l = indices.length; i55 < l; i55++){
                index = indices[i55] * itemSize;
                for(let j = 0; j < itemSize; j++)array2[index2++] = array[index++];
            }
            return new BufferAttribute(array2, itemSize, normalized);
        }
        //
        if (this.index === null) {
            console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
            return this;
        }
        const geometry2 = new BufferGeometry();
        const indices1 = this.index.array;
        const attributes = this.attributes;
        // attributes
        for(const name in attributes){
            const attribute = attributes[name];
            const newAttribute = convertBufferAttribute(attribute, indices1);
            geometry2.setAttribute(name, newAttribute);
        }
        // morph attributes
        const morphAttributes = this.morphAttributes;
        for(const name1 in morphAttributes){
            const morphArray = [];
            const morphAttribute = morphAttributes[name1]; // morphAttribute: array of Float32BufferAttributes
            for(let i56 = 0, il = morphAttribute.length; i56 < il; i56++){
                const attribute = morphAttribute[i56];
                const newAttribute = convertBufferAttribute(attribute, indices1);
                morphArray.push(newAttribute);
            }
            geometry2.morphAttributes[name1] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;
        // groups
        const groups = this.groups;
        for(let i54 = 0, l2 = groups.length; i54 < l2; i54++){
            const group = groups[i54];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
    },
    toJSON: function() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'BufferGeometry',
                generator: 'BufferGeometry.toJSON'
            }
        };
        // standard BufferGeometry serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '') data.name = this.name;
        if (Object.keys(this.userData).length > 0) data.userData = this.userData;
        if (this.parameters !== undefined) {
            const parameters = this.parameters;
            for(const key in parameters)if (parameters[key] !== undefined) data[key] = parameters[key];
            return data;
        }
        data.data = {
            attributes: {}
        };
        const index = this.index;
        if (index !== null) data.data.index = {
            type: index.array.constructor.name,
            array: Array.prototype.slice.call(index.array)
        };
        const attributes = this.attributes;
        for(const key in attributes){
            const attribute = attributes[key];
            const attributeData = attribute.toJSON(data.data);
            if (attribute.name !== '') attributeData.name = attribute.name;
            data.data.attributes[key] = attributeData;
        }
        const morphAttributes = {};
        let hasMorphAttributes = false;
        for(const key1 in this.morphAttributes){
            const attributeArray = this.morphAttributes[key1];
            const array = [];
            for(let i57 = 0, il = attributeArray.length; i57 < il; i57++){
                const attribute = attributeArray[i57];
                const attributeData = attribute.toJSON(data.data);
                if (attribute.name !== '') attributeData.name = attribute.name;
                array.push(attributeData);
            }
            if (array.length > 0) {
                morphAttributes[key1] = array;
                hasMorphAttributes = true;
            }
        }
        if (hasMorphAttributes) {
            data.data.morphAttributes = morphAttributes;
            data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        const groups = this.groups;
        if (groups.length > 0) data.data.groups = JSON.parse(JSON.stringify(groups));
        const boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
        };
        return data;
    },
    clone: function() {
        /*
		 // Handle primitives

		 const parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 const values = [];

		 for ( const key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 const geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */ return new BufferGeometry().copy(this);
    },
    copy: function(source) {
        // reset
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        // used for storing cloned, shared data
        const data = {};
        // name
        this.name = source.name;
        // index
        const index = source.index;
        if (index !== null) this.setIndex(index.clone(data));
        // attributes
        const attributes = source.attributes;
        for(const name in attributes){
            const attribute = attributes[name];
            this.setAttribute(name, attribute.clone(data));
        }
        // morph attributes
        const morphAttributes = source.morphAttributes;
        for(const name2 in morphAttributes){
            const array = [];
            const morphAttribute = morphAttributes[name2]; // morphAttribute: array of Float32BufferAttributes
            for(let i58 = 0, l = morphAttribute.length; i58 < l; i58++)array.push(morphAttribute[i58].clone(data));
            this.morphAttributes[name2] = array;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;
        // groups
        const groups = source.groups;
        for(let i59 = 0, l = groups.length; i59 < l; i59++){
            const group = groups[i59];
            this.addGroup(group.start, group.count, group.materialIndex);
        }
        // bounding box
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) this.boundingBox = boundingBox.clone();
        // bounding sphere
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) this.boundingSphere = boundingSphere.clone();
        // draw range
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        // user data
        this.userData = source.userData;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */ const _inverseMatrix = new Matrix4();
const _ray = new Ray();
const _sphere = new Sphere();
const _vA = new Vector3();
const _vB = new Vector3();
const _vC = new Vector3();
const _tempA = new Vector3();
const _tempB = new Vector3();
const _tempC = new Vector3();
const _morphA = new Vector3();
const _morphB = new Vector3();
const _morphC = new Vector3();
const _uvA = new Vector2();
const _uvB = new Vector2();
const _uvC = new Vector2();
const _intersectionPoint = new Vector3();
const _intersectionPointWorld = new Vector3();
function Mesh(geometry, material) {
    Object3D.call(this);
    this.type = 'Mesh';
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new MeshBasicMaterial();
    this.updateMorphTargets();
}
Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Mesh,
    isMesh: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        if (source.morphTargetInfluences !== undefined) this.morphTargetInfluences = source.morphTargetInfluences.slice();
        if (source.morphTargetDictionary !== undefined) this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    },
    updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    },
    raycast: function(raycaster, intersects1) {
        const geometry = this.geometry;
        const material = this.material;
        const matrixWorld = this.matrixWorld;
        if (material === undefined) return;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere.copy(geometry.boundingSphere);
        _sphere.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere) === false) return;
        //
        _inverseMatrix.getInverse(matrixWorld);
        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
        // Check boundingBox before continuing
        if (geometry.boundingBox !== null) {
            if (_ray.intersectsBox(geometry.boundingBox) === false) return;
        }
        let intersection;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const position = geometry.attributes.position;
            const morphPosition = geometry.morphAttributes.position;
            const morphTargetsRelative = geometry.morphTargetsRelative;
            const uv = geometry.attributes.uv;
            const uv2 = geometry.attributes.uv2;
            const groups = geometry.groups;
            const drawRange = geometry.drawRange;
            if (index !== null) {
                // indexed buffer geometry
                if (Array.isArray(material)) for(let i60 = 0, il = groups.length; i60 < il; i60++){
                    const group = groups[i60];
                    const groupMaterial = material[group.materialIndex];
                    const start = Math.max(group.start, drawRange.start);
                    const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                    for(let j = start, jl = end; j < jl; j += 3){
                        const a = index.getX(j);
                        const b = index.getX(j + 1);
                        const c = index.getX(j + 2);
                        intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                            intersection.face.materialIndex = group.materialIndex;
                            intersects1.push(intersection);
                        }
                    }
                }
                else {
                    const start = Math.max(0, drawRange.start);
                    const end = Math.min(index.count, drawRange.start + drawRange.count);
                    for(let i61 = start, il = end; i61 < il; i61 += 3){
                        const a = index.getX(i61);
                        const b = index.getX(i61 + 1);
                        const c = index.getX(i61 + 2);
                        intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i61 / 3); // triangle number in indexed buffer semantics
                            intersects1.push(intersection);
                        }
                    }
                }
            } else if (position !== undefined) {
                // non-indexed buffer geometry
                if (Array.isArray(material)) for(let i62 = 0, il = groups.length; i62 < il; i62++){
                    const group = groups[i62];
                    const groupMaterial = material[group.materialIndex];
                    const start = Math.max(group.start, drawRange.start);
                    const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                    for(let j = start, jl = end; j < jl; j += 3){
                        const a = j;
                        const b = j + 1;
                        const c = j + 2;
                        intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
                            intersection.face.materialIndex = group.materialIndex;
                            intersects1.push(intersection);
                        }
                    }
                }
                else {
                    const start = Math.max(0, drawRange.start);
                    const end = Math.min(position.count, drawRange.start + drawRange.count);
                    for(let i63 = start, il = end; i63 < il; i63 += 3){
                        const a = i63;
                        const b = i63 + 1;
                        const c = i63 + 2;
                        intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i63 / 3); // triangle number in non-indexed buffer semantics
                            intersects1.push(intersection);
                        }
                    }
                }
            }
        } else if (geometry.isGeometry) {
            const isMultiMaterial = Array.isArray(material);
            const vertices = geometry.vertices;
            const faces = geometry.faces;
            let uvs;
            const faceVertexUvs = geometry.faceVertexUvs[0];
            if (faceVertexUvs.length > 0) uvs = faceVertexUvs;
            for(let f = 0, fl = faces.length; f < fl; f++){
                const face = faces[f];
                const faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
                if (faceMaterial === undefined) continue;
                const fvA = vertices[face.a];
                const fvB = vertices[face.b];
                const fvC = vertices[face.c];
                intersection = checkIntersection(this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint);
                if (intersection) {
                    if (uvs && uvs[f]) {
                        const uvs_f = uvs[f];
                        _uvA.copy(uvs_f[0]);
                        _uvB.copy(uvs_f[1]);
                        _uvC.copy(uvs_f[2]);
                        intersection.uv = Triangle.getUV(_intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2());
                    }
                    intersection.face = face;
                    intersection.faceIndex = f;
                    intersects1.push(intersection);
                }
            }
        }
    }
});
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    else intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
    if (intersect === null) return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far) return null;
    return {
        distance: distance,
        point: _intersectionPointWorld.clone(),
        object: object
    };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
    _vA.fromBufferAttribute(position, a);
    _vB.fromBufferAttribute(position, b);
    _vC.fromBufferAttribute(position, c);
    const morphInfluences = object.morphTargetInfluences;
    if (material.morphTargets && morphPosition && morphInfluences) {
        _morphA.set(0, 0, 0);
        _morphB.set(0, 0, 0);
        _morphC.set(0, 0, 0);
        for(let i64 = 0, il = morphPosition.length; i64 < il; i64++){
            const influence = morphInfluences[i64];
            const morphAttribute = morphPosition[i64];
            if (influence === 0) continue;
            _tempA.fromBufferAttribute(morphAttribute, a);
            _tempB.fromBufferAttribute(morphAttribute, b);
            _tempC.fromBufferAttribute(morphAttribute, c);
            if (morphTargetsRelative) {
                _morphA.addScaledVector(_tempA, influence);
                _morphB.addScaledVector(_tempB, influence);
                _morphC.addScaledVector(_tempC, influence);
            } else {
                _morphA.addScaledVector(_tempA.sub(_vA), influence);
                _morphB.addScaledVector(_tempB.sub(_vB), influence);
                _morphC.addScaledVector(_tempC.sub(_vC), influence);
            }
        }
        _vA.add(_morphA);
        _vB.add(_morphB);
        _vC.add(_morphC);
    }
    if (object.isSkinnedMesh) {
        object.boneTransform(a, _vA);
        object.boneTransform(b, _vB);
        object.boneTransform(c, _vC);
    }
    const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);
    if (intersection) {
        if (uv) {
            _uvA.fromBufferAttribute(uv, a);
            _uvB.fromBufferAttribute(uv, b);
            _uvC.fromBufferAttribute(uv, c);
            intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
        }
        if (uv2) {
            _uvA.fromBufferAttribute(uv2, a);
            _uvB.fromBufferAttribute(uv2, b);
            _uvC.fromBufferAttribute(uv2, c);
            intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
        }
        const face = new Face3(a, b, c);
        Triangle.getNormal(_vA, _vB, _vC, face.normal);
        intersection.face = face;
    }
    return intersection;
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */ let _geometryId = 0; // Geometry uses even numbers as Id
const _m1$3 = new Matrix4();
const _obj$1 = new Object3D();
const _offset$1 = new Vector3();
function Geometry() {
    Object.defineProperty(this, 'id', {
        value: _geometryId += 2
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'Geometry';
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [
        []
    ];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    // update flags
    this.elementsNeedUpdate = false;
    this.verticesNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;
}
Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Geometry,
    isGeometry: true,
    applyMatrix4: function(matrix) {
        const normalMatrix = new Matrix3().getNormalMatrix(matrix);
        for(let i66 = 0, il = this.vertices.length; i66 < il; i66++){
            const vertex = this.vertices[i66];
            vertex.applyMatrix4(matrix);
        }
        for(let i65 = 0, il6 = this.faces.length; i65 < il6; i65++){
            const face = this.faces[i65];
            face.normal.applyMatrix3(normalMatrix).normalize();
            for(let j = 0, jl = face.vertexNormals.length; j < jl; j++)face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
        }
        if (this.boundingBox !== null) this.computeBoundingBox();
        if (this.boundingSphere !== null) this.computeBoundingSphere();
        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;
        return this;
    },
    rotateX: function(angle) {
        // rotate geometry around world x-axis
        _m1$3.makeRotationX(angle);
        this.applyMatrix4(_m1$3);
        return this;
    },
    rotateY: function(angle) {
        // rotate geometry around world y-axis
        _m1$3.makeRotationY(angle);
        this.applyMatrix4(_m1$3);
        return this;
    },
    rotateZ: function(angle) {
        // rotate geometry around world z-axis
        _m1$3.makeRotationZ(angle);
        this.applyMatrix4(_m1$3);
        return this;
    },
    translate: function(x, y, z) {
        // translate geometry
        _m1$3.makeTranslation(x, y, z);
        this.applyMatrix4(_m1$3);
        return this;
    },
    scale: function(x, y, z) {
        // scale geometry
        _m1$3.makeScale(x, y, z);
        this.applyMatrix4(_m1$3);
        return this;
    },
    lookAt: function(vector) {
        _obj$1.lookAt(vector);
        _obj$1.updateMatrix();
        this.applyMatrix4(_obj$1.matrix);
        return this;
    },
    fromBufferGeometry: function(geometry) {
        const scope = this;
        const index = geometry.index !== null ? geometry.index : undefined;
        const attributes = geometry.attributes;
        if (attributes.position === undefined) {
            console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');
            return this;
        }
        const position = attributes.position;
        const normal = attributes.normal;
        const color = attributes.color;
        const uv = attributes.uv;
        const uv2 = attributes.uv2;
        if (uv2 !== undefined) this.faceVertexUvs[1] = [];
        for(let i68 = 0; i68 < position.count; i68++){
            scope.vertices.push(new Vector3().fromBufferAttribute(position, i68));
            if (color !== undefined) scope.colors.push(new Color().fromBufferAttribute(color, i68));
        }
        function addFace(a, b, c, materialIndex) {
            const vertexColors = color === undefined ? [] : [
                scope.colors[a].clone(),
                scope.colors[b].clone(),
                scope.colors[c].clone()
            ];
            const vertexNormals = normal === undefined ? [] : [
                new Vector3().fromBufferAttribute(normal, a),
                new Vector3().fromBufferAttribute(normal, b),
                new Vector3().fromBufferAttribute(normal, c)
            ];
            const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
            scope.faces.push(face);
            if (uv !== undefined) scope.faceVertexUvs[0].push([
                new Vector2().fromBufferAttribute(uv, a),
                new Vector2().fromBufferAttribute(uv, b),
                new Vector2().fromBufferAttribute(uv, c)
            ]);
            if (uv2 !== undefined) scope.faceVertexUvs[1].push([
                new Vector2().fromBufferAttribute(uv2, a),
                new Vector2().fromBufferAttribute(uv2, b),
                new Vector2().fromBufferAttribute(uv2, c)
            ]);
        }
        const groups = geometry.groups;
        if (groups.length > 0) for(let i67 = 0; i67 < groups.length; i67++){
            const group = groups[i67];
            const start = group.start;
            const count = group.count;
            for(let j = start, jl = start + count; j < jl; j += 3)if (index !== undefined) addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);
            else addFace(j, j + 1, j + 2, group.materialIndex);
        }
        else {
            if (index !== undefined) for(let i70 = 0; i70 < index.count; i70 += 3)addFace(index.getX(i70), index.getX(i70 + 1), index.getX(i70 + 2));
            else for(let i69 = 0; i69 < position.count; i69 += 3)addFace(i69, i69 + 1, i69 + 2);
        }
        this.computeFaceNormals();
        if (geometry.boundingBox !== null) this.boundingBox = geometry.boundingBox.clone();
        if (geometry.boundingSphere !== null) this.boundingSphere = geometry.boundingSphere.clone();
        return this;
    },
    center: function() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset$1).negate();
        this.translate(_offset$1.x, _offset$1.y, _offset$1.z);
        return this;
    },
    normalize: function() {
        this.computeBoundingSphere();
        const center = this.boundingSphere.center;
        const radius = this.boundingSphere.radius;
        const s = radius === 0 ? 1 : 1 / radius;
        const matrix = new Matrix4();
        matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
        this.applyMatrix4(matrix);
        return this;
    },
    computeFaceNormals: function() {
        const cb = new Vector3(), ab = new Vector3();
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            const vA = this.vertices[face.a];
            const vB = this.vertices[face.b];
            const vC = this.vertices[face.c];
            cb.subVectors(vC, vB);
            ab.subVectors(vA, vB);
            cb.cross(ab);
            cb.normalize();
            face.normal.copy(cb);
        }
    },
    computeVertexNormals: function(areaWeighted) {
        if (areaWeighted === undefined) areaWeighted = true;
        const vertices = new Array(this.vertices.length);
        for(let v = 0, vl = this.vertices.length; v < vl; v++)vertices[v] = new Vector3();
        if (areaWeighted) {
            // vertex normals weighted by triangle areas
            // http://www.iquilezles.org/www/articles/normals/normals.htm
            const cb = new Vector3(), ab = new Vector3();
            for(let f = 0, fl = this.faces.length; f < fl; f++){
                const face = this.faces[f];
                const vA = this.vertices[face.a];
                const vB = this.vertices[face.b];
                const vC = this.vertices[face.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                vertices[face.a].add(cb);
                vertices[face.b].add(cb);
                vertices[face.c].add(cb);
            }
        } else {
            this.computeFaceNormals();
            for(let f = 0, fl = this.faces.length; f < fl; f++){
                const face = this.faces[f];
                vertices[face.a].add(face.normal);
                vertices[face.b].add(face.normal);
                vertices[face.c].add(face.normal);
            }
        }
        for(let v3 = 0, vl1 = this.vertices.length; v3 < vl1; v3++)vertices[v3].normalize();
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            const vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                vertexNormals[0].copy(vertices[face.a]);
                vertexNormals[1].copy(vertices[face.b]);
                vertexNormals[2].copy(vertices[face.c]);
            } else {
                vertexNormals[0] = vertices[face.a].clone();
                vertexNormals[1] = vertices[face.b].clone();
                vertexNormals[2] = vertices[face.c].clone();
            }
        }
        if (this.faces.length > 0) this.normalsNeedUpdate = true;
    },
    computeFlatVertexNormals: function() {
        this.computeFaceNormals();
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            const vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                vertexNormals[0].copy(face.normal);
                vertexNormals[1].copy(face.normal);
                vertexNormals[2].copy(face.normal);
            } else {
                vertexNormals[0] = face.normal.clone();
                vertexNormals[1] = face.normal.clone();
                vertexNormals[2] = face.normal.clone();
            }
        }
        if (this.faces.length > 0) this.normalsNeedUpdate = true;
    },
    computeMorphNormals: function() {
        // save original normals
        // - create temp variables on first access
        //   otherwise just copy (for faster repeated calls)
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            if (!face.__originalFaceNormal) face.__originalFaceNormal = face.normal.clone();
            else face.__originalFaceNormal.copy(face.normal);
            if (!face.__originalVertexNormals) face.__originalVertexNormals = [];
            for(let i71 = 0, il = face.vertexNormals.length; i71 < il; i71++)if (!face.__originalVertexNormals[i71]) face.__originalVertexNormals[i71] = face.vertexNormals[i71].clone();
            else face.__originalVertexNormals[i71].copy(face.vertexNormals[i71]);
        }
        // use temp geometry to compute face and vertex normals for each morph
        const tmpGeo = new Geometry();
        tmpGeo.faces = this.faces;
        for(let i72 = 0, il = this.morphTargets.length; i72 < il; i72++){
            // create on first access
            if (!this.morphNormals[i72]) {
                this.morphNormals[i72] = {};
                this.morphNormals[i72].faceNormals = [];
                this.morphNormals[i72].vertexNormals = [];
                const dstNormalsFace = this.morphNormals[i72].faceNormals;
                const dstNormalsVertex = this.morphNormals[i72].vertexNormals;
                for(let f = 0, fl = this.faces.length; f < fl; f++){
                    const faceNormal = new Vector3();
                    const vertexNormals = {
                        a: new Vector3(),
                        b: new Vector3(),
                        c: new Vector3()
                    };
                    dstNormalsFace.push(faceNormal);
                    dstNormalsVertex.push(vertexNormals);
                }
            }
            const morphNormals = this.morphNormals[i72];
            // set vertices to morph target
            tmpGeo.vertices = this.morphTargets[i72].vertices;
            // compute morph normals
            tmpGeo.computeFaceNormals();
            tmpGeo.computeVertexNormals();
            // store morph normals
            for(let f = 0, fl = this.faces.length; f < fl; f++){
                const face = this.faces[f];
                const faceNormal = morphNormals.faceNormals[f];
                const vertexNormals = morphNormals.vertexNormals[f];
                faceNormal.copy(face.normal);
                vertexNormals.a.copy(face.vertexNormals[0]);
                vertexNormals.b.copy(face.vertexNormals[1]);
                vertexNormals.c.copy(face.vertexNormals[2]);
            }
        }
        // restore original normals
        for(let f1 = 0, fl1 = this.faces.length; f1 < fl1; f1++){
            const face = this.faces[f1];
            face.normal = face.__originalFaceNormal;
            face.vertexNormals = face.__originalVertexNormals;
        }
    },
    computeBoundingBox: function() {
        if (this.boundingBox === null) this.boundingBox = new Box3();
        this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
        if (this.boundingSphere === null) this.boundingSphere = new Sphere();
        this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(geometry, matrix, materialIndexOffset) {
        if (!(geometry && geometry.isGeometry)) {
            console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
            return;
        }
        let normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;
        if (materialIndexOffset === undefined) materialIndexOffset = 0;
        if (matrix !== undefined) normalMatrix = new Matrix3().getNormalMatrix(matrix);
        // vertices
        for(let i76 = 0, il = vertices2.length; i76 < il; i76++){
            const vertex = vertices2[i76];
            const vertexCopy = vertex.clone();
            if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
            vertices1.push(vertexCopy);
        }
        // colors
        for(let i73 = 0, il7 = colors2.length; i73 < il7; i73++)colors1.push(colors2[i73].clone());
        // faces
        for(let i74 = 0, il8 = faces2.length; i74 < il8; i74++){
            let face = faces2[i74], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
            faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
            faceCopy.normal.copy(face.normal);
            if (normalMatrix !== undefined) faceCopy.normal.applyMatrix3(normalMatrix).normalize();
            for(let j = 0, jl = faceVertexNormals.length; j < jl; j++){
                normal = faceVertexNormals[j].clone();
                if (normalMatrix !== undefined) normal.applyMatrix3(normalMatrix).normalize();
                faceCopy.vertexNormals.push(normal);
            }
            faceCopy.color.copy(face.color);
            for(let j2 = 0, jl1 = faceVertexColors.length; j2 < jl1; j2++){
                color = faceVertexColors[j2];
                faceCopy.vertexColors.push(color.clone());
            }
            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
            faces1.push(faceCopy);
        }
        // uvs
        for(let i75 = 0, il9 = geometry.faceVertexUvs.length; i75 < il9; i75++){
            const faceVertexUvs2 = geometry.faceVertexUvs[i75];
            if (this.faceVertexUvs[i75] === undefined) this.faceVertexUvs[i75] = [];
            for(let j = 0, jl = faceVertexUvs2.length; j < jl; j++){
                const uvs2 = faceVertexUvs2[j], uvsCopy = [];
                for(let k = 0, kl = uvs2.length; k < kl; k++)uvsCopy.push(uvs2[k].clone());
                this.faceVertexUvs[i75].push(uvsCopy);
            }
        }
    },
    mergeMesh: function(mesh) {
        if (!(mesh && mesh.isMesh)) {
            console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
            return;
        }
        if (mesh.matrixAutoUpdate) mesh.updateMatrix();
        this.merge(mesh.geometry, mesh.matrix);
    },
    /*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */ mergeVertices: function() {
        const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
        const unique = [], changes = [];
        const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        const precision = Math.pow(10, precisionPoints);
        for(let i79 = 0, il = this.vertices.length; i79 < il; i79++){
            const v = this.vertices[i79];
            const key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
            if (verticesMap[key] === undefined) {
                verticesMap[key] = i79;
                unique.push(this.vertices[i79]);
                changes[i79] = unique.length - 1;
            } else //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
            changes[i79] = changes[verticesMap[key]];
        }
        // if faces are completely degenerate after merging vertices, we
        // have to remove them from the geometry.
        const faceIndicesToRemove = [];
        for(let i77 = 0, il10 = this.faces.length; i77 < il10; i77++){
            const face = this.faces[i77];
            face.a = changes[face.a];
            face.b = changes[face.b];
            face.c = changes[face.c];
            const indices = [
                face.a,
                face.b,
                face.c
            ];
            // if any duplicate vertices are found in a Face3
            // we have to remove the face as nothing can be saved
            for(let n = 0; n < 3; n++)if (indices[n] === indices[(n + 1) % 3]) {
                faceIndicesToRemove.push(i77);
                break;
            }
        }
        for(let i78 = faceIndicesToRemove.length - 1; i78 >= 0; i78--){
            const idx = faceIndicesToRemove[i78];
            this.faces.splice(idx, 1);
            for(let j = 0, jl = this.faceVertexUvs.length; j < jl; j++)this.faceVertexUvs[j].splice(idx, 1);
        }
        // Use unique set of vertices
        const diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;
    },
    setFromPoints: function(points) {
        this.vertices = [];
        for(let i80 = 0, l = points.length; i80 < l; i80++){
            const point = points[i80];
            this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
        }
        return this;
    },
    sortFacesByMaterialIndex: function() {
        const faces = this.faces;
        const length = faces.length;
        // tag faces
        for(let i82 = 0; i82 < length; i82++)faces[i82]._id = i82;
        // sort faces
        function materialIndexSort(a, b) {
            return a.materialIndex - b.materialIndex;
        }
        faces.sort(materialIndexSort);
        // sort uvs
        const uvs1 = this.faceVertexUvs[0];
        const uvs2 = this.faceVertexUvs[1];
        let newUvs1, newUvs2;
        if (uvs1 && uvs1.length === length) newUvs1 = [];
        if (uvs2 && uvs2.length === length) newUvs2 = [];
        for(let i81 = 0; i81 < length; i81++){
            const id = faces[i81]._id;
            if (newUvs1) newUvs1.push(uvs1[id]);
            if (newUvs2) newUvs2.push(uvs2[id]);
        }
        if (newUvs1) this.faceVertexUvs[0] = newUvs1;
        if (newUvs2) this.faceVertexUvs[1] = newUvs2;
    },
    toJSON: function() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'Geometry',
                generator: 'Geometry.toJSON'
            }
        };
        // standard Geometry serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '') data.name = this.name;
        if (this.parameters !== undefined) {
            const parameters = this.parameters;
            for(const key in parameters)if (parameters[key] !== undefined) data[key] = parameters[key];
            return data;
        }
        const vertices = [];
        for(let i84 = 0; i84 < this.vertices.length; i84++){
            const vertex = this.vertices[i84];
            vertices.push(vertex.x, vertex.y, vertex.z);
        }
        const faces = [];
        const normals = [];
        const normalsHash = {};
        const colors = [];
        const colorsHash = {};
        const uvs = [];
        const uvsHash = {};
        for(let i83 = 0; i83 < this.faces.length; i83++){
            const face = this.faces[i83];
            const hasMaterial = true;
            const hasFaceUv = false; // deprecated
            const hasFaceVertexUv = this.faceVertexUvs[0][i83] !== undefined;
            const hasFaceNormal = face.normal.length() > 0;
            const hasFaceVertexNormal = face.vertexNormals.length > 0;
            const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
            const hasFaceVertexColor = face.vertexColors.length > 0;
            let faceType = 0;
            faceType = setBit(faceType, 0, 0); // isQuad
            faceType = setBit(faceType, 1, hasMaterial);
            faceType = setBit(faceType, 2, hasFaceUv);
            faceType = setBit(faceType, 3, hasFaceVertexUv);
            faceType = setBit(faceType, 4, hasFaceNormal);
            faceType = setBit(faceType, 5, hasFaceVertexNormal);
            faceType = setBit(faceType, 6, hasFaceColor);
            faceType = setBit(faceType, 7, hasFaceVertexColor);
            faces.push(faceType);
            faces.push(face.a, face.b, face.c);
            faces.push(face.materialIndex);
            if (hasFaceVertexUv) {
                const faceVertexUvs = this.faceVertexUvs[0][i83];
                faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
            }
            if (hasFaceNormal) faces.push(getNormalIndex(face.normal));
            if (hasFaceVertexNormal) {
                const vertexNormals = face.vertexNormals;
                faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
            }
            if (hasFaceColor) faces.push(getColorIndex(face.color));
            if (hasFaceVertexColor) {
                const vertexColors = face.vertexColors;
                faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
            }
        }
        function setBit(value, position, enabled) {
            return enabled ? value | 1 << position : value & ~(1 << position);
        }
        function getNormalIndex(normal) {
            const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
            if (normalsHash[hash] !== undefined) return normalsHash[hash];
            normalsHash[hash] = normals.length / 3;
            normals.push(normal.x, normal.y, normal.z);
            return normalsHash[hash];
        }
        function getColorIndex(color) {
            const hash = color.r.toString() + color.g.toString() + color.b.toString();
            if (colorsHash[hash] !== undefined) return colorsHash[hash];
            colorsHash[hash] = colors.length;
            colors.push(color.getHex());
            return colorsHash[hash];
        }
        function getUvIndex(uv) {
            const hash = uv.x.toString() + uv.y.toString();
            if (uvsHash[hash] !== undefined) return uvsHash[hash];
            uvsHash[hash] = uvs.length / 2;
            uvs.push(uv.x, uv.y);
            return uvsHash[hash];
        }
        data.data = {};
        data.data.vertices = vertices;
        data.data.normals = normals;
        if (colors.length > 0) data.data.colors = colors;
        if (uvs.length > 0) data.data.uvs = [
            uvs
        ]; // temporal backward compatibility
        data.data.faces = faces;
        return data;
    },
    clone: function() {
        /*
		 // Handle primitives

		 const parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 const values = [];

		 for ( const key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 const geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */ return new Geometry().copy(this);
    },
    copy: function(source) {
        // reset
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [
            []
        ];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        // name
        this.name = source.name;
        // vertices
        const vertices = source.vertices;
        for(let i93 = 0, il = vertices.length; i93 < il; i93++)this.vertices.push(vertices[i93].clone());
        // colors
        const colors = source.colors;
        for(let i85 = 0, il11 = colors.length; i85 < il11; i85++)this.colors.push(colors[i85].clone());
        // faces
        const faces = source.faces;
        for(let i86 = 0, il12 = faces.length; i86 < il12; i86++)this.faces.push(faces[i86].clone());
        // face vertex uvs
        for(let i87 = 0, il13 = source.faceVertexUvs.length; i87 < il13; i87++){
            const faceVertexUvs = source.faceVertexUvs[i87];
            if (this.faceVertexUvs[i87] === undefined) this.faceVertexUvs[i87] = [];
            for(let j = 0, jl = faceVertexUvs.length; j < jl; j++){
                const uvs = faceVertexUvs[j], uvsCopy = [];
                for(let k = 0, kl = uvs.length; k < kl; k++){
                    const uv = uvs[k];
                    uvsCopy.push(uv.clone());
                }
                this.faceVertexUvs[i87].push(uvsCopy);
            }
        }
        // morph targets
        const morphTargets = source.morphTargets;
        for(let i88 = 0, il14 = morphTargets.length; i88 < il14; i88++){
            const morphTarget = {};
            morphTarget.name = morphTargets[i88].name;
            // vertices
            if (morphTargets[i88].vertices !== undefined) {
                morphTarget.vertices = [];
                for(let j = 0, jl = morphTargets[i88].vertices.length; j < jl; j++)morphTarget.vertices.push(morphTargets[i88].vertices[j].clone());
            }
            // normals
            if (morphTargets[i88].normals !== undefined) {
                morphTarget.normals = [];
                for(let j = 0, jl = morphTargets[i88].normals.length; j < jl; j++)morphTarget.normals.push(morphTargets[i88].normals[j].clone());
            }
            this.morphTargets.push(morphTarget);
        }
        // morph normals
        const morphNormals = source.morphNormals;
        for(let i89 = 0, il15 = morphNormals.length; i89 < il15; i89++){
            const morphNormal = {};
            // vertex normals
            if (morphNormals[i89].vertexNormals !== undefined) {
                morphNormal.vertexNormals = [];
                for(let j = 0, jl = morphNormals[i89].vertexNormals.length; j < jl; j++){
                    const srcVertexNormal = morphNormals[i89].vertexNormals[j];
                    const destVertexNormal = {};
                    destVertexNormal.a = srcVertexNormal.a.clone();
                    destVertexNormal.b = srcVertexNormal.b.clone();
                    destVertexNormal.c = srcVertexNormal.c.clone();
                    morphNormal.vertexNormals.push(destVertexNormal);
                }
            }
            // face normals
            if (morphNormals[i89].faceNormals !== undefined) {
                morphNormal.faceNormals = [];
                for(let j = 0, jl = morphNormals[i89].faceNormals.length; j < jl; j++)morphNormal.faceNormals.push(morphNormals[i89].faceNormals[j].clone());
            }
            this.morphNormals.push(morphNormal);
        }
        // skin weights
        const skinWeights = source.skinWeights;
        for(let i90 = 0, il16 = skinWeights.length; i90 < il16; i90++)this.skinWeights.push(skinWeights[i90].clone());
        // skin indices
        const skinIndices = source.skinIndices;
        for(let i91 = 0, il17 = skinIndices.length; i91 < il17; i91++)this.skinIndices.push(skinIndices[i91].clone());
        // line distances
        const lineDistances = source.lineDistances;
        for(let i92 = 0, il18 = lineDistances.length; i92 < il18; i92++)this.lineDistances.push(lineDistances[i92]);
        // bounding box
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) this.boundingBox = boundingBox.clone();
        // bounding sphere
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) this.boundingSphere = boundingSphere.clone();
        // update flags
        this.elementsNeedUpdate = source.elementsNeedUpdate;
        this.verticesNeedUpdate = source.verticesNeedUpdate;
        this.uvsNeedUpdate = source.uvsNeedUpdate;
        this.normalsNeedUpdate = source.normalsNeedUpdate;
        this.colorsNeedUpdate = source.colorsNeedUpdate;
        this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
        this.groupsNeedUpdate = source.groupsNeedUpdate;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ // BoxGeometry
class BoxGeometry extends Geometry {
    constructor(width, height, depth, widthSegments, heightSegments, depthSegments){
        super();
        this.type = 'BoxGeometry';
        this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
        this.mergeVertices();
    }
}
// BoxBufferGeometry
class BoxBufferGeometry extends BufferGeometry {
    constructor(width1, height1, depth1, widthSegments, heightSegments, depthSegments){
        super();
        this.type = 'BoxBufferGeometry';
        this.parameters = {
            width: width1,
            height: height1,
            depth: depth1,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        const scope = this;
        width1 = width1 || 1;
        height1 = height1 || 1;
        depth1 = depth1 || 1;
        // segments
        widthSegments = Math.floor(widthSegments) || 1;
        heightSegments = Math.floor(heightSegments) || 1;
        depthSegments = Math.floor(depthSegments) || 1;
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        let numberOfVertices = 0;
        let groupStart = 0;
        // build each side of the box geometry
        buildPlane('z', 'y', 'x', -1, -1, depth1, height1, width1, depthSegments, heightSegments, 0); // px
        buildPlane('z', 'y', 'x', 1, -1, depth1, height1, -width1, depthSegments, heightSegments, 1); // nx
        buildPlane('x', 'z', 'y', 1, 1, width1, depth1, height1, widthSegments, depthSegments, 2); // py
        buildPlane('x', 'z', 'y', 1, -1, width1, depth1, -height1, widthSegments, depthSegments, 3); // ny
        buildPlane('x', 'y', 'z', 1, -1, width1, height1, depth1, widthSegments, heightSegments, 4); // pz
        buildPlane('x', 'y', 'z', -1, -1, width1, height1, -depth1, widthSegments, heightSegments, 5); // nz
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
            const segmentWidth = width / gridX;
            const segmentHeight = height / gridY;
            const widthHalf = width / 2;
            const heightHalf = height / 2;
            const depthHalf = depth / 2;
            const gridX1 = gridX + 1;
            const gridY1 = gridY + 1;
            let vertexCounter = 0;
            let groupCount = 0;
            const vector = new Vector3();
            // generate vertices, normals and uvs
            for(let iy = 0; iy < gridY1; iy++){
                const y = iy * segmentHeight - heightHalf;
                for(let ix = 0; ix < gridX1; ix++){
                    const x = ix * segmentWidth - widthHalf;
                    // set values to correct vector component
                    vector[u] = x * udir;
                    vector[v] = y * vdir;
                    vector[w] = depthHalf;
                    // now apply vector to vertex buffer
                    vertices.push(vector.x, vector.y, vector.z);
                    // set values to correct vector component
                    vector[u] = 0;
                    vector[v] = 0;
                    vector[w] = depth > 0 ? 1 : -1;
                    // now apply vector to normal buffer
                    normals.push(vector.x, vector.y, vector.z);
                    // uvs
                    uvs.push(ix / gridX);
                    uvs.push(1 - iy / gridY);
                    // counters
                    vertexCounter += 1;
                }
            }
            // indices
            // 1. you need three indices to draw a single face
            // 2. a single segment consists of two faces
            // 3. so we need to generate six (2*3) indices per segment
            for(let iy1 = 0; iy1 < gridY; iy1++)for(let ix = 0; ix < gridX; ix++){
                const a = numberOfVertices + ix + gridX1 * iy1;
                const b = numberOfVertices + ix + gridX1 * (iy1 + 1);
                const c = numberOfVertices + (ix + 1) + gridX1 * (iy1 + 1);
                const d = numberOfVertices + (ix + 1) + gridX1 * iy1;
                // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
                // increase counter
                groupCount += 6;
            }
            // add a group to the geometry. this will ensure multi material support
            scope.addGroup(groupStart, groupCount, materialIndex);
            // calculate new start value for groups
            groupStart += groupCount;
            // update total number of vertices
            numberOfVertices += vertexCounter;
        }
    }
}
/**
 * Uniform Utilities
 */ function cloneUniforms(src) {
    const dst = {};
    for(const u in src){
        dst[u] = {};
        for(const p in src[u]){
            const property = src[u][p];
            if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) dst[u][p] = property.clone();
            else if (Array.isArray(property)) dst[u][p] = property.slice();
            else dst[u][p] = property;
        }
    }
    return dst;
}
function mergeUniforms(uniforms) {
    const merged = {};
    for(let u = 0; u < uniforms.length; u++){
        const tmp3 = cloneUniforms(uniforms[u]);
        for(const p in tmp3)merged[p] = tmp3[p];
    }
    return merged;
}
// Legacy
const UniformsUtils = {
    clone: cloneUniforms,
    merge: mergeUniforms
};
var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function ShaderMaterial(parameters) {
    Material.call(this);
    this.type = 'ShaderMaterial';
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false; // set to use scene fog
    this.lights = false; // set to use scene lights
    this.clipping = false; // set to use user-defined clipping planes
    this.skinning = false; // set to use skinning attribute streams
    this.morphTargets = false; // set to use morph targets
    this.morphNormals = false; // set to use morph normals
    this.extensions = {
        derivatives: false,
        fragDepth: false,
        drawBuffers: false,
        shaderTextureLOD: false // set to use shader texture LOD
    };
    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    this.defaultAttributeValues = {
        'color': [
            1,
            1,
            1
        ],
        'uv': [
            0,
            0
        ],
        'uv2': [
            0,
            0
        ]
    };
    this.index0AttributeName = undefined;
    this.uniformsNeedUpdate = false;
    if (parameters !== undefined) {
        if (parameters.attributes !== undefined) console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
        this.setValues(parameters);
    }
}
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.extensions = Object.assign({}, source.extensions);
    return this;
};
ShaderMaterial.prototype.toJSON = function(meta) {
    const data = Material.prototype.toJSON.call(this, meta);
    data.uniforms = {};
    for(const name in this.uniforms){
        const uniform = this.uniforms[name];
        const value = uniform.value;
        if (value && value.isTexture) data.uniforms[name] = {
            type: 't',
            value: value.toJSON(meta).uuid
        };
        else if (value && value.isColor) data.uniforms[name] = {
            type: 'c',
            value: value.getHex()
        };
        else if (value && value.isVector2) data.uniforms[name] = {
            type: 'v2',
            value: value.toArray()
        };
        else if (value && value.isVector3) data.uniforms[name] = {
            type: 'v3',
            value: value.toArray()
        };
        else if (value && value.isVector4) data.uniforms[name] = {
            type: 'v4',
            value: value.toArray()
        };
        else if (value && value.isMatrix3) data.uniforms[name] = {
            type: 'm3',
            value: value.toArray()
        };
        else if (value && value.isMatrix4) data.uniforms[name] = {
            type: 'm4',
            value: value.toArray()
        };
        else data.uniforms[name] = {
            value: value
        };
    }
    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions = {};
    for(const key in this.extensions)if (this.extensions[key] === true) extensions[key] = true;
    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/ function Camera() {
    Object3D.call(this);
    this.type = 'Camera';
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
}
Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Camera,
    isCamera: true,
    copy: function(source, recursive) {
        Object3D.prototype.copy.call(this, source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        return this;
    },
    getWorldDirection: function(target) {
        if (target === undefined) {
            console.warn('THREE.Camera: .getWorldDirection() target is now required');
            target = new Vector3();
        }
        this.updateMatrixWorld(true);
        const e = this.matrixWorld.elements;
        return target.set(-e[8], -e[9], -e[10]).normalize();
    },
    updateMatrixWorld: function(force) {
        Object3D.prototype.updateMatrixWorld.call(this, force);
        this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
        Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
        this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    clone: function() {
        return new this.constructor().copy(this);
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */ function PerspectiveCamera(fov1, aspect1, near, far) {
    Camera.call(this);
    this.type = 'PerspectiveCamera';
    this.fov = fov1 !== undefined ? fov1 : 50;
    this.zoom = 1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.focus = 10;
    this.aspect = aspect1 !== undefined ? aspect1 : 1;
    this.view = null;
    this.filmGauge = 35; // width of the film (default in millimeters)
    this.filmOffset = 0; // horizontal film offset (same unit as gauge)
    this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
    constructor: PerspectiveCamera,
    isPerspectiveCamera: true,
    copy: function(source, recursive) {
        Camera.prototype.copy.call(this, source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
    },
    /**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */ setFocalLength: function(focalLength) {
        // see http://www.bobatkins.com/photography/technical/field_of_view.html
        const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
    },
    /**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */ getFocalLength: function() {
        const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
    },
    getEffectiveFOV: function() {
        return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
    },
    getFilmWidth: function() {
        // film not completely covered in portrait format (aspect < 1)
        return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function() {
        // film not completely covered in landscape format (aspect > 1)
        return this.filmGauge / Math.max(this.aspect, 1);
    },
    /**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */ setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
        let near = this.near, top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width, view = this.view;
        if (this.view !== null && this.view.enabled) {
            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width / fullWidth;
            top -= view.offsetY * height / fullHeight;
            width *= view.width / fullWidth;
            height *= view.height / fullHeight;
        }
        const skew = this.filmOffset;
        if (skew !== 0) left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null) data.object.view = Object.assign({}, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
    }
});
/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */ const fov = 90, aspect = 1;
function CubeCamera(near, far, renderTarget) {
    Object3D.call(this);
    this.type = 'CubeCamera';
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
        console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
        return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
    this.update = function(renderer, scene) {
        if (this.parent === null) this.updateMatrixWorld();
        const currentXrEnabled = renderer.xr.enabled;
        const currentRenderTarget = renderer.getRenderTarget();
        renderer.xr.enabled = false;
        const generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderer.setRenderTarget(renderTarget, 0);
        renderer.render(scene, cameraPX);
        renderer.setRenderTarget(renderTarget, 1);
        renderer.render(scene, cameraNX);
        renderer.setRenderTarget(renderTarget, 2);
        renderer.render(scene, cameraPY);
        renderer.setRenderTarget(renderTarget, 3);
        renderer.render(scene, cameraNY);
        renderer.setRenderTarget(renderTarget, 4);
        renderer.render(scene, cameraPZ);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderer.setRenderTarget(renderTarget, 5);
        renderer.render(scene, cameraNZ);
        renderer.setRenderTarget(currentRenderTarget);
        renderer.xr.enabled = currentXrEnabled;
    };
    this.clear = function(renderer, color, depth, stencil) {
        const currentRenderTarget = renderer.getRenderTarget();
        for(let i94 = 0; i94 < 6; i94++){
            renderer.setRenderTarget(renderTarget, i94);
            renderer.clear(color, depth, stencil);
        }
        renderer.setRenderTarget(currentRenderTarget);
    };
}
CubeCamera.prototype = Object.create(Object3D.prototype);
CubeCamera.prototype.constructor = CubeCamera;
/**
 * @author alteredq / http://alteredqualia.com
 * @author WestLangley / http://github.com/WestLangley
 */ function WebGLCubeRenderTarget(size, options, dummy) {
    if (Number.isInteger(options)) {
        console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
        options = dummy;
    }
    WebGLRenderTarget.call(this, size, size, options);
}
WebGLCubeRenderTarget.prototype = Object.create(WebGLRenderTarget.prototype);
WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = texture.format;
    this.texture.encoding = texture.encoding;
    const scene = new Scene();
    const shader = {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: [
            "varying vec3 vWorldDirection;",
            "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",
            "	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",
            "}",
            "void main() {",
            "	vWorldDirection = transformDirection( position, modelMatrix );",
            "	#include <begin_vertex>",
            "	#include <project_vertex>",
            "}"
        ].join('\n'),
        fragmentShader: [
            "uniform sampler2D tEquirect;",
            "varying vec3 vWorldDirection;",
            "#include <common>",
            "void main() {",
            "	vec3 direction = normalize( vWorldDirection );",
            "	vec2 sampleUV = equirectUv( direction );",
            "	gl_FragColor = texture2D( tEquirect, sampleUV );",
            "}"
        ].join('\n')
    };
    const material = new ShaderMaterial({
        name: 'CubemapFromEquirect',
        uniforms: cloneUniforms(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        side: BackSide,
        blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(new BoxBufferGeometry(5, 5, 5), material);
    scene.add(mesh);
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, scene);
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
};
/**
 * @author alteredq / http://alteredqualia.com/
 */ function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
        data: data || null,
        width: width || 1,
        height: height || 1
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
}
DataTexture.prototype = Object.create(Texture.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */ const _sphere$1 = new Sphere();
const _vector$5 = new Vector3();
function Frustum(p0, p1, p2, p3, p4, p5) {
    this.planes = [
        p0 !== undefined ? p0 : new Plane(),
        p1 !== undefined ? p1 : new Plane(),
        p2 !== undefined ? p2 : new Plane(),
        p3 !== undefined ? p3 : new Plane(),
        p4 !== undefined ? p4 : new Plane(),
        p5 !== undefined ? p5 : new Plane()
    ];
}
Object.assign(Frustum.prototype, {
    set: function(p0, p1, p2, p3, p4, p5) {
        const planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(frustum) {
        const planes = this.planes;
        for(let i95 = 0; i95 < 6; i95++)planes[i95].copy(frustum.planes[i95]);
        return this;
    },
    setFromProjectionMatrix: function(m) {
        const planes = this.planes;
        const me = m.elements;
        const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
    },
    intersectsObject: function(object) {
        const geometry = object.geometry;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        return this.intersectsSphere(_sphere$1);
    },
    intersectsSprite: function(sprite) {
        _sphere$1.center.set(0, 0, 0);
        _sphere$1.radius = 0.7071067811865476;
        _sphere$1.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(_sphere$1);
    },
    intersectsSphere: function(sphere) {
        const planes = this.planes;
        const center = sphere.center;
        const negRadius = -sphere.radius;
        for(let i96 = 0; i96 < 6; i96++){
            const distance = planes[i96].distanceToPoint(center);
            if (distance < negRadius) return false;
        }
        return true;
    },
    intersectsBox: function(box) {
        const planes = this.planes;
        for(let i97 = 0; i97 < 6; i97++){
            const plane = planes[i97];
            // corner at max distance
            _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            if (plane.distanceToPoint(_vector$5) < 0) return false;
        }
        return true;
    },
    containsPoint: function(point) {
        const planes = this.planes;
        for(let i98 = 0; i98 < 6; i98++){
            if (planes[i98].distanceToPoint(point) < 0) return false;
        }
        return true;
    }
});
/**
 * Uniforms library for shared webgl shaders
 */ const UniformsLib = {
    common: {
        diffuse: {
            value: new Color(15658734)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Matrix3()
        },
        uv2Transform: {
            value: new Matrix3()
        },
        alphaMap: {
            value: null
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        refractionRatio: {
            value: 0.98
        },
        maxMipLevel: {
            value: 0
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new Vector2(1, 1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 0.00025
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2000
        },
        fogColor: {
            value: new Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        }
    },
    points: {
        diffuse: {
            value: new Color(15658734)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        uvTransform: {
            value: new Matrix3()
        }
    },
    sprite: {
        diffuse: {
            value: new Color(15658734)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new Vector2(0.5, 0.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        uvTransform: {
            value: new Matrix3()
        }
    }
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLAnimation() {
    let context = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time, frame) {
        animationLoop(time, frame);
        requestId = context.requestAnimationFrame(onAnimationFrame);
    }
    return {
        start: function() {
            if (isAnimating === true) return;
            if (animationLoop === null) return;
            requestId = context.requestAnimationFrame(onAnimationFrame);
            isAnimating = true;
        },
        stop: function() {
            context.cancelAnimationFrame(requestId);
            isAnimating = false;
        },
        setAnimationLoop: function(callback) {
            animationLoop = callback;
        },
        setContext: function(value) {
            context = value;
        }
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLAttributes(gl, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = new WeakMap();
    function createBuffer(attribute, bufferType) {
        const array = attribute.array;
        const usage = attribute.usage;
        const buffer = gl.createBuffer();
        gl.bindBuffer(bufferType, buffer);
        gl.bufferData(bufferType, array, usage);
        attribute.onUploadCallback();
        let type = 5126;
        if (array instanceof Float32Array) type = 5126;
        else if (array instanceof Float64Array) console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
        else if (array instanceof Uint16Array) type = 5123;
        else if (array instanceof Int16Array) type = 5122;
        else if (array instanceof Uint32Array) type = 5125;
        else if (array instanceof Int32Array) type = 5124;
        else if (array instanceof Int8Array) type = 5120;
        else if (array instanceof Uint8Array) type = 5121;
        return {
            buffer: buffer,
            type: type,
            bytesPerElement: array.BYTES_PER_ELEMENT,
            version: attribute.version
        };
    }
    function updateBuffer(buffer, attribute, bufferType) {
        const array = attribute.array;
        const updateRange = attribute.updateRange;
        gl.bindBuffer(bufferType, buffer);
        if (updateRange.count === -1) // Not using update ranges
        gl.bufferSubData(bufferType, 0, array);
        else {
            if (isWebGL2) gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
            else gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
            updateRange.count = -1; // reset range
        }
    }
    //
    function get(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        return buffers.get(attribute);
    }
    function remove(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data) {
            gl.deleteBuffer(data.buffer);
            buffers.delete(attribute);
        }
    }
    function update(attribute, bufferType) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data === undefined) buffers.set(attribute, createBuffer(attribute, bufferType));
        else if (data.version < attribute.version) {
            updateBuffer(data.buffer, attribute, bufferType);
            data.version = attribute.version;
        }
    }
    return {
        get: get,
        remove: remove,
        update: update
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ // PlaneGeometry
function PlaneGeometry(width, height, widthSegments, heightSegments) {
    Geometry.call(this);
    this.type = 'PlaneGeometry';
    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };
    this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
    this.mergeVertices();
}
PlaneGeometry.prototype = Object.create(Geometry.prototype);
PlaneGeometry.prototype.constructor = PlaneGeometry;
// PlaneBufferGeometry
function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
    BufferGeometry.call(this);
    this.type = 'PlaneBufferGeometry';
    this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
    };
    width = width || 1;
    height = height || 1;
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments) || 1;
    const gridY = Math.floor(heightSegments) || 1;
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    // buffers
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    // generate vertices, normals and uvs
    for(let iy = 0; iy < gridY1; iy++){
        const y = iy * segment_height - height_half;
        for(let ix = 0; ix < gridX1; ix++){
            const x = ix * segment_width - width_half;
            vertices.push(x, -y, 0);
            normals.push(0, 0, 1);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
        }
    }
    // indices
    for(let iy2 = 0; iy2 < gridY; iy2++)for(let ix = 0; ix < gridX; ix++){
        const a = ix + gridX1 * iy2;
        const b = ix + gridX1 * (iy2 + 1);
        const c = ix + 1 + gridX1 * (iy2 + 1);
        const d = ix + 1 + gridX1 * iy2;
        // faces
        indices.push(a, b, d);
        indices.push(b, c, d);
    }
    // build geometry
    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
}
PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
const ShaderChunk = {
    alphamap_fragment: alphamap_fragment,
    alphamap_pars_fragment: alphamap_pars_fragment,
    alphatest_fragment: alphatest_fragment,
    aomap_fragment: aomap_fragment,
    aomap_pars_fragment: aomap_pars_fragment,
    begin_vertex: begin_vertex,
    beginnormal_vertex: beginnormal_vertex,
    bsdfs: bsdfs,
    bumpmap_pars_fragment: bumpmap_pars_fragment,
    clipping_planes_fragment: clipping_planes_fragment,
    clipping_planes_pars_fragment: clipping_planes_pars_fragment,
    clipping_planes_pars_vertex: clipping_planes_pars_vertex,
    clipping_planes_vertex: clipping_planes_vertex,
    color_fragment: color_fragment,
    color_pars_fragment: color_pars_fragment,
    color_pars_vertex: color_pars_vertex,
    color_vertex: color_vertex,
    common: common,
    cube_uv_reflection_fragment: cube_uv_reflection_fragment,
    defaultnormal_vertex: defaultnormal_vertex,
    displacementmap_pars_vertex: displacementmap_pars_vertex,
    displacementmap_vertex: displacementmap_vertex,
    emissivemap_fragment: emissivemap_fragment,
    emissivemap_pars_fragment: emissivemap_pars_fragment,
    encodings_fragment: encodings_fragment,
    encodings_pars_fragment: encodings_pars_fragment,
    envmap_fragment: envmap_fragment,
    envmap_common_pars_fragment: envmap_common_pars_fragment,
    envmap_pars_fragment: envmap_pars_fragment,
    envmap_pars_vertex: envmap_pars_vertex,
    envmap_physical_pars_fragment: envmap_physical_pars_fragment,
    envmap_vertex: envmap_vertex,
    fog_vertex: fog_vertex,
    fog_pars_vertex: fog_pars_vertex,
    fog_fragment: fog_fragment,
    fog_pars_fragment: fog_pars_fragment,
    gradientmap_pars_fragment: gradientmap_pars_fragment,
    lightmap_fragment: lightmap_fragment,
    lightmap_pars_fragment: lightmap_pars_fragment,
    lights_lambert_vertex: lights_lambert_vertex,
    lights_pars_begin: lights_pars_begin,
    lights_toon_fragment: lights_toon_fragment,
    lights_toon_pars_fragment: lights_toon_pars_fragment,
    lights_phong_fragment: lights_phong_fragment,
    lights_phong_pars_fragment: lights_phong_pars_fragment,
    lights_physical_fragment: lights_physical_fragment,
    lights_physical_pars_fragment: lights_physical_pars_fragment,
    lights_fragment_begin: lights_fragment_begin,
    lights_fragment_maps: lights_fragment_maps,
    lights_fragment_end: lights_fragment_end,
    logdepthbuf_fragment: logdepthbuf_fragment,
    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
    logdepthbuf_vertex: logdepthbuf_vertex,
    map_fragment: map_fragment,
    map_pars_fragment: map_pars_fragment,
    map_particle_fragment: map_particle_fragment,
    map_particle_pars_fragment: map_particle_pars_fragment,
    metalnessmap_fragment: metalnessmap_fragment,
    metalnessmap_pars_fragment: metalnessmap_pars_fragment,
    morphnormal_vertex: morphnormal_vertex,
    morphtarget_pars_vertex: morphtarget_pars_vertex,
    morphtarget_vertex: morphtarget_vertex,
    normal_fragment_begin: normal_fragment_begin,
    normal_fragment_maps: normal_fragment_maps,
    normalmap_pars_fragment: normalmap_pars_fragment,
    clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment: clearcoat_pars_fragment,
    packing: packing,
    premultiplied_alpha_fragment: premultiplied_alpha_fragment,
    project_vertex: project_vertex,
    dithering_fragment: dithering_fragment,
    dithering_pars_fragment: dithering_pars_fragment,
    roughnessmap_fragment: roughnessmap_fragment,
    roughnessmap_pars_fragment: roughnessmap_pars_fragment,
    shadowmap_pars_fragment: shadowmap_pars_fragment,
    shadowmap_pars_vertex: shadowmap_pars_vertex,
    shadowmap_vertex: shadowmap_vertex,
    shadowmask_pars_fragment: shadowmask_pars_fragment,
    skinbase_vertex: skinbase_vertex,
    skinning_pars_vertex: skinning_pars_vertex,
    skinning_vertex: skinning_vertex,
    skinnormal_vertex: skinnormal_vertex,
    specularmap_fragment: specularmap_fragment,
    specularmap_pars_fragment: specularmap_pars_fragment,
    tonemapping_fragment: tonemapping_fragment,
    tonemapping_pars_fragment: tonemapping_pars_fragment,
    uv_pars_fragment: uv_pars_fragment,
    uv_pars_vertex: uv_pars_vertex,
    uv_vertex: uv_vertex,
    uv2_pars_fragment: uv2_pars_fragment,
    uv2_pars_vertex: uv2_pars_vertex,
    uv2_vertex: uv2_vertex,
    worldpos_vertex: worldpos_vertex,
    background_frag: background_frag,
    background_vert: background_vert,
    cube_frag: cube_frag,
    cube_vert: cube_vert,
    depth_frag: depth_frag,
    depth_vert: depth_vert,
    distanceRGBA_frag: distanceRGBA_frag,
    distanceRGBA_vert: distanceRGBA_vert,
    equirect_frag: equirect_frag,
    equirect_vert: equirect_vert,
    linedashed_frag: linedashed_frag,
    linedashed_vert: linedashed_vert,
    meshbasic_frag: meshbasic_frag,
    meshbasic_vert: meshbasic_vert,
    meshlambert_frag: meshlambert_frag,
    meshlambert_vert: meshlambert_vert,
    meshmatcap_frag: meshmatcap_frag,
    meshmatcap_vert: meshmatcap_vert,
    meshtoon_frag: meshtoon_frag,
    meshtoon_vert: meshtoon_vert,
    meshphong_frag: meshphong_frag,
    meshphong_vert: meshphong_vert,
    meshphysical_frag: meshphysical_frag,
    meshphysical_vert: meshphysical_vert,
    normal_frag: normal_frag,
    normal_vert: normal_vert,
    points_frag: points_frag,
    points_vert: points_vert,
    shadow_frag: shadow_frag,
    shadow_vert: shadow_vert,
    sprite_frag: sprite_frag,
    sprite_vert: sprite_vert
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */ const ShaderLib = {
    basic: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0)
                }
            }
        ]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0)
                },
                specular: {
                    value: new Color(1118481)
                },
                shininess: {
                    value: 30
                }
            }
        ]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.roughnessmap,
            UniformsLib.metalnessmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                } // temporary
            }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.gradientmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0)
                }
            }
        ]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            {
                matcap: {
                    value: null
                }
            }
        ]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
        uniforms: mergeUniforms([
            UniformsLib.points,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.fog,
            {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }
        ]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap
        ]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: ShaderChunk.normal_vert,
        fragmentShader: ShaderChunk.normal_frag
    },
    sprite: {
        uniforms: mergeUniforms([
            UniformsLib.sprite,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Matrix3()
            },
            t2D: {
                value: null
            }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
    },
    /* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */ cube: {
        uniforms: mergeUniforms([
            UniformsLib.envmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap,
            {
                referencePosition: {
                    value: new Vector3()
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1000
                }
            }
        ]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
        uniforms: mergeUniforms([
            UniformsLib.lights,
            UniformsLib.fog,
            {
                color: {
                    value: new Color(0)
                },
                opacity: {
                    value: 1
                }
            }, 
        ]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
    }
};
ShaderLib.physical = {
    uniforms: mergeUniforms([
        ShaderLib.standard.uniforms,
        {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new Vector2(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: new Color(0)
            },
            transparency: {
                value: 0
            }
        }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
    const clearColor = new Color(0);
    let clearAlpha = 0;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render(renderList, scene, camera1, forceClear) {
        let background = scene.isScene === true ? scene.background : null;
        // Ignore background in AR
        // TODO: Reconsider this.
        const xr = renderer.xr;
        const session = xr.getSession && xr.getSession();
        if (session && session.environmentBlendMode === 'additive') background = null;
        if (background === null) setClear(clearColor, clearAlpha);
        else if (background && background.isColor) {
            setClear(background, 1);
            forceClear = true;
        }
        if (renderer.autoClear || forceClear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
            if (boxMesh === undefined) {
                boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
                    name: 'BackgroundCubeMaterial',
                    uniforms: cloneUniforms(ShaderLib.cube.uniforms),
                    vertexShader: ShaderLib.cube.vertexShader,
                    fragmentShader: ShaderLib.cube.fragmentShader,
                    side: BackSide,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                boxMesh.geometry.deleteAttribute('normal');
                boxMesh.geometry.deleteAttribute('uv');
                boxMesh.onBeforeRender = function(renderer, scene, camera) {
                    this.matrixWorld.copyPosition(camera.matrixWorld);
                };
                // enable code injection for non-built-in material
                Object.defineProperty(boxMesh.material, 'envMap', {
                    get: function() {
                        return this.uniforms.envMap.value;
                    }
                });
                objects.update(boxMesh);
            }
            const texture = background.isWebGLCubeRenderTarget ? background.texture : background;
            boxMesh.material.uniforms.envMap.value = texture;
            boxMesh.material.uniforms.flipEnvMap.value = texture.isCubeTexture ? -1 : 1;
            if (currentBackground !== background || currentBackgroundVersion !== texture.version || currentTonemapping !== renderer.toneMapping) {
                boxMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = texture.version;
                currentTonemapping = renderer.toneMapping;
            }
            // push to the pre-sorted opaque render list
            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
        } else if (background && background.isTexture) {
            if (planeMesh === undefined) {
                planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
                    name: 'BackgroundMaterial',
                    uniforms: cloneUniforms(ShaderLib.background.uniforms),
                    vertexShader: ShaderLib.background.vertexShader,
                    fragmentShader: ShaderLib.background.fragmentShader,
                    side: FrontSide,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                planeMesh.geometry.deleteAttribute('normal');
                // enable code injection for non-built-in material
                Object.defineProperty(planeMesh.material, 'map', {
                    get: function() {
                        return this.uniforms.t2D.value;
                    }
                });
                objects.update(planeMesh);
            }
            planeMesh.material.uniforms.t2D.value = background;
            if (background.matrixAutoUpdate === true) background.updateMatrix();
            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                planeMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
            }
            // push to the pre-sorted opaque render list
            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
        }
    }
    function setClear(color, alpha) {
        state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
    }
    return {
        getClearColor: function() {
            return clearColor;
        },
        setClearColor: function(color, alpha) {
            clearColor.set(color);
            clearAlpha = alpha !== undefined ? alpha : 1;
            setClear(clearColor, clearAlpha);
        },
        getClearAlpha: function() {
            return clearAlpha;
        },
        setClearAlpha: function(alpha) {
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
        },
        render: render
    };
}
/**
 * @author Mugen87 / https://github.com/Mugen87
 * @author Takahiro / https://github.com/takahirox
 */ function WebGLBindingStates(gl, extensions, attributes1, capabilities) {
    const maxVertexAttributes = gl.getParameter(34921);
    const extension1 = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
    const vaoAvailable = capabilities.isWebGL2 || extension1 !== null;
    const bindingStates = {};
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    function setup(object, material, program, geometry, index) {
        let updateBuffers = false;
        if (vaoAvailable) {
            const state = getBindingState(geometry, program, material);
            if (currentState !== state) {
                currentState = state;
                bindVertexArrayObject(currentState.object);
            }
            updateBuffers = needsUpdate(geometry);
            if (updateBuffers) saveCache(geometry);
        } else {
            const wireframe = material.wireframe === true;
            if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
                currentState.geometry = geometry.id;
                currentState.program = program.id;
                currentState.wireframe = wireframe;
                updateBuffers = true;
            }
        }
        if (object.isInstancedMesh === true) updateBuffers = true;
        if (index !== null) attributes1.update(index, 34963);
        if (updateBuffers) {
            setupVertexAttributes(object, material, program, geometry);
            if (index !== null) gl.bindBuffer(34963, attributes1.get(index).buffer);
        }
    }
    function createVertexArrayObject() {
        if (capabilities.isWebGL2) return gl.createVertexArray();
        return extension1.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
        return extension1.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
        return extension1.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry, program, material) {
        const wireframe = material.wireframe === true;
        let programMap = bindingStates[geometry.id];
        if (programMap === undefined) {
            programMap = {};
            bindingStates[geometry.id] = programMap;
        }
        let stateMap = programMap[program.id];
        if (stateMap === undefined) {
            stateMap = {};
            programMap[program.id] = stateMap;
        }
        let state = stateMap[wireframe];
        if (state === undefined) {
            state = createBindingState(createVertexArrayObject());
            stateMap[wireframe] = state;
        }
        return state;
    }
    function createBindingState(vao) {
        const newAttributes = [];
        const enabledAttributes = [];
        const attributeDivisors = [];
        for(let i99 = 0; i99 < maxVertexAttributes; i99++){
            newAttributes[i99] = 0;
            enabledAttributes[i99] = 0;
            attributeDivisors[i99] = 0;
        }
        return {
            // for backward compatibility on non-VAO support browser
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes: newAttributes,
            enabledAttributes: enabledAttributes,
            attributeDivisors: attributeDivisors,
            object: vao,
            attributes: {}
        };
    }
    function needsUpdate(geometry) {
        const cachedAttributes = currentState.attributes;
        const geometryAttributes = geometry.attributes;
        if (Object.keys(cachedAttributes).length !== Object.keys(geometryAttributes).length) return true;
        for(const key in geometryAttributes){
            const cachedAttribute = cachedAttributes[key];
            const geometryAttribute = geometryAttributes[key];
            if (cachedAttribute.attribute !== geometryAttribute) return true;
            if (cachedAttribute.data !== geometryAttribute.data) return true;
        }
        return false;
    }
    function saveCache(geometry) {
        const cache = {};
        const attributes = geometry.attributes;
        for(const key in attributes){
            const attribute = attributes[key];
            const data = {};
            data.attribute = attribute;
            if (attribute.data) data.data = attribute.data;
            cache[key] = data;
        }
        currentState.attributes = cache;
    }
    function initAttributes() {
        const newAttributes = currentState.newAttributes;
        for(let i100 = 0, il = newAttributes.length; i100 < il; i100++)newAttributes[i100] = 0;
    }
    function enableAttribute(attribute) {
        enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        const attributeDivisors = currentState.attributeDivisors;
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== meshPerAttribute) {
            const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
            extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
            attributeDivisors[attribute] = meshPerAttribute;
        }
    }
    function disableUnusedAttributes() {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        for(let i101 = 0, il = enabledAttributes.length; i101 < il; i101++)if (enabledAttributes[i101] !== newAttributes[i101]) {
            gl.disableVertexAttribArray(i101);
            enabledAttributes[i101] = 0;
        }
    }
    function vertexAttribPointer(index, size, type, normalized, stride, offset) {
        if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) gl.vertexAttribIPointer(index, size, type, normalized, stride, offset);
        else gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
    function setupVertexAttributes(object, material, program, geometry) {
        if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
            if (extensions.get('ANGLE_instanced_arrays') === null) return;
        }
        initAttributes();
        const geometryAttributes = geometry.attributes;
        const programAttributes = program.getAttributes();
        const materialDefaultAttributeValues = material.defaultAttributeValues;
        for(const name in programAttributes){
            const programAttribute = programAttributes[name];
            if (programAttribute >= 0) {
                const geometryAttribute = geometryAttributes[name];
                if (geometryAttribute !== undefined) {
                    const normalized = geometryAttribute.normalized;
                    const size = geometryAttribute.itemSize;
                    const attribute = attributes1.get(geometryAttribute);
                    // TODO Attribute may not be available on context restore
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type = attribute.type;
                    const bytesPerElement = attribute.bytesPerElement;
                    if (geometryAttribute.isInterleavedBufferAttribute) {
                        const data = geometryAttribute.data;
                        const stride = data.stride;
                        const offset = geometryAttribute.offset;
                        if (data && data.isInstancedInterleavedBuffer) {
                            enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                            if (geometry._maxInstanceCount === undefined) geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                        } else enableAttribute(programAttribute);
                        gl.bindBuffer(34962, buffer);
                        vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
                    } else {
                        if (geometryAttribute.isInstancedBufferAttribute) {
                            enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                            if (geometry._maxInstanceCount === undefined) geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                        } else enableAttribute(programAttribute);
                        gl.bindBuffer(34962, buffer);
                        vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
                    }
                } else if (name === 'instanceMatrix') {
                    const attribute = attributes1.get(object.instanceMatrix);
                    // TODO Attribute may not be available on context restore
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type = attribute.type;
                    enableAttributeAndDivisor(programAttribute + 0, 1);
                    enableAttributeAndDivisor(programAttribute + 1, 1);
                    enableAttributeAndDivisor(programAttribute + 2, 1);
                    enableAttributeAndDivisor(programAttribute + 3, 1);
                    gl.bindBuffer(34962, buffer);
                    gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
                    gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
                    gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
                    gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
                } else if (materialDefaultAttributeValues !== undefined) {
                    const value = materialDefaultAttributeValues[name];
                    if (value !== undefined) switch(value.length){
                        case 2:
                            gl.vertexAttrib2fv(programAttribute, value);
                            break;
                        case 3:
                            gl.vertexAttrib3fv(programAttribute, value);
                            break;
                        case 4:
                            gl.vertexAttrib4fv(programAttribute, value);
                            break;
                        default:
                            gl.vertexAttrib1fv(programAttribute, value);
                    }
                }
            }
        }
        disableUnusedAttributes();
    }
    function dispose() {
        reset();
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            for(const programId in programMap){
                const stateMap = programMap[programId];
                for(const wireframe in stateMap){
                    deleteVertexArrayObject(stateMap[wireframe].object);
                    delete stateMap[wireframe];
                }
                delete programMap[programId];
            }
            delete bindingStates[geometryId];
        }
    }
    function releaseStatesOfGeometry(geometry) {
        if (bindingStates[geometry.id] === undefined) return;
        const programMap = bindingStates[geometry.id];
        for(const programId in programMap){
            const stateMap = programMap[programId];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[programId];
        }
        delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            if (programMap[program.id] === undefined) continue;
            const stateMap = programMap[program.id];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[program.id];
        }
    }
    function reset() {
        resetDefaultState();
        if (currentState === defaultState) return;
        currentState = defaultState;
        bindVertexArrayObject(currentState.object);
    }
    // for backward-compatilibity
    function resetDefaultState() {
        defaultState.geometry = null;
        defaultState.program = null;
        defaultState.wireframe = false;
    }
    return {
        setup: setup,
        reset: reset,
        resetDefaultState: resetDefaultState,
        dispose: dispose,
        releaseStatesOfGeometry: releaseStatesOfGeometry,
        releaseStatesOfProgram: releaseStatesOfProgram,
        initAttributes: initAttributes,
        enableAttribute: enableAttribute,
        disableUnusedAttributes: disableUnusedAttributes
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
        mode = value;
    }
    function render(start, count) {
        gl.drawArrays(mode, start, count);
        info.update(count, mode);
    }
    function renderInstances(geometry, start, count, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
            extension = gl;
            methodName = 'drawArraysInstanced';
        } else {
            extension = extensions.get('ANGLE_instanced_arrays');
            methodName = 'drawArraysInstancedANGLE';
            if (extension === null) {
                console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
        }
        extension[methodName](mode, start, count, primcount);
        info.update(count, mode, primcount);
    }
    //
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLCapabilities(gl, extensions, parameters) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
        if (maxAnisotropy !== undefined) return maxAnisotropy;
        const extension = extensions.get('EXT_texture_filter_anisotropic');
        if (extension !== null) maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        else maxAnisotropy = 0;
        return maxAnisotropy;
    }
    function getMaxPrecision(precision) {
        if (precision === 'highp') {
            if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) return 'highp';
            precision = 'mediump';
        }
        if (precision === 'mediump') {
            if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) return 'mediump';
        }
        return 'lowp';
    }
    /* eslint-disable no-undef */ const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
    /* eslint-enable no-undef */ let precision1 = parameters.precision !== undefined ? parameters.precision : 'highp';
    const maxPrecision = getMaxPrecision(precision1);
    if (maxPrecision !== precision1) {
        console.warn('THREE.WebGLRenderer:', precision1, 'not supported, using', maxPrecision, 'instead.');
        precision1 = maxPrecision;
    }
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl.getParameter(34930);
    const maxVertexTextures = gl.getParameter(35660);
    const maxTextureSize = gl.getParameter(3379);
    const maxCubemapSize = gl.getParameter(34076);
    const maxAttributes = gl.getParameter(34921);
    const maxVertexUniforms = gl.getParameter(36347);
    const maxVaryings = gl.getParameter(36348);
    const maxFragmentUniforms = gl.getParameter(36349);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
    return {
        isWebGL2: isWebGL2,
        getMaxAnisotropy: getMaxAnisotropy,
        getMaxPrecision: getMaxPrecision,
        precision: precision1,
        logarithmicDepthBuffer: logarithmicDepthBuffer,
        maxTextures: maxTextures,
        maxVertexTextures: maxVertexTextures,
        maxTextureSize: maxTextureSize,
        maxCubemapSize: maxCubemapSize,
        maxAttributes: maxAttributes,
        maxVertexUniforms: maxVertexUniforms,
        maxVaryings: maxVaryings,
        maxFragmentUniforms: maxFragmentUniforms,
        vertexTextures: vertexTextures,
        floatFragmentTextures: floatFragmentTextures,
        floatVertexTextures: floatVertexTextures,
        maxSamples: maxSamples
    };
}
/**
 * @author tschw
 */ function WebGLClipping() {
    const scope = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {
        value: null,
        needsUpdate: false
    };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera) {
        const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
        // run another frame in order to reset the state:
        numGlobalPlanes !== 0 || localClippingEnabled;
        localClippingEnabled = enableLocalClipping;
        globalState = projectPlanes(planes, camera, 0);
        numGlobalPlanes = planes.length;
        return enabled;
    };
    this.beginShadows = function() {
        renderingShadows = true;
        projectPlanes(null);
    };
    this.endShadows = function() {
        renderingShadows = false;
        resetGlobalState();
    };
    this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
            // there's no local clipping
            if (renderingShadows) // there's no global clipping
            projectPlanes(null);
            else resetGlobalState();
        } else {
            const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
            let dstArray = cache.clippingState || null;
            uniform.value = dstArray; // ensure unique state
            dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
            for(let i102 = 0; i102 !== lGlobal; ++i102)dstArray[i102] = globalState[i102];
            cache.clippingState = dstArray;
            this.numIntersection = clipIntersection ? this.numPlanes : 0;
            this.numPlanes += nGlobal;
        }
    };
    function resetGlobalState() {
        if (uniform.value !== globalState) {
            uniform.value = globalState;
            uniform.needsUpdate = numGlobalPlanes > 0;
        }
        scope.numPlanes = numGlobalPlanes;
        scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
        let nPlanes = planes !== null ? planes.length : 0, dstArray = null;
        if (nPlanes !== 0) {
            dstArray = uniform.value;
            if (skipTransform !== true || dstArray === null) {
                const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                viewNormalMatrix.getNormalMatrix(viewMatrix);
                if (dstArray === null || dstArray.length < flatSize) dstArray = new Float32Array(flatSize);
                for(let i103 = 0, i4 = dstOffset; i103 !== nPlanes; ++i103, i4 += 4){
                    plane.copy(planes[i103]).applyMatrix4(viewMatrix, viewNormalMatrix);
                    plane.normal.toArray(dstArray, i4);
                    dstArray[i4 + 3] = plane.constant;
                }
            }
            uniform.value = dstArray;
            uniform.needsUpdate = true;
        }
        scope.numPlanes = nPlanes;
        scope.numIntersection = 0;
        return dstArray;
    }
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLExtensions(gl) {
    const extensions = {};
    return {
        get: function(name) {
            if (extensions[name] !== undefined) return extensions[name];
            let extension;
            switch(name){
                case 'WEBGL_depth_texture':
                    extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                    break;
                case 'EXT_texture_filter_anisotropic':
                    extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                    break;
                case 'WEBGL_compressed_texture_s3tc':
                    extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                    break;
                case 'WEBGL_compressed_texture_pvrtc':
                    extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                    break;
                default:
                    extension = gl.getExtension(name);
            }
            if (extension === null) console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
            extensions[name] = extension;
            return extension;
        }
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLGeometries(gl, attributes, info, bindingStates) {
    const geometries = new WeakMap();
    const wireframeAttributes = new WeakMap();
    function onGeometryDispose(event) {
        const geometry = event.target;
        const buffergeometry = geometries.get(geometry);
        if (buffergeometry.index !== null) attributes.remove(buffergeometry.index);
        for(const name in buffergeometry.attributes)attributes.remove(buffergeometry.attributes[name]);
        geometry.removeEventListener('dispose', onGeometryDispose);
        geometries.delete(geometry);
        const attribute = wireframeAttributes.get(buffergeometry);
        if (attribute) {
            attributes.remove(attribute);
            wireframeAttributes.delete(buffergeometry);
        }
        bindingStates.releaseStatesOfGeometry(geometry);
        if (geometry.isInstancedBufferGeometry === true) delete geometry._maxInstanceCount;
        //
        info.memory.geometries--;
    }
    function get(object, geometry) {
        let buffergeometry = geometries.get(geometry);
        if (buffergeometry) return buffergeometry;
        geometry.addEventListener('dispose', onGeometryDispose);
        if (geometry.isBufferGeometry) buffergeometry = geometry;
        else if (geometry.isGeometry) {
            if (geometry._bufferGeometry === undefined) geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
            buffergeometry = geometry._bufferGeometry;
        }
        geometries.set(geometry, buffergeometry);
        info.memory.geometries++;
        return buffergeometry;
    }
    function update(geometry) {
        const geometryAttributes = geometry.attributes;
        // Updating index buffer in VAO now. See WebGLBindingStates.
        for(const name in geometryAttributes)attributes.update(geometryAttributes[name], 34962);
        // morph targets
        const morphAttributes = geometry.morphAttributes;
        for(const name3 in morphAttributes){
            const array = morphAttributes[name3];
            for(let i104 = 0, l = array.length; i104 < l; i104++)attributes.update(array[i104], 34962);
        }
    }
    function updateWireframeAttribute(geometry) {
        const indices = [];
        const geometryIndex = geometry.index;
        const geometryPosition = geometry.attributes.position;
        let version = 0;
        if (geometryIndex !== null) {
            const array = geometryIndex.array;
            version = geometryIndex.version;
            for(let i105 = 0, l = array.length; i105 < l; i105 += 3){
                const a = array[i105 + 0];
                const b = array[i105 + 1];
                const c = array[i105 + 2];
                indices.push(a, b, b, c, c, a);
            }
        } else {
            const array = geometryPosition.array;
            version = geometryPosition.version;
            for(let i106 = 0, l = array.length / 3 - 1; i106 < l; i106 += 3){
                const a = i106 + 0;
                const b = i106 + 1;
                const c = i106 + 2;
                indices.push(a, b, b, c, c, a);
            }
        }
        const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
        attribute.version = version;
        // Updating index buffer in VAO now. See WebGLBindingStates
        //
        const previousAttribute = wireframeAttributes.get(geometry);
        if (previousAttribute) attributes.remove(previousAttribute);
        //
        wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
        const currentAttribute = wireframeAttributes.get(geometry);
        if (currentAttribute) {
            const geometryIndex = geometry.index;
            if (geometryIndex !== null) // if the attribute is obsolete, create a new one
            {
                if (currentAttribute.version < geometryIndex.version) updateWireframeAttribute(geometry);
            }
        } else updateWireframeAttribute(geometry);
        return wireframeAttributes.get(geometry);
    }
    return {
        get: get,
        update: update,
        getWireframeAttribute: getWireframeAttribute
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
        mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
        type = value.type;
        bytesPerElement = value.bytesPerElement;
    }
    function render(start, count) {
        gl.drawElements(mode, count, type, start * bytesPerElement);
        info.update(count, mode);
    }
    function renderInstances(geometry, start, count, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
            extension = gl;
            methodName = 'drawElementsInstanced';
        } else {
            extension = extensions.get('ANGLE_instanced_arrays');
            methodName = 'drawElementsInstancedANGLE';
            if (extension === null) {
                console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
        }
        extension[methodName](mode, count, type, start * bytesPerElement, primcount);
        info.update(count, mode, primcount);
    }
    //
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
}
/**
 * @author Mugen87 / https://github.com/Mugen87
 */ function WebGLInfo(gl) {
    const memory = {
        geometries: 0,
        textures: 0
    };
    const render = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function update(count, mode, instanceCount) {
        instanceCount = instanceCount || 1;
        render.calls++;
        switch(mode){
            case 4:
                render.triangles += instanceCount * (count / 3);
                break;
            case 1:
                render.lines += instanceCount * (count / 2);
                break;
            case 3:
                render.lines += instanceCount * (count - 1);
                break;
            case 2:
                render.lines += instanceCount * count;
                break;
            case 0:
                render.points += instanceCount * count;
                break;
            default:
                console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
                break;
        }
    }
    function reset() {
        render.frame++;
        render.calls = 0;
        render.triangles = 0;
        render.points = 0;
        render.lines = 0;
    }
    return {
        memory: memory,
        render: render,
        programs: null,
        autoReset: true,
        reset: reset,
        update: update
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function numericalSort(a, b) {
    return a[0] - b[0];
}
function absNumericalSort(a, b) {
    return Math.abs(b[1]) - Math.abs(a[1]);
}
function WebGLMorphtargets(gl) {
    const influencesList = {};
    const morphInfluences = new Float32Array(8);
    const workInfluences = [];
    for(let i107 = 0; i107 < 8; i107++)workInfluences[i107] = [
        i107,
        0
    ];
    function update(object, geometry, material, program) {
        const objectInfluences = object.morphTargetInfluences;
        // When object doesn't have morph target influences defined, we treat it as a 0-length array
        // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
        const length = objectInfluences === undefined ? 0 : objectInfluences.length;
        let influences = influencesList[geometry.id];
        if (influences === undefined) {
            // initialise list
            influences = [];
            for(let i110 = 0; i110 < length; i110++)influences[i110] = [
                i110,
                0
            ];
            influencesList[geometry.id] = influences;
        }
        // Collect influences
        for(let i111 = 0; i111 < length; i111++){
            const influence = influences[i111];
            influence[0] = i111;
            influence[1] = objectInfluences[i111];
        }
        influences.sort(absNumericalSort);
        for(let i108 = 0; i108 < 8; i108++)if (i108 < length && influences[i108][1]) {
            workInfluences[i108][0] = influences[i108][0];
            workInfluences[i108][1] = influences[i108][1];
        } else {
            workInfluences[i108][0] = Number.MAX_SAFE_INTEGER;
            workInfluences[i108][1] = 0;
        }
        workInfluences.sort(numericalSort);
        const morphTargets = material.morphTargets && geometry.morphAttributes.position;
        const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
        let morphInfluencesSum = 0;
        for(let i109 = 0; i109 < 8; i109++){
            const influence = workInfluences[i109];
            const index = influence[0];
            const value = influence[1];
            if (index !== Number.MAX_SAFE_INTEGER && value) {
                if (morphTargets && geometry.getAttribute('morphTarget' + i109) !== morphTargets[index]) geometry.setAttribute('morphTarget' + i109, morphTargets[index]);
                if (morphNormals && geometry.getAttribute('morphNormal' + i109) !== morphNormals[index]) geometry.setAttribute('morphNormal' + i109, morphNormals[index]);
                morphInfluences[i109] = value;
                morphInfluencesSum += value;
            } else {
                if (morphTargets && geometry.getAttribute('morphTarget' + i109) !== undefined) geometry.deleteAttribute('morphTarget' + i109);
                if (morphNormals && geometry.getAttribute('morphNormal' + i109) !== undefined) geometry.deleteAttribute('morphNormal' + i109);
                morphInfluences[i109] = 0;
            }
        }
        // GLSL shader uses formula baseinfluence * base + sum(target * influence)
        // This allows us to switch between absolute morphs and relative morphs without changing shader code
        // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
        program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
    }
    return {
        update: update
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLObjects(gl, geometries, attributes, info) {
    let updateMap = new WeakMap();
    function update(object) {
        const frame = info.render.frame;
        const geometry = object.geometry;
        const buffergeometry = geometries.get(object, geometry);
        // Update once per frame
        if (updateMap.get(buffergeometry) !== frame) {
            if (geometry.isGeometry) buffergeometry.updateFromObject(object);
            geometries.update(buffergeometry);
            updateMap.set(buffergeometry, frame);
        }
        if (object.isInstancedMesh) attributes.update(object.instanceMatrix, 34962);
        return buffergeometry;
    }
    function dispose() {
        updateMap = new WeakMap();
    }
    return {
        update: update,
        dispose: dispose
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== undefined ? images : [];
    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
    format = format !== undefined ? format : RGBFormat;
    Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.flipY = false;
}
CubeTexture.prototype = Object.create(Texture.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture.prototype, 'images', {
    get: function() {
        return this.image;
    },
    set: function(value) {
        this.image = value;
    }
});
/**
 * @author Takahiro https://github.com/takahirox
 */ function DataTexture2DArray(data, width, height, depth) {
    Texture.call(this, null);
    this.image = {
        data: data || null,
        width: width || 1,
        height: height || 1,
        depth: depth || 1
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
}
DataTexture2DArray.prototype = Object.create(Texture.prototype);
DataTexture2DArray.prototype.constructor = DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray = true;
/**
 * @author Artur Trzesiok
 */ function DataTexture3D(data, width, height, depth) {
    // We're going to add .setXXX() methods for setting properties later.
    // Users can still set in DataTexture3D directly.
    //
    //	const texture = new THREE.DataTexture3D( data, width, height, depth );
    // 	texture.anisotropy = 16;
    //
    // See #14839
    Texture.call(this, null);
    this.image = {
        data: data || null,
        width: width || 1,
        height: height || 1,
        depth: depth || 1
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
}
DataTexture3D.prototype = Object.create(Texture.prototype);
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;
/**
 * @author tschw
 * @author Mugen87 / https://github.com/Mugen87
 * @author mrdoob / http://mrdoob.com/
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */ const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture();
// --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)
const arrayCacheF32 = [];
const arrayCacheI32 = [];
// Float32Array caches used for uploading Matrix uniforms
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
// Flattening for arrays of vectors and matrices
function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0) return array;
    // unoptimized: ! isNaN( firstElem )
    // see http://jacksondunstan.com/articles/983
    let n = nBlocks * blockSize, r = arrayCacheF32[n];
    if (r === undefined) {
        r = new Float32Array(n);
        arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
        firstElem.toArray(r, 0);
        for(let i112 = 1, offset = 0; i112 !== nBlocks; ++i112){
            offset += blockSize;
            array[i112].toArray(r, offset);
        }
    }
    return r;
}
function arraysEqual(a, b) {
    if (a.length !== b.length) return false;
    for(let i113 = 0, l = a.length; i113 < l; i113++){
        if (a[i113] !== b[i113]) return false;
    }
    return true;
}
function copyArray(a, b) {
    for(let i114 = 0, l = b.length; i114 < l; i114++)a[i114] = b[i114];
}
// Texture unit allocation
function allocTexUnits(textures, n) {
    let r = arrayCacheI32[n];
    if (r === undefined) {
        r = new Int32Array(n);
        arrayCacheI32[n] = r;
    }
    for(let i115 = 0; i115 !== n; ++i115)r[i115] = textures.allocateTextureUnit();
    return r;
}
// --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar
function setValueV1f(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
}
// Single float vector (from flat array or THREE.VectorN)
function setValueV2f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y) {
            gl.uniform2f(this.addr, v.x, v.y);
            cache[0] = v.x;
            cache[1] = v.y;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform2fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValueV3f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
            gl.uniform3f(this.addr, v.x, v.y, v.z);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
        }
    } else if (v.r !== undefined) {
        if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
            gl.uniform3f(this.addr, v.r, v.g, v.b);
            cache[0] = v.r;
            cache[1] = v.g;
            cache[2] = v.b;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform3fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValueV4f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
            cache[3] = v.w;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform4fv(this.addr, v);
        copyArray(cache, v);
    }
}
// Single matrix (from flat array or MatrixN)
function setValueM2(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix2fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat2array.set(elements);
        gl.uniformMatrix2fv(this.addr, false, mat2array);
        copyArray(cache, elements);
    }
}
function setValueM3(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix3fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat3array.set(elements);
        gl.uniformMatrix3fv(this.addr, false, mat3array);
        copyArray(cache, elements);
    }
}
function setValueM4(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix4fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat4array.set(elements);
        gl.uniformMatrix4fv(this.addr, false, mat4array);
        copyArray(cache, elements);
    }
}
// Single texture (2D / Cube)
function setValueT1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.safeSetTexture2D(v || emptyTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}
function setValueT3D1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture3D(v || emptyTexture3d, unit);
}
function setValueT6(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.safeSetTextureCube(v || emptyCubeTexture, unit);
}
// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValueV1i(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
}
function setValueV2i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
}
function setValueV3i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
}
function setValueV4i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
}
// uint
function setValueV1ui(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
}
// Helper to pick the right setter for the singular case
function getSingularSetter(type) {
    switch(type){
        case 5126:
            return setValueV1f; // FLOAT
        case 35664:
            return setValueV2f; // _VEC2
        case 35665:
            return setValueV3f; // _VEC3
        case 35666:
            return setValueV4f; // _VEC4
        case 35674:
            return setValueM2; // _MAT2
        case 35675:
            return setValueM3; // _MAT3
        case 35676:
            return setValueM4; // _MAT4
        case 5124:
        case 35670:
            return setValueV1i; // INT, BOOL
        case 35667:
        case 35671:
            return setValueV2i; // _VEC2
        case 35668:
        case 35672:
            return setValueV3i; // _VEC3
        case 35669:
        case 35673:
            return setValueV4i; // _VEC4
        case 5125:
            return setValueV1ui; // UINT
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return setValueT1;
        case 35679:
        case 36299:
        case 36307:
            return setValueT3D1;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return setValueT6;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return setValueT2DArray1;
    }
}
// Array of scalars
function setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
}
// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
}
// Array of vectors (flat or from THREE classes)
function setValueV2fArray(gl, v) {
    const data = flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
    const data = flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data);
}
// Array of matrices (flat or from THREE clases)
function setValueM2Array(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
    const data = flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
    const data = flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
}
// Array of textures (2D / Cube)
function setValueT1Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i116 = 0; i116 !== n; ++i116)textures.safeSetTexture2D(v[i116] || emptyTexture, units[i116]);
}
function setValueT6Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i117 = 0; i117 !== n; ++i117)textures.safeSetTextureCube(v[i117] || emptyCubeTexture, units[i117]);
}
// Helper to pick the right setter for a pure (bottom-level) array
function getPureArraySetter(type) {
    switch(type){
        case 5126:
            return setValueV1fArray; // FLOAT
        case 35664:
            return setValueV2fArray; // _VEC2
        case 35665:
            return setValueV3fArray; // _VEC3
        case 35666:
            return setValueV4fArray; // _VEC4
        case 35674:
            return setValueM2Array; // _MAT2
        case 35675:
            return setValueM3Array; // _MAT3
        case 35676:
            return setValueM4Array; // _MAT4
        case 5124:
        case 35670:
            return setValueV1iArray; // INT, BOOL
        case 35667:
        case 35671:
            return setValueV2iArray; // _VEC2
        case 35668:
        case 35672:
            return setValueV3iArray; // _VEC3
        case 35669:
        case 35673:
            return setValueV4iArray; // _VEC4
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return setValueT1Array;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return setValueT6Array;
    }
}
// --- Uniform Classes ---
function SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
// this.path = activeInfo.name; // DEBUG
}
function PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
// this.path = activeInfo.name; // DEBUG
}
PureArrayUniform.prototype.updateCache = function(data) {
    let cache = this.cache;
    if (data instanceof Float32Array && cache.length !== data.length) this.cache = new Float32Array(data.length);
    copyArray(cache, data);
};
function StructuredUniform(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
    const seq = this.seq;
    for(let i118 = 0, n = seq.length; i118 !== n; ++i118){
        const u = seq[i118];
        u.setValue(gl, value[u.id], textures);
    }
};
// --- Top-level ---
// Parser - builds up the property tree from the path strings
const RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    // reset RegExp object, because of the early exit of a previous run
    RePathPart.lastIndex = 0;
    while(true){
        const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
        let id = match[1], idIsIndex = match[2] === ']', subscript = match[3];
        if (idIsIndex) id = id | 0; // convert to integer
        if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
            // bare name or "pure" bottom-level array "[0]" suffix
            addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
            break;
        } else {
            // step into inner node / create it in case it doesn't exist
            const map = container.map;
            let next = map[id];
            if (next === undefined) {
                next = new StructuredUniform(id);
                addUniform(container, next);
            }
            container = next;
        }
    }
}
// Root Container
function WebGLUniforms(gl, program) {
    this.seq = [];
    this.map = {};
    const n = gl.getProgramParameter(program, 35718);
    for(let i119 = 0; i119 < n; ++i119){
        const info = gl.getActiveUniform(program, i119), addr = gl.getUniformLocation(program, info.name);
        parseUniform(info, addr, this);
    }
}
WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== undefined) u.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name) {
    const v = object[name];
    if (v !== undefined) this.setValue(gl, name, v);
};
// Static interface
WebGLUniforms.upload = function(gl, seq, values, textures) {
    for(let i120 = 0, n = seq.length; i120 !== n; ++i120){
        const u = seq[i120], v = values[u.id];
        if (v.needsUpdate !== false) // note: always updating when .needsUpdate is undefined
        u.setValue(gl, v.value, textures);
    }
};
WebGLUniforms.seqWithValue = function(seq, values) {
    const r = [];
    for(let i121 = 0, n = seq.length; i121 !== n; ++i121){
        const u = seq[i121];
        if (u.id in values) r.push(u);
    }
    return r;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLShader(gl, type, string) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ let programIdCount = 0;
function addLineNumbers(string) {
    const lines = string.split('\n');
    for(let i122 = 0; i122 < lines.length; i122++)lines[i122] = i122 + 1 + ': ' + lines[i122];
    return lines.join('\n');
}
function getEncodingComponents(encoding) {
    switch(encoding){
        case LinearEncoding:
            return [
                'Linear',
                '( value )'
            ];
        case sRGBEncoding:
            return [
                'sRGB',
                '( value )'
            ];
        case RGBEEncoding:
            return [
                'RGBE',
                '( value )'
            ];
        case RGBM7Encoding:
            return [
                'RGBM',
                '( value, 7.0 )'
            ];
        case RGBM16Encoding:
            return [
                'RGBM',
                '( value, 16.0 )'
            ];
        case RGBDEncoding:
            return [
                'RGBD',
                '( value, 256.0 )'
            ];
        case GammaEncoding:
            return [
                'Gamma',
                '( value, float( GAMMA_FACTOR ) )'
            ];
        case LogLuvEncoding:
            return [
                'LogLuv',
                '( value )'
            ];
        default:
            console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
            return [
                'Linear',
                '( value )'
            ];
    }
}
function getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, 35713);
    const log = gl.getShaderInfoLog(shader).trim();
    if (status && log === '') return '';
    // --enable-privileged-webgl-extension
    // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
    const source = gl.getShaderSource(shader);
    return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
}
function getTexelDecodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
}
function getTexelEncodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}
function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch(toneMapping){
        case LinearToneMapping:
            toneMappingName = 'Linear';
            break;
        case ReinhardToneMapping:
            toneMappingName = 'Reinhard';
            break;
        case CineonToneMapping:
            toneMappingName = 'OptimizedCineon';
            break;
        case ACESFilmicToneMapping:
            toneMappingName = 'ACESFilmic';
            break;
        case CustomToneMapping:
            toneMappingName = 'Custom';
            break;
        default:
            console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
            toneMappingName = 'Linear';
    }
    return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}
function generateExtensions(parameters) {
    const chunks = [
        parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '',
        (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
        parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '',
        (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
    ];
    return chunks.filter(filterEmptyLine).join('\n');
}
function generateDefines(defines) {
    const chunks = [];
    for(const name in defines){
        const value = defines[name];
        if (value === false) continue;
        chunks.push('#define ' + name + ' ' + value);
    }
    return chunks.join('\n');
}
function fetchAttributeLocations(gl, program) {
    const attributes = {};
    const n = gl.getProgramParameter(program, 35721);
    for(let i123 = 0; i123 < n; i123++){
        const info = gl.getActiveAttrib(program, i123);
        const name = info.name;
        // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
        attributes[name] = gl.getAttribLocation(program, name);
    }
    return attributes;
}
function filterEmptyLine(string) {
    return string !== '';
}
function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
// Resolve Includes
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
    const string = ShaderChunk[include];
    if (string === undefined) throw new Error('Can not resolve #include <' + include + '>');
    return resolveIncludes(string);
}
// Unroll Loops
const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;
function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start, end, snippet) {
    console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
    return loopReplacer(match, start, end, snippet);
}
function loopReplacer(match, start, end, snippet) {
    let string = '';
    for(let i124 = parseInt(start); i124 < parseInt(end); i124++)string += snippet.replace(/\[ i \]/g, '[ ' + i124 + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i124);
    return string;
}
//
function generatePrecision(parameters) {
    let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
    if (parameters.precision === "highp") precisionstring += "\n#define HIGH_PRECISION";
    else if (parameters.precision === "mediump") precisionstring += "\n#define MEDIUM_PRECISION";
    else if (parameters.precision === "lowp") precisionstring += "\n#define LOW_PRECISION";
    return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
    if (parameters.shadowMapType === PCFShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
    else if (parameters.shadowMapType === PCFSoftShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
    else if (parameters.shadowMapType === VSMShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
    return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    if (parameters.envMap) switch(parameters.envMapMode){
        case CubeReflectionMapping:
        case CubeRefractionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
            break;
        case CubeUVReflectionMapping:
        case CubeUVRefractionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
            break;
        case EquirectangularReflectionMapping:
        case EquirectangularRefractionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
            break;
    }
    return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    if (parameters.envMap) switch(parameters.envMapMode){
        case CubeRefractionMapping:
        case EquirectangularRefractionMapping:
            envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
            break;
    }
    return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
    if (parameters.envMap) switch(parameters.combine){
        case MultiplyOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
            break;
        case MixOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
            break;
        case AddOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
            break;
    }
    return envMapBlendingDefine;
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
    const gl = renderer.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
    const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    if (parameters.isRawShaderMaterial) {
        prefixVertex = [
            customDefines
        ].filter(filterEmptyLine).join('\n');
        if (prefixVertex.length > 0) prefixVertex += '\n';
        prefixFragment = [
            customExtensions,
            customDefines
        ].filter(filterEmptyLine).join('\n');
        if (prefixFragment.length > 0) prefixFragment += '\n';
    } else {
        prefixVertex = [
            generatePrecision(parameters),
            '#define SHADER_NAME ' + parameters.shaderName,
            customDefines,
            parameters.instancing ? '#define USE_INSTANCING' : '',
            parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
            '#define GAMMA_FACTOR ' + gammaFactorDefine,
            '#define MAX_BONES ' + parameters.maxBones,
            parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
            parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',
            parameters.map ? '#define USE_MAP' : '',
            parameters.envMap ? '#define USE_ENVMAP' : '',
            parameters.envMap ? '#define ' + envMapModeDefine : '',
            parameters.lightMap ? '#define USE_LIGHTMAP' : '',
            parameters.aoMap ? '#define USE_AOMAP' : '',
            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            parameters.bumpMap ? '#define USE_BUMPMAP' : '',
            parameters.normalMap ? '#define USE_NORMALMAP' : '',
            parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
            parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
            parameters.specularMap ? '#define USE_SPECULARMAP' : '',
            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
            parameters.vertexTangents ? '#define USE_TANGENT' : '',
            parameters.vertexColors ? '#define USE_COLOR' : '',
            parameters.vertexUvs ? '#define USE_UV' : '',
            parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            parameters.flatShading ? '#define FLAT_SHADED' : '',
            parameters.skinning ? '#define USE_SKINNING' : '',
            parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
            parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
            parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
            parameters.flipSided ? '#define FLIP_SIDED' : '',
            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
            parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
            'uniform mat4 modelMatrix;',
            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform mat4 viewMatrix;',
            'uniform mat3 normalMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            '#ifdef USE_INSTANCING',
            ' attribute mat4 instanceMatrix;',
            '#endif',
            'attribute vec3 position;',
            'attribute vec3 normal;',
            'attribute vec2 uv;',
            '#ifdef USE_TANGENT',
            '	attribute vec4 tangent;',
            '#endif',
            '#ifdef USE_COLOR',
            '	attribute vec3 color;',
            '#endif',
            '#ifdef USE_MORPHTARGETS',
            '	attribute vec3 morphTarget0;',
            '	attribute vec3 morphTarget1;',
            '	attribute vec3 morphTarget2;',
            '	attribute vec3 morphTarget3;',
            '	#ifdef USE_MORPHNORMALS',
            '		attribute vec3 morphNormal0;',
            '		attribute vec3 morphNormal1;',
            '		attribute vec3 morphNormal2;',
            '		attribute vec3 morphNormal3;',
            '	#else',
            '		attribute vec3 morphTarget4;',
            '		attribute vec3 morphTarget5;',
            '		attribute vec3 morphTarget6;',
            '		attribute vec3 morphTarget7;',
            '	#endif',
            '#endif',
            '#ifdef USE_SKINNING',
            '	attribute vec4 skinIndex;',
            '	attribute vec4 skinWeight;',
            '#endif',
            '\n'
        ].filter(filterEmptyLine).join('\n');
        prefixFragment = [
            customExtensions,
            generatePrecision(parameters),
            '#define SHADER_NAME ' + parameters.shaderName,
            customDefines,
            parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '',
            '#define GAMMA_FACTOR ' + gammaFactorDefine,
            parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
            parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',
            parameters.map ? '#define USE_MAP' : '',
            parameters.matcap ? '#define USE_MATCAP' : '',
            parameters.envMap ? '#define USE_ENVMAP' : '',
            parameters.envMap ? '#define ' + envMapTypeDefine : '',
            parameters.envMap ? '#define ' + envMapModeDefine : '',
            parameters.envMap ? '#define ' + envMapBlendingDefine : '',
            parameters.lightMap ? '#define USE_LIGHTMAP' : '',
            parameters.aoMap ? '#define USE_AOMAP' : '',
            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            parameters.bumpMap ? '#define USE_BUMPMAP' : '',
            parameters.normalMap ? '#define USE_NORMALMAP' : '',
            parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
            parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            parameters.specularMap ? '#define USE_SPECULARMAP' : '',
            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
            parameters.sheen ? '#define USE_SHEEN' : '',
            parameters.vertexTangents ? '#define USE_TANGENT' : '',
            parameters.vertexColors ? '#define USE_COLOR' : '',
            parameters.vertexUvs ? '#define USE_UV' : '',
            parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
            parameters.flatShading ? '#define FLAT_SHADED' : '',
            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
            parameters.flipSided ? '#define FLIP_SIDED' : '',
            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
            parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
            parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
            (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '',
            'uniform mat4 viewMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '',
            parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '',
            parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',
            parameters.dithering ? '#define DITHERING' : '',
            ShaderChunk['encodings_pars_fragment'],
            parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
            parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '',
            parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
            parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
            parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '',
            getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding),
            parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',
            '\n'
        ].filter(filterEmptyLine).join('\n');
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isWebGL2 && !parameters.isRawShaderMaterial) {
        let isGLSL3ShaderMaterial = false;
        const versionRegex = /^\s*#version\s+300\s+es\s*\n/;
        if (parameters.isShaderMaterial && vertexShader.match(versionRegex) !== null && fragmentShader.match(versionRegex) !== null) {
            isGLSL3ShaderMaterial = true;
            vertexShader = vertexShader.replace(versionRegex, '');
            fragmentShader = fragmentShader.replace(versionRegex, '');
        }
        // GLSL 3.0 conversion
        prefixVertex = [
            '#version 300 es\n',
            '#define attribute in',
            '#define varying out',
            '#define texture2D texture'
        ].join('\n') + '\n' + prefixVertex;
        prefixFragment = [
            '#version 300 es\n',
            '#define varying in',
            isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
            isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
            '#define gl_FragDepthEXT gl_FragDepth',
            '#define texture2D texture',
            '#define textureCube texture',
            '#define texture2DProj textureProj',
            '#define texture2DLodEXT textureLod',
            '#define texture2DProjLodEXT textureProjLod',
            '#define textureCubeLodEXT textureLod',
            '#define texture2DGradEXT textureGrad',
            '#define texture2DProjGradEXT textureProjGrad',
            '#define textureCubeGradEXT textureGrad'
        ].join('\n') + '\n' + prefixFragment;
    }
    const vertexGlsl = prefixVertex + vertexShader;
    const fragmentGlsl = prefixFragment + fragmentShader;
    // console.log( '*VERTEX*', vertexGlsl );
    // console.log( '*FRAGMENT*', fragmentGlsl );
    const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
    const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    // Force a particular attribute to index 0.
    if (parameters.index0AttributeName !== undefined) gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    else if (parameters.morphTargets === true) // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, 'position');
    gl.linkProgram(program);
    // check for link errors
    if (renderer.debug.checkShaderErrors) {
        const programLog = gl.getProgramInfoLog(program).trim();
        const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
        const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
        let runnable = true;
        let haveDiagnostics = true;
        if (gl.getProgramParameter(program, 35714) === false) {
            runnable = false;
            const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
            const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
            console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
        } else if (programLog !== '') console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
        else if (vertexLog === '' || fragmentLog === '') haveDiagnostics = false;
        if (haveDiagnostics) this.diagnostics = {
            runnable: runnable,
            programLog: programLog,
            vertexShader: {
                log: vertexLog,
                prefix: prefixVertex
            },
            fragmentShader: {
                log: fragmentLog,
                prefix: prefixFragment
            }
        };
    }
    // Clean up
    // Crashes in iOS9 and iOS10. #18402
    // gl.detachShader( program, glVertexShader );
    // gl.detachShader( program, glFragmentShader );
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    // set up caching for uniform locations
    let cachedUniforms;
    this.getUniforms = function() {
        if (cachedUniforms === undefined) cachedUniforms = new WebGLUniforms(gl, program);
        return cachedUniforms;
    };
    // set up caching for attribute locations
    let cachedAttributes;
    this.getAttributes = function() {
        if (cachedAttributes === undefined) cachedAttributes = fetchAttributeLocations(gl, program);
        return cachedAttributes;
    };
    // free resource
    this.destroy = function() {
        bindingStates.releaseStatesOfProgram(this);
        gl.deleteProgram(program);
        this.program = undefined;
    };
    //
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLPrograms(renderer, extensions, capabilities, bindingStates) {
    const programs = [];
    const isWebGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const floatVertexTextures = capabilities.floatVertexTextures;
    const maxVertexUniforms = capabilities.maxVertexUniforms;
    const vertexTextures = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshDistanceMaterial: 'distanceRGBA',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        MeshToonMaterial: 'toon',
        MeshStandardMaterial: 'physical',
        MeshPhysicalMaterial: 'physical',
        MeshMatcapMaterial: 'matcap',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points',
        ShadowMaterial: 'shadow',
        SpriteMaterial: 'sprite'
    };
    const parameterNames = [
        "precision",
        "isWebGL2",
        "supportsVertexTextures",
        "outputEncoding",
        "instancing",
        "map",
        "mapEncoding",
        "matcap",
        "matcapEncoding",
        "envMap",
        "envMapMode",
        "envMapEncoding",
        "envMapCubeUV",
        "lightMap",
        "lightMapEncoding",
        "aoMap",
        "emissiveMap",
        "emissiveMapEncoding",
        "bumpMap",
        "normalMap",
        "objectSpaceNormalMap",
        "tangentSpaceNormalMap",
        "clearcoatMap",
        "clearcoatRoughnessMap",
        "clearcoatNormalMap",
        "displacementMap",
        "specularMap",
        "roughnessMap",
        "metalnessMap",
        "gradientMap",
        "alphaMap",
        "combine",
        "vertexColors",
        "vertexTangents",
        "vertexUvs",
        "uvsVertexOnly",
        "fog",
        "useFog",
        "fogExp2",
        "flatShading",
        "sizeAttenuation",
        "logarithmicDepthBuffer",
        "skinning",
        "maxBones",
        "useVertexTexture",
        "morphTargets",
        "morphNormals",
        "maxMorphTargets",
        "maxMorphNormals",
        "premultipliedAlpha",
        "numDirLights",
        "numPointLights",
        "numSpotLights",
        "numHemiLights",
        "numRectAreaLights",
        "numDirLightShadows",
        "numPointLightShadows",
        "numSpotLightShadows",
        "shadowMapEnabled",
        "shadowMapType",
        "toneMapping",
        'physicallyCorrectLights',
        "alphaTest",
        "doubleSided",
        "flipSided",
        "numClippingPlanes",
        "numClipIntersection",
        "depthPacking",
        "dithering",
        "sheen"
    ];
    function getShaderObject(material, shaderID) {
        let shaderobject;
        if (shaderID) {
            const shader = ShaderLib[shaderID];
            shaderobject = {
                name: material.name || material.type,
                uniforms: UniformsUtils.clone(shader.uniforms),
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader
            };
        } else shaderobject = {
            name: material.name || material.type,
            uniforms: material.uniforms,
            vertexShader: material.vertexShader,
            fragmentShader: material.fragmentShader
        };
        return shaderobject;
    }
    function allocateBones(object) {
        const skeleton = object.skeleton;
        const bones = skeleton.bones;
        if (floatVertexTextures) return 1024;
        else {
            // default for when object is not specified
            // ( for example when prebuilding shader to be used with multiple objects )
            //
            //  - leave some extra space for other uniforms
            //  - limit here is ANGLE's 254 max uniform vectors
            //    (up to 54 should be safe)
            const nVertexUniforms = maxVertexUniforms;
            const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
            const maxBones = Math.min(nVertexMatrices, bones.length);
            if (maxBones < bones.length) {
                console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                return 0;
            }
            return maxBones;
        }
    }
    function getTextureEncodingFromMap(map) {
        let encoding;
        if (!map) encoding = LinearEncoding;
        else if (map.isTexture) encoding = map.encoding;
        else if (map.isWebGLRenderTarget) {
            console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
            encoding = map.texture.encoding;
        }
        return encoding;
    }
    function getParameters(material, lights, shadows, scene, nClipPlanes, nClipIntersection, object) {
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const envMap = material.envMap || environment;
        const shaderID = shaderIDs[material.type];
        // heuristics to create shader parameters according to lights in the scene
        // (not to blow over maxLights budget)
        const maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
        if (material.precision !== null) {
            precision = capabilities.getMaxPrecision(material.precision);
            if (precision !== material.precision) console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
        }
        const shaderobject = getShaderObject(material, shaderID);
        material.onBeforeCompile(shaderobject, renderer);
        const currentRenderTarget = renderer.getRenderTarget();
        const parameters = {
            isWebGL2: isWebGL2,
            shaderID: shaderID,
            shaderName: shaderobject.name,
            uniforms: shaderobject.uniforms,
            vertexShader: shaderobject.vertexShader,
            fragmentShader: shaderobject.fragmentShader,
            defines: material.defines,
            isRawShaderMaterial: material.isRawShaderMaterial,
            isShaderMaterial: material.isShaderMaterial,
            precision: precision,
            instancing: object.isInstancedMesh === true,
            supportsVertexTextures: vertexTextures,
            outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
            map: !!material.map,
            mapEncoding: getTextureEncodingFromMap(material.map),
            matcap: !!material.matcap,
            matcapEncoding: getTextureEncodingFromMap(material.matcap),
            envMap: !!envMap,
            envMapMode: envMap && envMap.mapping,
            envMapEncoding: getTextureEncodingFromMap(envMap),
            envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
            lightMap: !!material.lightMap,
            lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
            tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
            clearcoatMap: !!material.clearcoatMap,
            clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
            clearcoatNormalMap: !!material.clearcoatNormalMap,
            displacementMap: !!material.displacementMap,
            roughnessMap: !!material.roughnessMap,
            metalnessMap: !!material.metalnessMap,
            specularMap: !!material.specularMap,
            alphaMap: !!material.alphaMap,
            gradientMap: !!material.gradientMap,
            sheen: !!material.sheen,
            combine: material.combine,
            vertexTangents: material.normalMap && material.vertexTangents,
            vertexColors: material.vertexColors,
            vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap,
            uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap) && !!material.displacementMap,
            fog: !!fog,
            useFog: material.fog,
            fogExp2: fog && fog.isFogExp2,
            flatShading: material.flatShading,
            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            skinning: material.skinning && maxBones > 0,
            maxBones: maxBones,
            useVertexTexture: floatVertexTextures,
            morphTargets: material.morphTargets,
            morphNormals: material.morphNormals,
            maxMorphTargets: renderer.maxMorphTargets,
            maxMorphNormals: renderer.maxMorphNormals,
            numDirLights: lights.directional.length,
            numPointLights: lights.point.length,
            numSpotLights: lights.spot.length,
            numRectAreaLights: lights.rectArea.length,
            numHemiLights: lights.hemi.length,
            numDirLightShadows: lights.directionalShadowMap.length,
            numPointLightShadows: lights.pointShadowMap.length,
            numSpotLightShadows: lights.spotShadowMap.length,
            numClippingPlanes: nClipPlanes,
            numClipIntersection: nClipIntersection,
            dithering: material.dithering,
            shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
            shadowMapType: renderer.shadowMap.type,
            toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
            physicallyCorrectLights: renderer.physicallyCorrectLights,
            premultipliedAlpha: material.premultipliedAlpha,
            alphaTest: material.alphaTest,
            doubleSided: material.side === DoubleSide,
            flipSided: material.side === BackSide,
            depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
            index0AttributeName: material.index0AttributeName,
            extensionDerivatives: material.extensions && material.extensions.derivatives,
            extensionFragDepth: material.extensions && material.extensions.fragDepth,
            extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
            extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: isWebGL2 || extensions.get('EXT_frag_depth') !== null,
            rendererExtensionDrawBuffers: isWebGL2 || extensions.get('WEBGL_draw_buffers') !== null,
            rendererExtensionShaderTextureLod: isWebGL2 || extensions.get('EXT_shader_texture_lod') !== null,
            customProgramCacheKey: material.customProgramCacheKey()
        };
        return parameters;
    }
    function getProgramCacheKey(parameters) {
        const array = [];
        if (parameters.shaderID) array.push(parameters.shaderID);
        else {
            array.push(parameters.fragmentShader);
            array.push(parameters.vertexShader);
        }
        if (parameters.defines !== undefined) for(const name in parameters.defines){
            array.push(name);
            array.push(parameters.defines[name]);
        }
        if (parameters.isRawShaderMaterial === undefined) {
            for(let i125 = 0; i125 < parameterNames.length; i125++)array.push(parameters[parameterNames[i125]]);
            array.push(renderer.outputEncoding);
            array.push(renderer.gammaFactor);
        }
        array.push(parameters.customProgramCacheKey);
        return array.join();
    }
    function acquireProgram(parameters, cacheKey) {
        let program;
        // Check if code has been already compiled
        for(let p = 0, pl = programs.length; p < pl; p++){
            const preexistingProgram = programs[p];
            if (preexistingProgram.cacheKey === cacheKey) {
                program = preexistingProgram;
                ++program.usedTimes;
                break;
            }
        }
        if (program === undefined) {
            program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
            programs.push(program);
        }
        return program;
    }
    function releaseProgram(program) {
        if (--program.usedTimes === 0) {
            // Remove from unordered set
            const i126 = programs.indexOf(program);
            programs[i126] = programs[programs.length - 1];
            programs.pop();
            // Free WebGL resources
            program.destroy();
        }
    }
    return {
        getParameters: getParameters,
        getProgramCacheKey: getProgramCacheKey,
        acquireProgram: acquireProgram,
        releaseProgram: releaseProgram,
        // Exposed for resource monitoring & error feedback via renderer.info:
        programs: programs
    };
}
/**
 * @author fordacious / fordacious.github.io
 */ function WebGLProperties() {
    let properties = new WeakMap();
    function get(object) {
        let map = properties.get(object);
        if (map === undefined) {
            map = {};
            properties.set(object, map);
        }
        return map;
    }
    function remove(object) {
        properties.delete(object);
    }
    function update(object, key, value) {
        properties.get(object)[key] = value;
    }
    function dispose() {
        properties = new WeakMap();
    }
    return {
        get: get,
        remove: remove,
        update: update,
        dispose: dispose
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function painterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) return a.groupOrder - b.groupOrder;
    else if (a.renderOrder !== b.renderOrder) return a.renderOrder - b.renderOrder;
    else if (a.program !== b.program) return a.program.id - b.program.id;
    else if (a.material.id !== b.material.id) return a.material.id - b.material.id;
    else if (a.z !== b.z) return a.z - b.z;
    else return a.id - b.id;
}
function reversePainterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) return a.groupOrder - b.groupOrder;
    else if (a.renderOrder !== b.renderOrder) return a.renderOrder - b.renderOrder;
    else if (a.z !== b.z) return b.z - a.z;
    else return a.id - b.id;
}
function WebGLRenderList() {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transparent = [];
    const defaultProgram = {
        id: -1
    };
    function init() {
        renderItemsIndex = 0;
        opaque.length = 0;
        transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
        let renderItem = renderItems[renderItemsIndex];
        if (renderItem === undefined) {
            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                program: material.program || defaultProgram,
                groupOrder: groupOrder,
                renderOrder: object.renderOrder,
                z: z,
                group: group
            };
            renderItems[renderItemsIndex] = renderItem;
        } else {
            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.program = material.program || defaultProgram;
            renderItem.groupOrder = groupOrder;
            renderItem.renderOrder = object.renderOrder;
            renderItem.z = z;
            renderItem.group = group;
        }
        renderItemsIndex++;
        return renderItem;
    }
    function push(object, geometry, material, groupOrder, z, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
        (material.transparent === true ? transparent : opaque).push(renderItem);
    }
    function unshift(object, geometry, material, groupOrder, z, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
        (material.transparent === true ? transparent : opaque).unshift(renderItem);
    }
    function sort(customOpaqueSort, customTransparentSort) {
        if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
        if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
    }
    function finish() {
        // Clear references from inactive renderItems in the list
        for(let i127 = renderItemsIndex, il = renderItems.length; i127 < il; i127++){
            const renderItem = renderItems[i127];
            if (renderItem.id === null) break;
            renderItem.id = null;
            renderItem.object = null;
            renderItem.geometry = null;
            renderItem.material = null;
            renderItem.program = null;
            renderItem.group = null;
        }
    }
    return {
        opaque: opaque,
        transparent: transparent,
        init: init,
        push: push,
        unshift: unshift,
        finish: finish,
        sort: sort
    };
}
function WebGLRenderLists() {
    let lists = new WeakMap();
    function onSceneDispose(event) {
        const scene = event.target;
        scene.removeEventListener('dispose', onSceneDispose);
        lists.delete(scene);
    }
    function get(scene, camera) {
        const cameras = lists.get(scene);
        let list;
        if (cameras === undefined) {
            list = new WebGLRenderList();
            lists.set(scene, new WeakMap());
            lists.get(scene).set(camera, list);
            scene.addEventListener('dispose', onSceneDispose);
        } else {
            list = cameras.get(camera);
            if (list === undefined) {
                list = new WebGLRenderList();
                cameras.set(camera, list);
            }
        }
        return list;
    }
    function dispose() {
        lists = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function UniformsCache() {
    const lights = {};
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) return lights[light.id];
            let uniforms;
            switch(light.type){
                case 'DirectionalLight':
                    uniforms = {
                        direction: new Vector3(),
                        color: new Color()
                    };
                    break;
                case 'SpotLight':
                    uniforms = {
                        position: new Vector3(),
                        direction: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case 'PointLight':
                    uniforms = {
                        position: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        decay: 0
                    };
                    break;
                case 'HemisphereLight':
                    uniforms = {
                        direction: new Vector3(),
                        skyColor: new Color(),
                        groundColor: new Color()
                    };
                    break;
                case 'RectAreaLight':
                    uniforms = {
                        color: new Color(),
                        position: new Vector3(),
                        halfWidth: new Vector3(),
                        halfHeight: new Vector3()
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
function ShadowUniformsCache() {
    const lights = {};
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) return lights[light.id];
            let uniforms;
            switch(light.type){
                case 'DirectionalLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;
                case 'SpotLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;
                case 'PointLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1000
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
let nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights() {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        },
        ambient: [
            0,
            0,
            0
        ],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
    };
    for(let i128 = 0; i128 < 9; i128++)state.probe.push(new Vector3());
    const vector3 = new Vector3();
    const matrix4 = new Matrix4();
    const matrix42 = new Matrix4();
    function setup(lights, shadows, camera) {
        let r = 0, g = 0, b = 0;
        for(let i130 = 0; i130 < 9; i130++)state.probe[i130].set(0, 0, 0);
        let directionalLength = 0;
        let pointLength = 0;
        let spotLength = 0;
        let rectAreaLength = 0;
        let hemiLength = 0;
        let numDirectionalShadows = 0;
        let numPointShadows = 0;
        let numSpotShadows = 0;
        const viewMatrix = camera.matrixWorldInverse;
        lights.sort(shadowCastingLightsFirst);
        for(let i129 = 0, l = lights.length; i129 < l; i129++){
            const light = lights[i129];
            const color = light.color;
            const intensity = light.intensity;
            const distance = light.distance;
            const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
            if (light.isAmbientLight) {
                r += color.r * intensity;
                g += color.g * intensity;
                b += color.b * intensity;
            } else if (light.isLightProbe) for(let j = 0; j < 9; j++)state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
            else if (light.isDirectionalLight) {
                const uniforms = cache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    state.directionalShadow[directionalLength] = shadowUniforms;
                    state.directionalShadowMap[directionalLength] = shadowMap;
                    state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                    numDirectionalShadows++;
                }
                state.directional[directionalLength] = uniforms;
                directionalLength++;
            } else if (light.isSpotLight) {
                const uniforms = cache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.color.copy(color).multiplyScalar(intensity);
                uniforms.distance = distance;
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.coneCos = Math.cos(light.angle);
                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                uniforms.decay = light.decay;
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    state.spotShadow[spotLength] = shadowUniforms;
                    state.spotShadowMap[spotLength] = shadowMap;
                    state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                    numSpotShadows++;
                }
                state.spot[spotLength] = uniforms;
                spotLength++;
            } else if (light.isRectAreaLight) {
                const uniforms = cache.get(light);
                // (a) intensity is the total visible light emitted
                //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
                // (b) intensity is the brightness of the light
                uniforms.color.copy(color).multiplyScalar(intensity);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                // extract local rotation of light to derive width/height half vectors
                matrix42.identity();
                matrix4.copy(light.matrixWorld);
                matrix4.premultiply(viewMatrix);
                matrix42.extractRotation(matrix4);
                uniforms.halfWidth.set(light.width * 0.5, 0, 0);
                uniforms.halfHeight.set(0, light.height * 0.5, 0);
                uniforms.halfWidth.applyMatrix4(matrix42);
                uniforms.halfHeight.applyMatrix4(matrix42);
                // TODO (abelnation): RectAreaLight distance?
                // uniforms.distance = distance;
                state.rectArea[rectAreaLength] = uniforms;
                rectAreaLength++;
            } else if (light.isPointLight) {
                const uniforms = cache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.distance = light.distance;
                uniforms.decay = light.decay;
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    shadowUniforms.shadowCameraNear = shadow.camera.near;
                    shadowUniforms.shadowCameraFar = shadow.camera.far;
                    state.pointShadow[pointLength] = shadowUniforms;
                    state.pointShadowMap[pointLength] = shadowMap;
                    state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                    numPointShadows++;
                }
                state.point[pointLength] = uniforms;
                pointLength++;
            } else if (light.isHemisphereLight) {
                const uniforms = cache.get(light);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.direction.normalize();
                uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                state.hemi[hemiLength] = uniforms;
                hemiLength++;
            }
        }
        state.ambient[0] = r;
        state.ambient[1] = g;
        state.ambient[2] = b;
        const hash = state.hash;
        if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
            state.directional.length = directionalLength;
            state.spot.length = spotLength;
            state.rectArea.length = rectAreaLength;
            state.point.length = pointLength;
            state.hemi.length = hemiLength;
            state.directionalShadow.length = numDirectionalShadows;
            state.directionalShadowMap.length = numDirectionalShadows;
            state.pointShadow.length = numPointShadows;
            state.pointShadowMap.length = numPointShadows;
            state.spotShadow.length = numSpotShadows;
            state.spotShadowMap.length = numSpotShadows;
            state.directionalShadowMatrix.length = numDirectionalShadows;
            state.pointShadowMatrix.length = numPointShadows;
            state.spotShadowMatrix.length = numSpotShadows;
            hash.directionalLength = directionalLength;
            hash.pointLength = pointLength;
            hash.spotLength = spotLength;
            hash.rectAreaLength = rectAreaLength;
            hash.hemiLength = hemiLength;
            hash.numDirectionalShadows = numDirectionalShadows;
            hash.numPointShadows = numPointShadows;
            hash.numSpotShadows = numSpotShadows;
            state.version = nextVersion++;
        }
    }
    return {
        setup: setup,
        state: state
    };
}
/**
 * @author Mugen87 / https://github.com/Mugen87
 */ function WebGLRenderState() {
    const lights = new WebGLLights();
    const lightsArray = [];
    const shadowsArray = [];
    function init() {
        lightsArray.length = 0;
        shadowsArray.length = 0;
    }
    function pushLight(light) {
        lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
        shadowsArray.push(shadowLight);
    }
    function setupLights(camera) {
        lights.setup(lightsArray, shadowsArray, camera);
    }
    const state = {
        lightsArray: lightsArray,
        shadowsArray: shadowsArray,
        lights: lights
    };
    return {
        init: init,
        state: state,
        setupLights: setupLights,
        pushLight: pushLight,
        pushShadow: pushShadow
    };
}
function WebGLRenderStates() {
    let renderStates = new WeakMap();
    function onSceneDispose(event) {
        const scene = event.target;
        scene.removeEventListener('dispose', onSceneDispose);
        renderStates.delete(scene);
    }
    function get(scene, camera) {
        let renderState;
        if (renderStates.has(scene) === false) {
            renderState = new WebGLRenderState();
            renderStates.set(scene, new WeakMap());
            renderStates.get(scene).set(camera, renderState);
            scene.addEventListener('dispose', onSceneDispose);
        } else if (renderStates.get(scene).has(camera) === false) {
            renderState = new WebGLRenderState();
            renderStates.get(scene).set(camera, renderState);
        } else renderState = renderStates.get(scene).get(camera);
        return renderState;
    }
    function dispose() {
        renderStates = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */ function MeshDepthMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshDepthMaterial';
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
}
MeshDepthMaterial.prototype = Object.create(Material.prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
MeshDepthMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
};
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */ function MeshDistanceMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshDistanceMaterial';
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1000;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
}
MeshDistanceMaterial.prototype = Object.create(Material.prototype);
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
MeshDistanceMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
};
var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
    let _frustum = new Frustum();
    const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {};
    const shadowSide = {
        0: BackSide,
        1: FrontSide,
        2: DoubleSide
    };
    const shadowMaterialVertical = new ShaderMaterial({
        defines: {
            SAMPLE_RATE: 0.25,
            HALF_SAMPLE_RATE: 0.125
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new Vector2()
            },
            radius: {
                value: 4
            }
        },
        vertexShader: vsm_vert,
        fragmentShader: vsm_frag
    });
    const shadowMaterialHorizonal = shadowMaterialVertical.clone();
    shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
    const fullScreenTri = new BufferGeometry();
    fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([
        -1,
        -1,
        0.5,
        3,
        -1,
        0.5,
        -1,
        3,
        0.5
    ]), 3));
    const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
    const scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.render = function(lights, scene, camera) {
        if (scope.enabled === false) return;
        if (scope.autoUpdate === false && scope.needsUpdate === false) return;
        if (lights.length === 0) return;
        const currentRenderTarget = _renderer.getRenderTarget();
        const activeCubeFace = _renderer.getActiveCubeFace();
        const activeMipmapLevel = _renderer.getActiveMipmapLevel();
        const _state = _renderer.state;
        // Set GL state for depth map.
        _state.setBlending(NoBlending);
        _state.buffers.color.setClear(1, 1, 1, 1);
        _state.buffers.depth.setTest(true);
        _state.setScissorTest(false);
        // render depth map
        for(let i131 = 0, il = lights.length; i131 < il; i131++){
            const light = lights[i131];
            const shadow = light.shadow;
            if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
            if (shadow === undefined) {
                console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                continue;
            }
            _shadowMapSize.copy(shadow.mapSize);
            const shadowFrameExtents = shadow.getFrameExtents();
            _shadowMapSize.multiply(shadowFrameExtents);
            _viewportSize.copy(shadow.mapSize);
            if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
                if (_shadowMapSize.x > maxTextureSize) {
                    _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
                    _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                    shadow.mapSize.x = _viewportSize.x;
                }
                if (_shadowMapSize.y > maxTextureSize) {
                    _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
                    _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                    shadow.mapSize.y = _viewportSize.y;
                }
            }
            if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
                const pars = {
                    minFilter: LinearFilter,
                    magFilter: LinearFilter,
                    format: RGBAFormat
                };
                shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + ".shadowMap";
                shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.camera.updateProjectionMatrix();
            }
            if (shadow.map === null) {
                const pars = {
                    minFilter: NearestFilter,
                    magFilter: NearestFilter,
                    format: RGBAFormat
                };
                shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + ".shadowMap";
                shadow.camera.updateProjectionMatrix();
            }
            _renderer.setRenderTarget(shadow.map);
            _renderer.clear();
            const viewportCount = shadow.getViewportCount();
            for(let vp = 0; vp < viewportCount; vp++){
                const viewport = shadow.getViewport(vp);
                _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
                _state.viewport(_viewport);
                shadow.updateMatrices(light, vp);
                _frustum = shadow.getFrustum();
                renderObject(scene, camera, shadow.camera, light, this.type);
            }
            // do blur pass for VSM
            if (!shadow.isPointLightShadow && this.type === VSMShadowMap) VSMPass(shadow, camera);
            shadow.needsUpdate = false;
        }
        scope.needsUpdate = false;
        _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera) {
        const geometry = _objects.update(fullScreenMesh);
        // vertical pass
        shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
        shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialVertical.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.mapPass);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
        // horizonal pass
        shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
        shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);
    }
    function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
        const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
        let material = _depthMaterials[index];
        if (material === undefined) {
            material = new MeshDepthMaterial({
                depthPacking: RGBADepthPacking,
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _depthMaterials[index] = material;
        }
        return material;
    }
    function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
        const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
        let material = _distanceMaterials[index];
        if (material === undefined) {
            material = new MeshDistanceMaterial({
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _distanceMaterials[index] = material;
        }
        return material;
    }
    function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
        let result = null;
        let getMaterialVariant = getDepthMaterialVariant;
        let customMaterial = object.customDepthMaterial;
        if (light.isPointLight === true) {
            getMaterialVariant = getDistanceMaterialVariant;
            customMaterial = object.customDistanceMaterial;
        }
        if (customMaterial === undefined) {
            let useMorphing = false;
            if (material.morphTargets === true) useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
            let useSkinning = false;
            if (object.isSkinnedMesh === true) {
                if (material.skinning === true) useSkinning = true;
                else console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
            }
            const useInstancing = object.isInstancedMesh === true;
            result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
        } else result = customMaterial;
        if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
            // in this case we need a unique material instance reflecting the
            // appropriate state
            const keyA = result.uuid, keyB = material.uuid;
            let materialsForVariant = _materialCache[keyA];
            if (materialsForVariant === undefined) {
                materialsForVariant = {};
                _materialCache[keyA] = materialsForVariant;
            }
            let cachedMaterial = materialsForVariant[keyB];
            if (cachedMaterial === undefined) {
                cachedMaterial = result.clone();
                materialsForVariant[keyB] = cachedMaterial;
            }
            result = cachedMaterial;
        }
        result.visible = material.visible;
        result.wireframe = material.wireframe;
        if (type === VSMShadowMap) result.side = material.shadowSide !== null ? material.shadowSide : material.side;
        else result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
        result.clipShadows = material.clipShadows;
        result.clippingPlanes = material.clippingPlanes;
        result.clipIntersection = material.clipIntersection;
        result.wireframeLinewidth = material.wireframeLinewidth;
        result.linewidth = material.linewidth;
        if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
            result.referencePosition.setFromMatrixPosition(light.matrixWorld);
            result.nearDistance = shadowCameraNear;
            result.farDistance = shadowCameraFar;
        }
        return result;
    }
    function renderObject(object, camera, shadowCamera, light, type) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible && (object.isMesh || object.isLine || object.isPoints)) {
            if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                const geometry = _objects.update(object);
                const material = object.material;
                if (Array.isArray(material)) {
                    const groups = geometry.groups;
                    for(let k = 0, kl = groups.length; k < kl; k++){
                        const group = groups[k];
                        const groupMaterial = material[group.materialIndex];
                        if (groupMaterial && groupMaterial.visible) {
                            const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                        }
                    }
                } else if (material.visible) {
                    const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                }
            }
        }
        const children = object.children;
        for(let i132 = 0, l = children.length; i132 < l; i132++)renderObject(children[i132], camera, shadowCamera, light, type);
    }
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLState(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
        let locked = false;
        const color = new Vector4();
        let currentColorMask = null;
        const currentColorClear = new Vector4(0, 0, 0, 0);
        return {
            setMask: function(colorMask) {
                if (currentColorMask !== colorMask && !locked) {
                    gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                    currentColorMask = colorMask;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(r, g, b, a, premultipliedAlpha) {
                if (premultipliedAlpha === true) {
                    r *= a;
                    g *= a;
                    b *= a;
                }
                color.set(r, g, b, a);
                if (currentColorClear.equals(color) === false) {
                    gl.clearColor(r, g, b, a);
                    currentColorClear.copy(color);
                }
            },
            reset: function() {
                locked = false;
                currentColorMask = null;
                currentColorClear.set(-1, 0, 0, 0); // set to invalid state
            }
        };
    }
    function DepthBuffer() {
        let locked = false;
        let currentDepthMask = null;
        let currentDepthFunc = null;
        let currentDepthClear = null;
        return {
            setTest: function(depthTest) {
                if (depthTest) enable(2929);
                else disable(2929);
            },
            setMask: function(depthMask) {
                if (currentDepthMask !== depthMask && !locked) {
                    gl.depthMask(depthMask);
                    currentDepthMask = depthMask;
                }
            },
            setFunc: function(depthFunc) {
                if (currentDepthFunc !== depthFunc) {
                    if (depthFunc) switch(depthFunc){
                        case NeverDepth:
                            gl.depthFunc(512);
                            break;
                        case AlwaysDepth:
                            gl.depthFunc(519);
                            break;
                        case LessDepth:
                            gl.depthFunc(513);
                            break;
                        case LessEqualDepth:
                            gl.depthFunc(515);
                            break;
                        case EqualDepth:
                            gl.depthFunc(514);
                            break;
                        case GreaterEqualDepth:
                            gl.depthFunc(518);
                            break;
                        case GreaterDepth:
                            gl.depthFunc(516);
                            break;
                        case NotEqualDepth:
                            gl.depthFunc(517);
                            break;
                        default:
                            gl.depthFunc(515);
                    }
                    else gl.depthFunc(515);
                    currentDepthFunc = depthFunc;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(depth) {
                if (currentDepthClear !== depth) {
                    gl.clearDepth(depth);
                    currentDepthClear = depth;
                }
            },
            reset: function() {
                locked = false;
                currentDepthMask = null;
                currentDepthFunc = null;
                currentDepthClear = null;
            }
        };
    }
    function StencilBuffer() {
        let locked = false;
        let currentStencilMask = null;
        let currentStencilFunc = null;
        let currentStencilRef = null;
        let currentStencilFuncMask = null;
        let currentStencilFail = null;
        let currentStencilZFail = null;
        let currentStencilZPass = null;
        let currentStencilClear = null;
        return {
            setTest: function(stencilTest) {
                if (!locked) {
                    if (stencilTest) enable(2960);
                    else disable(2960);
                }
            },
            setMask: function(stencilMask) {
                if (currentStencilMask !== stencilMask && !locked) {
                    gl.stencilMask(stencilMask);
                    currentStencilMask = stencilMask;
                }
            },
            setFunc: function(stencilFunc, stencilRef, stencilMask) {
                if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                    gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                    currentStencilFunc = stencilFunc;
                    currentStencilRef = stencilRef;
                    currentStencilFuncMask = stencilMask;
                }
            },
            setOp: function(stencilFail, stencilZFail, stencilZPass) {
                if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                    gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                    currentStencilFail = stencilFail;
                    currentStencilZFail = stencilZFail;
                    currentStencilZPass = stencilZPass;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(stencil) {
                if (currentStencilClear !== stencil) {
                    gl.clearStencil(stencil);
                    currentStencilClear = stencil;
                }
            },
            reset: function() {
                locked = false;
                currentStencilMask = null;
                currentStencilFunc = null;
                currentStencilRef = null;
                currentStencilFuncMask = null;
                currentStencilFail = null;
                currentStencilZFail = null;
                currentStencilZPass = null;
                currentStencilClear = null;
            }
        };
    }
    //
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    let enabledCapabilities = {};
    let currentProgram = null;
    let currentBlendingEnabled = null;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(35661);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(7938);
    if (glVersion.indexOf('WebGL') !== -1) {
        version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf('OpenGL ES') !== -1) {
        version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {};
    const currentScissor = new Vector4();
    const currentViewport = new Vector4();
    function createTexture(type, target, count) {
        const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
        const texture = gl.createTexture();
        gl.bindTexture(type, texture);
        gl.texParameteri(type, 10241, 9728);
        gl.texParameteri(type, 10240, 9728);
        for(let i133 = 0; i133 < count; i133++)gl.texImage2D(target + i133, 0, 6408, 1, 1, 0, 6408, 5121, data);
        return texture;
    }
    const emptyTextures = {};
    emptyTextures[3553] = createTexture(3553, 3553, 1);
    emptyTextures[34067] = createTexture(34067, 34069, 6);
    // init
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(2929);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(2884);
    setBlending(NoBlending);
    //
    function enable(id) {
        if (enabledCapabilities[id] !== true) {
            gl.enable(id);
            enabledCapabilities[id] = true;
        }
    }
    function disable(id) {
        if (enabledCapabilities[id] !== false) {
            gl.disable(id);
            enabledCapabilities[id] = false;
        }
    }
    function useProgram(program) {
        if (currentProgram !== program) {
            gl.useProgram(program);
            currentProgram = program;
            return true;
        }
        return false;
    }
    const equationToGL = {
        [AddEquation]: 32774,
        [SubtractEquation]: 32778,
        [ReverseSubtractEquation]: 32779
    };
    if (isWebGL2) {
        equationToGL[MinEquation] = 32775;
        equationToGL[MaxEquation] = 32776;
    } else {
        const extension = extensions.get('EXT_blend_minmax');
        if (extension !== null) {
            equationToGL[MinEquation] = extension.MIN_EXT;
            equationToGL[MaxEquation] = extension.MAX_EXT;
        }
    }
    const factorToGL = {
        [ZeroFactor]: 0,
        [OneFactor]: 1,
        [SrcColorFactor]: 768,
        [SrcAlphaFactor]: 770,
        [SrcAlphaSaturateFactor]: 776,
        [DstColorFactor]: 774,
        [DstAlphaFactor]: 772,
        [OneMinusSrcColorFactor]: 769,
        [OneMinusSrcAlphaFactor]: 771,
        [OneMinusDstColorFactor]: 775,
        [OneMinusDstAlphaFactor]: 773
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
        if (blending === NoBlending) {
            if (currentBlendingEnabled) {
                disable(3042);
                currentBlendingEnabled = false;
            }
            return;
        }
        if (!currentBlendingEnabled) {
            enable(3042);
            currentBlendingEnabled = true;
        }
        if (blending !== CustomBlending) {
            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
                    gl.blendEquation(32774);
                    currentBlendEquation = AddEquation;
                    currentBlendEquationAlpha = AddEquation;
                }
                if (premultipliedAlpha) switch(blending){
                    case NormalBlending:
                        gl.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case AdditiveBlending:
                        gl.blendFunc(1, 1);
                        break;
                    case SubtractiveBlending:
                        gl.blendFuncSeparate(0, 0, 769, 771);
                        break;
                    case MultiplyBlending:
                        gl.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error('THREE.WebGLState: Invalid blending: ', blending);
                        break;
                }
                else switch(blending){
                    case NormalBlending:
                        gl.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case AdditiveBlending:
                        gl.blendFunc(770, 1);
                        break;
                    case SubtractiveBlending:
                        gl.blendFunc(0, 769);
                        break;
                    case MultiplyBlending:
                        gl.blendFunc(0, 768);
                        break;
                    default:
                        console.error('THREE.WebGLState: Invalid blending: ', blending);
                        break;
                }
                currentBlendSrc = null;
                currentBlendDst = null;
                currentBlendSrcAlpha = null;
                currentBlendDstAlpha = null;
                currentBlending = blending;
                currentPremultipledAlpha = premultipliedAlpha;
            }
            return;
        }
        // custom blending
        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;
        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
        }
        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
        }
        currentBlending = blending;
        currentPremultipledAlpha = null;
    }
    function setMaterial(material, frontFaceCW) {
        material.side === DoubleSide ? disable(2884) : enable(2884);
        let flipSided = material.side === BackSide;
        if (frontFaceCW) flipSided = !flipSided;
        setFlipSided(flipSided);
        material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
        depthBuffer.setFunc(material.depthFunc);
        depthBuffer.setTest(material.depthTest);
        depthBuffer.setMask(material.depthWrite);
        colorBuffer.setMask(material.colorWrite);
        const stencilWrite = material.stencilWrite;
        stencilBuffer.setTest(stencilWrite);
        if (stencilWrite) {
            stencilBuffer.setMask(material.stencilWriteMask);
            stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
            stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
        }
        setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    }
    //
    function setFlipSided(flipSided) {
        if (currentFlipSided !== flipSided) {
            if (flipSided) gl.frontFace(2304);
            else gl.frontFace(2305);
            currentFlipSided = flipSided;
        }
    }
    function setCullFace(cullFace) {
        if (cullFace !== CullFaceNone) {
            enable(2884);
            if (cullFace !== currentCullFace) {
                if (cullFace === CullFaceBack) gl.cullFace(1029);
                else if (cullFace === CullFaceFront) gl.cullFace(1028);
                else gl.cullFace(1032);
            }
        } else disable(2884);
        currentCullFace = cullFace;
    }
    function setLineWidth(width) {
        if (width !== currentLineWidth) {
            if (lineWidthAvailable) gl.lineWidth(width);
            currentLineWidth = width;
        }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
        if (polygonOffset) {
            enable(32823);
            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                gl.polygonOffset(factor, units);
                currentPolygonOffsetFactor = factor;
                currentPolygonOffsetUnits = units;
            }
        } else disable(32823);
    }
    function setScissorTest(scissorTest) {
        if (scissorTest) enable(3089);
        else disable(3089);
    }
    // texture
    function activeTexture(webglSlot) {
        if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
            gl.activeTexture(webglSlot);
            currentTextureSlot = webglSlot;
        }
    }
    function bindTexture(webglType, webglTexture) {
        if (currentTextureSlot === null) activeTexture();
        let boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture === undefined) {
            boundTexture = {
                type: undefined,
                texture: undefined
            };
            currentBoundTextures[currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;
        }
    }
    function unbindTexture() {
        const boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture !== undefined && boundTexture.type !== undefined) {
            gl.bindTexture(boundTexture.type, null);
            boundTexture.type = undefined;
            boundTexture.texture = undefined;
        }
    }
    function compressedTexImage2D() {
        try {
            gl.compressedTexImage2D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    function texImage2D() {
        try {
            gl.texImage2D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    function texImage3D() {
        try {
            gl.texImage3D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    //
    function scissor1(scissor) {
        if (currentScissor.equals(scissor) === false) {
            gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
            currentScissor.copy(scissor);
        }
    }
    function viewport1(viewport) {
        if (currentViewport.equals(viewport) === false) {
            gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
            currentViewport.copy(viewport);
        }
    }
    //
    function reset() {
        enabledCapabilities = {};
        currentTextureSlot = null;
        currentBoundTextures = {};
        currentProgram = null;
        currentBlending = null;
        currentFlipSided = null;
        currentCullFace = null;
        colorBuffer.reset();
        depthBuffer.reset();
        stencilBuffer.reset();
    }
    return {
        buffers: {
            color: colorBuffer,
            depth: depthBuffer,
            stencil: stencilBuffer
        },
        enable: enable,
        disable: disable,
        useProgram: useProgram,
        setBlending: setBlending,
        setMaterial: setMaterial,
        setFlipSided: setFlipSided,
        setCullFace: setCullFace,
        setLineWidth: setLineWidth,
        setPolygonOffset: setPolygonOffset,
        setScissorTest: setScissorTest,
        activeTexture: activeTexture,
        bindTexture: bindTexture,
        unbindTexture: unbindTexture,
        compressedTexImage2D: compressedTexImage2D,
        texImage2D: texImage2D,
        texImage3D: texImage3D,
        scissor: scissor1,
        viewport: viewport1,
        reset: reset
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const _videoTextures = new WeakMap();
    let _canvas1;
    // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
    // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
    // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
    let useOffscreenCanvas = false;
    try {
        useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {
    // Ignore any errors
    }
    function createCanvas(width, height) {
        // Use OffscreenCanvas when available. Specially needed in web workers
        return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
        let scale = 1;
        // handle case if texture exceeds max size
        if (image.width > maxSize || image.height > maxSize) scale = maxSize / Math.max(image.width, image.height);
        // only perform resize if necessary
        if (scale < 1 || needsPowerOfTwo === true) {
            // only perform resize for certain image types
            if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
                const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
                const width = floor(scale * image.width);
                const height = floor(scale * image.height);
                if (_canvas1 === undefined) _canvas1 = createCanvas(width, height);
                // cube textures can't reuse the same canvas
                const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas1;
                canvas.width = width;
                canvas.height = height;
                const context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, width, height);
                console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
                return canvas;
            } else {
                if ('data' in image) console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
                return image;
            }
        }
        return image;
    }
    function isPowerOfTwo(image) {
        return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
        if (isWebGL2) return false;
        return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
        return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target, texture, width, height) {
        _gl.generateMipmap(target);
        const textureProperties = properties.get(texture);
        // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
        textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
    }
    function getInternalFormat(internalFormatName, glFormat, glType) {
        if (isWebGL2 === false) return glFormat;
        if (internalFormatName !== null) {
            if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
            console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
        }
        let internalFormat = glFormat;
        if (glFormat === 6403) {
            if (glType === 5126) internalFormat = 33326;
            if (glType === 5131) internalFormat = 33325;
            if (glType === 5121) internalFormat = 33321;
        }
        if (glFormat === 6407) {
            if (glType === 5126) internalFormat = 34837;
            if (glType === 5131) internalFormat = 34843;
            if (glType === 5121) internalFormat = 32849;
        }
        if (glFormat === 6408) {
            if (glType === 5126) internalFormat = 34836;
            if (glType === 5131) internalFormat = 34842;
            if (glType === 5121) internalFormat = 32856;
        }
        if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) extensions.get('EXT_color_buffer_float');
        return internalFormat;
    }
    // Fallback filters for non-power-of-2 textures
    function filterFallback(f) {
        if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) return 9728;
        return 9729;
    }
    //
    function onTextureDispose(event) {
        const texture = event.target;
        texture.removeEventListener('dispose', onTextureDispose);
        deallocateTexture(texture);
        if (texture.isVideoTexture) _videoTextures.delete(texture);
        info.memory.textures--;
    }
    function onRenderTargetDispose(event) {
        const renderTarget = event.target;
        renderTarget.removeEventListener('dispose', onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
        info.memory.textures--;
    }
    //
    function deallocateTexture(texture) {
        const textureProperties = properties.get(texture);
        if (textureProperties.__webglInit === undefined) return;
        _gl.deleteTexture(textureProperties.__webglTexture);
        properties.remove(texture);
    }
    function deallocateRenderTarget(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(renderTarget.texture);
        if (!renderTarget) return;
        if (textureProperties.__webglTexture !== undefined) _gl.deleteTexture(textureProperties.__webglTexture);
        if (renderTarget.depthTexture) renderTarget.depthTexture.dispose();
        if (renderTarget.isWebGLCubeRenderTarget) for(let i134 = 0; i134 < 6; i134++){
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i134]);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i134]);
        }
        else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
            if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
            if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
        }
        properties.remove(renderTarget.texture);
        properties.remove(renderTarget);
    }
    //
    let textureUnits = 0;
    function resetTextureUnits() {
        textureUnits = 0;
    }
    function allocateTextureUnit() {
        const textureUnit = textureUnits;
        if (textureUnit >= maxTextures) console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
        textureUnits += 1;
        return textureUnit;
    }
    //
    function setTexture2D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.isVideoTexture) updateVideoTexture(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            const image = texture.image;
            if (image === undefined) console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
            else if (image.complete === false) console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
            else {
                uploadTexture(textureProperties, texture, slot);
                return;
            }
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(3553, textureProperties.__webglTexture);
    }
    function setTexture2DArray(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(35866, textureProperties.__webglTexture);
    }
    function setTexture3D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(32879, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
        if (texture.image.length !== 6) return;
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            initTexture(textureProperties, texture);
            state.activeTexture(33984 + slot);
            state.bindTexture(34067, textureProperties.__webglTexture);
            _gl.pixelStorei(37440, texture.flipY);
            const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
            const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
            const cubeImage = [];
            for(let i135 = 0; i135 < 6; i135++)if (!isCompressed && !isDataTexture) cubeImage[i135] = resizeImage(texture.image[i135], false, true, maxCubemapSize);
            else cubeImage[i135] = isDataTexture ? texture.image[i135].image : texture.image[i135];
            const image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
            setTextureParameters(34067, texture, supportsMips);
            let mipmaps;
            if (isCompressed) {
                for(let i136 = 0; i136 < 6; i136++){
                    mipmaps = cubeImage[i136].mipmaps;
                    for(let j = 0; j < mipmaps.length; j++){
                        const mipmap = mipmaps[j];
                        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                            if (glFormat !== null) state.compressedTexImage2D(34069 + i136, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                            else console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                        } else state.texImage2D(34069 + i136, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                }
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
                mipmaps = texture.mipmaps;
                for(let i137 = 0; i137 < 6; i137++)if (isDataTexture) {
                    state.texImage2D(34069 + i137, 0, glInternalFormat, cubeImage[i137].width, cubeImage[i137].height, 0, glFormat, glType, cubeImage[i137].data);
                    for(let j = 0; j < mipmaps.length; j++){
                        const mipmap = mipmaps[j];
                        const mipmapImage = mipmap.image[i137].image;
                        state.texImage2D(34069 + i137, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                    }
                } else {
                    state.texImage2D(34069 + i137, 0, glInternalFormat, glFormat, glType, cubeImage[i137]);
                    for(let j = 0; j < mipmaps.length; j++){
                        const mipmap = mipmaps[j];
                        state.texImage2D(34069 + i137, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i137]);
                    }
                }
                textureProperties.__maxMipLevel = mipmaps.length;
            }
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) // We assume images for cube map have the same size.
            generateMipmap(34067, texture, image.width, image.height);
            textureProperties.__version = texture.version;
            if (texture.onUpdate) texture.onUpdate(texture);
        } else {
            state.activeTexture(33984 + slot);
            state.bindTexture(34067, textureProperties.__webglTexture);
        }
    }
    function setTextureCubeDynamic(texture, slot) {
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, properties.get(texture).__webglTexture);
    }
    const wrappingToGL = {
        [RepeatWrapping]: 10497,
        [ClampToEdgeWrapping]: 33071,
        [MirroredRepeatWrapping]: 33648
    };
    const filterToGL = {
        [NearestFilter]: 9728,
        [NearestMipmapNearestFilter]: 9984,
        [NearestMipmapLinearFilter]: 9986,
        [LinearFilter]: 9729,
        [LinearMipmapNearestFilter]: 9985,
        [LinearMipmapLinearFilter]: 9987
    };
    function setTextureParameters(textureType, texture, supportsMips) {
        if (supportsMips) {
            _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
            _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
            if (textureType === 32879 || textureType === 35866) _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
            _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
            _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
        } else {
            _gl.texParameteri(textureType, 10242, 33071);
            _gl.texParameteri(textureType, 10243, 33071);
            if (textureType === 32879 || textureType === 35866) _gl.texParameteri(textureType, 32882, 33071);
            if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
            _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
            _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
            if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
        }
        const extension = extensions.get('EXT_texture_filter_anisotropic');
        if (extension) {
            if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
            if (texture.type === HalfFloatType && (isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;
            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                properties.get(texture).__currentAnisotropy = texture.anisotropy;
            }
        }
    }
    function initTexture(textureProperties, texture) {
        if (textureProperties.__webglInit === undefined) {
            textureProperties.__webglInit = true;
            texture.addEventListener('dispose', onTextureDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
        }
    }
    function uploadTexture(textureProperties, texture, slot) {
        let textureType = 3553;
        if (texture.isDataTexture2DArray) textureType = 35866;
        if (texture.isDataTexture3D) textureType = 32879;
        initTexture(textureProperties, texture);
        state.activeTexture(33984 + slot);
        state.bindTexture(textureType, textureProperties.__webglTexture);
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
        const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
        const supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
        let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        setTextureParameters(textureType, texture, supportsMips);
        let mipmap;
        const mipmaps = texture.mipmaps;
        if (texture.isDepthTexture) {
            // populate depth texture with dummy data
            glInternalFormat = 6402;
            if (isWebGL2) {
                if (texture.type === FloatType) glInternalFormat = 36012;
                else if (texture.type === UnsignedIntType) glInternalFormat = 33190;
                else if (texture.type === UnsignedInt248Type) glInternalFormat = 35056;
                else glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D
            } else if (texture.type === FloatType) console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
            // validation checks for WebGL 1
            if (texture.format === DepthFormat && glInternalFormat === 6402) // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
            // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
            // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
            {
                if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                    console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
                    texture.type = UnsignedShortType;
                    glType = utils.convert(texture.type);
                }
            }
            if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
                // Depth stencil textures need the DEPTH_STENCIL internal format
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                glInternalFormat = 34041;
                // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                if (texture.type !== UnsignedInt248Type) {
                    console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
                    texture.type = UnsignedInt248Type;
                    glType = utils.convert(texture.type);
                }
            }
            //
            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        } else if (texture.isDataTexture) {
            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels
            if (mipmaps.length > 0 && supportsMips) {
                for(let i138 = 0, il = mipmaps.length; i138 < il; i138++){
                    mipmap = mipmaps[i138];
                    state.texImage2D(3553, i138, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
                texture.generateMipmaps = false;
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
                state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
                textureProperties.__maxMipLevel = 0;
            }
        } else if (texture.isCompressedTexture) {
            for(let i139 = 0, il = mipmaps.length; i139 < il; i139++){
                mipmap = mipmaps[i139];
                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                    if (glFormat !== null) state.compressedTexImage2D(3553, i139, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    else console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                } else state.texImage2D(3553, i139, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else if (texture.isDataTexture2DArray) {
            state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
        } else if (texture.isDataTexture3D) {
            state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
        } else // regular Texture (image, video, canvas)
        // use manually created mipmaps if available
        // if there are no manual mipmaps
        // set 0 level mipmap and then use GL to generate other mipmap levels
        if (mipmaps.length > 0 && supportsMips) {
            for(let i140 = 0, il = mipmaps.length; i140 < il; i140++){
                mipmap = mipmaps[i140];
                state.texImage2D(3553, i140, glInternalFormat, glFormat, glType, mipmap);
            }
            texture.generateMipmaps = false;
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
            textureProperties.__maxMipLevel = 0;
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) generateMipmap(textureType, texture, image.width, image.height);
        textureProperties.__version = texture.version;
        if (texture.onUpdate) texture.onUpdate(texture);
    }
    // Render targets
    // Setup storage for target texture and bind it to correct framebuffer
    function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
        const glFormat = utils.convert(renderTarget.texture.format);
        const glType = utils.convert(renderTarget.texture.type);
        const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        _gl.bindFramebuffer(36160, framebuffer);
        _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
        _gl.bindFramebuffer(36160, null);
    }
    // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
        _gl.bindRenderbuffer(36161, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            let glInternalFormat = 33189;
            if (isMultisample) {
                const depthTexture = renderTarget.depthTexture;
                if (depthTexture && depthTexture.isDepthTexture) {
                    if (depthTexture.type === FloatType) glInternalFormat = 36012;
                    else if (depthTexture.type === UnsignedIntType) glInternalFormat = 33190;
                }
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            if (isMultisample) {
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
        } else {
            const glFormat = utils.convert(renderTarget.texture.format);
            const glType = utils.convert(renderTarget.texture.type);
            const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
            if (isMultisample) {
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
        _gl.bindRenderbuffer(36161, null);
    }
    // Setup resources for a Depth Texture for a FBO (needs an extension)
    function setupDepthTexture(framebuffer, renderTarget) {
        const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
        if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
        _gl.bindFramebuffer(36160, framebuffer);
        if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
        // upload an empty depth texture with framebuffer size
        if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
            renderTarget.depthTexture.image.width = renderTarget.width;
            renderTarget.depthTexture.image.height = renderTarget.height;
            renderTarget.depthTexture.needsUpdate = true;
        }
        setTexture2D(renderTarget.depthTexture, 0);
        const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
        if (renderTarget.depthTexture.format === DepthFormat) _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
        else if (renderTarget.depthTexture.format === DepthStencilFormat) _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
        else throw new Error('Unknown depthTexture format');
    }
    // Setup GL resources for a non-texture depth buffer
    function setupDepthRenderbuffer(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        if (renderTarget.depthTexture) {
            if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
        } else if (isCube) {
            renderTargetProperties.__webglDepthbuffer = [];
            for(let i141 = 0; i141 < 6; i141++){
                _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i141]);
                renderTargetProperties.__webglDepthbuffer[i141] = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i141], renderTarget, false);
            }
        } else {
            _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        }
        _gl.bindFramebuffer(36160, null);
    }
    // Set up GL resources for the render target
    function setupRenderTarget(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(renderTarget.texture);
        renderTarget.addEventListener('dispose', onRenderTargetDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        info.memory.textures++;
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
        const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
        // Handles WebGL2 RGBFormat fallback - #18858
        if (isWebGL2 && renderTarget.texture.format === RGBFormat && (renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType)) {
            renderTarget.texture.format = RGBAFormat;
            console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
        }
        // Setup framebuffer
        if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            for(let i142 = 0; i142 < 6; i142++)renderTargetProperties.__webglFramebuffer[i142] = _gl.createFramebuffer();
        } else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (isMultisample) {
                if (isWebGL2) {
                    renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                    renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
                    _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
                    const glFormat = utils.convert(renderTarget.texture.format);
                    const glType = utils.convert(renderTarget.texture.type);
                    const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
                    const samples = getRenderTargetSamples(renderTarget);
                    _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                    _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
                    _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
                    _gl.bindRenderbuffer(36161, null);
                    if (renderTarget.depthBuffer) {
                        renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                        setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
                    }
                    _gl.bindFramebuffer(36160, null);
                } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
            }
        }
        // Setup color buffer
        if (isCube) {
            state.bindTexture(34067, textureProperties.__webglTexture);
            setTextureParameters(34067, renderTarget.texture, supportsMips);
            for(let i143 = 0; i143 < 6; i143++)setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i143], renderTarget, 36064, 34069 + i143);
            if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
            state.bindTexture(34067, null);
        } else {
            state.bindTexture(3553, textureProperties.__webglTexture);
            setTextureParameters(3553, renderTarget.texture, supportsMips);
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);
            if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
            state.bindTexture(3553, null);
        }
        // Setup depth and stencil buffers
        if (renderTarget.depthBuffer) setupDepthRenderbuffer(renderTarget);
    }
    function updateRenderTargetMipmap(renderTarget) {
        const texture = renderTarget.texture;
        const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
            const webglTexture = properties.get(texture).__webglTexture;
            state.bindTexture(target, webglTexture);
            generateMipmap(target, texture, renderTarget.width, renderTarget.height);
            state.bindTexture(target, null);
        }
    }
    function updateMultisampleRenderTarget(renderTarget) {
        if (renderTarget.isWebGLMultisampleRenderTarget) {
            if (isWebGL2) {
                const renderTargetProperties = properties.get(renderTarget);
                _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
                _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
                const width = renderTarget.width;
                const height = renderTarget.height;
                let mask = 16384;
                if (renderTarget.depthBuffer) mask |= 256;
                if (renderTarget.stencilBuffer) mask |= 1024;
                _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
                _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer); // see #18905
            } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
        }
    }
    function getRenderTargetSamples(renderTarget) {
        return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
    }
    function updateVideoTexture(texture) {
        const frame = info.render.frame;
        // Check the last frame we updated the VideoTexture
        if (_videoTextures.get(texture) !== frame) {
            _videoTextures.set(texture, frame);
            texture.update();
        }
    }
    // backwards compatibility
    let warnedTexture2D = false;
    let warnedTextureCube = false;
    function safeSetTexture2D(texture, slot) {
        if (texture && texture.isWebGLRenderTarget) {
            if (warnedTexture2D === false) {
                console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
                warnedTexture2D = true;
            }
            texture = texture.texture;
        }
        setTexture2D(texture, slot);
    }
    function safeSetTextureCube(texture, slot) {
        if (texture && texture.isWebGLCubeRenderTarget) {
            if (warnedTextureCube === false) {
                console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                warnedTextureCube = true;
            }
            texture = texture.texture;
        }
        // currently relying on the fact that WebGLCubeRenderTarget.texture is a Texture and NOT a CubeTexture
        // TODO: unify these code paths
        if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) // CompressedTexture can have Array in image :/
        // this function alone should take care of cube textures
        setTextureCube(texture, slot);
        else // assumed: texture property of THREE.WebGLCubeRenderTarget
        setTextureCubeDynamic(texture, slot);
    }
    //
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.setTextureCubeDynamic = setTextureCubeDynamic;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.safeSetTexture2D = safeSetTexture2D;
    this.safeSetTextureCube = safeSetTextureCube;
}
/**
 * @author thespite / http://www.twitter.com/thespite
 */ function WebGLUtils(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p) {
        let extension;
        if (p === UnsignedByteType) return 5121;
        if (p === UnsignedShort4444Type) return 32819;
        if (p === UnsignedShort5551Type) return 32820;
        if (p === UnsignedShort565Type) return 33635;
        if (p === ByteType) return 5120;
        if (p === ShortType) return 5122;
        if (p === UnsignedShortType) return 5123;
        if (p === IntType) return 5124;
        if (p === UnsignedIntType) return 5125;
        if (p === FloatType) return 5126;
        if (p === HalfFloatType) {
            if (isWebGL2) return 5131;
            extension = extensions.get('OES_texture_half_float');
            if (extension !== null) return extension.HALF_FLOAT_OES;
            else return null;
        }
        if (p === AlphaFormat) return 6406;
        if (p === RGBFormat) return 6407;
        if (p === RGBAFormat) return 6408;
        if (p === LuminanceFormat) return 6409;
        if (p === LuminanceAlphaFormat) return 6410;
        if (p === DepthFormat) return 6402;
        if (p === DepthStencilFormat) return 34041;
        if (p === RedFormat) return 6403;
        // WebGL2 formats.
        if (p === RedIntegerFormat) return 36244;
        if (p === RGFormat) return 33319;
        if (p === RGIntegerFormat) return 33320;
        if (p === RGBIntegerFormat) return 36248;
        if (p === RGBAIntegerFormat) return 36249;
        if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
            extension = extensions.get('WEBGL_compressed_texture_s3tc');
            if (extension !== null) {
                if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
        }
        if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
            extension = extensions.get('WEBGL_compressed_texture_pvrtc');
            if (extension !== null) {
                if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
        }
        if (p === RGB_ETC1_Format) {
            extension = extensions.get('WEBGL_compressed_texture_etc1');
            if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
            else return null;
        }
        if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
            extension = extensions.get('WEBGL_compressed_texture_etc');
            if (extension !== null) {
                if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
                if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
            }
        }
        if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
            extension = extensions.get('WEBGL_compressed_texture_astc');
            if (extension !== null) // TODO Complete?
            return p;
            else return null;
        }
        if (p === RGBA_BPTC_Format) {
            extension = extensions.get('EXT_texture_compression_bptc');
            if (extension !== null) // TODO Complete?
            return p;
            else return null;
        }
        if (p === UnsignedInt248Type) {
            if (isWebGL2) return 34042;
            extension = extensions.get('WEBGL_depth_texture');
            if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
            else return null;
        }
    }
    return {
        convert: convert
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function ArrayCamera(array) {
    PerspectiveCamera.call(this);
    this.cameras = array || [];
}
ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
    constructor: ArrayCamera,
    isArrayCamera: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function Group() {
    Object3D.call(this);
    this.type = 'Group';
}
Group.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Group,
    isGroup: true
});
/**
 * @author Mugen87 / https://github.com/Mugen87
 */ function WebXRController() {
    this._targetRay = null;
    this._grip = null;
}
Object.assign(WebXRController.prototype, {
    constructor: WebXRController,
    getTargetRaySpace: function() {
        if (this._targetRay === null) {
            this._targetRay = new Group();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
        }
        return this._targetRay;
    },
    getGripSpace: function() {
        if (this._grip === null) {
            this._grip = new Group();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
        }
        return this._grip;
    },
    dispatchEvent: function(event) {
        if (this._targetRay !== null) this._targetRay.dispatchEvent(event);
        if (this._grip !== null) this._grip.dispatchEvent(event);
        return this;
    },
    disconnect: function(inputSource) {
        this.dispatchEvent({
            type: 'disconnected',
            data: inputSource
        });
        if (this._targetRay !== null) this._targetRay.visible = false;
        if (this._grip !== null) this._grip.visible = false;
        return this;
    },
    update: function(inputSource, frame, referenceSpace) {
        let inputPose = null;
        let gripPose = null;
        const targetRay = this._targetRay;
        const grip = this._grip;
        if (inputSource) {
            if (targetRay !== null) {
                inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                if (inputPose !== null) {
                    targetRay.matrix.fromArray(inputPose.transform.matrix);
                    targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                }
            }
            if (grip !== null && inputSource.gripSpace) {
                gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                if (gripPose !== null) {
                    grip.matrix.fromArray(gripPose.transform.matrix);
                    grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                }
            }
        }
        if (targetRay !== null) targetRay.visible = inputPose !== null;
        if (grip !== null) grip.visible = gripPose !== null;
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebXRManager(renderer, gl) {
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = 'local-floor';
    let pose = null;
    const controllers = [];
    const inputSourcesMap = new Map();
    //
    const cameraL1 = new PerspectiveCamera();
    cameraL1.layers.enable(1);
    cameraL1.viewport = new Vector4();
    const cameraR1 = new PerspectiveCamera();
    cameraR1.layers.enable(2);
    cameraR1.viewport = new Vector4();
    const cameras1 = [
        cameraL1,
        cameraR1
    ];
    const cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    //
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
        let controller = controllers[index];
        if (controller === undefined) {
            controller = new WebXRController();
            controllers[index] = controller;
        }
        return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
        let controller = controllers[index];
        if (controller === undefined) {
            controller = new WebXRController();
            controllers[index] = controller;
        }
        return controller.getGripSpace();
    };
    //
    function onSessionEvent(event) {
        const controller = inputSourcesMap.get(event.inputSource);
        if (controller) controller.dispatchEvent({
            type: event.type
        });
    }
    function onSessionEnd() {
        inputSourcesMap.forEach(function(controller, inputSource) {
            controller.disconnect(inputSource);
        });
        inputSourcesMap.clear();
        //
        renderer.setFramebuffer(null);
        renderer.setRenderTarget(renderer.getRenderTarget()); // Hack #15830
        animation.stop();
        scope.isPresenting = false;
        scope.dispatchEvent({
            type: 'sessionend'
        });
    }
    function onRequestReferenceSpace(value) {
        referenceSpace = value;
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({
            type: 'sessionstart'
        });
    }
    this.setFramebufferScaleFactor = function(value) {
        framebufferScaleFactor = value;
        if (scope.isPresenting === true) console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
    };
    this.setReferenceSpaceType = function(value) {
        referenceSpaceType = value;
        if (scope.isPresenting === true) console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
    };
    this.getReferenceSpace = function() {
        return referenceSpace;
    };
    this.getSession = function() {
        return session;
    };
    this.setSession = function(value) {
        session = value;
        if (session !== null) {
            session.addEventListener('select', onSessionEvent);
            session.addEventListener('selectstart', onSessionEvent);
            session.addEventListener('selectend', onSessionEvent);
            session.addEventListener('squeeze', onSessionEvent);
            session.addEventListener('squeezestart', onSessionEvent);
            session.addEventListener('squeezeend', onSessionEvent);
            session.addEventListener('end', onSessionEnd);
            const attributes = gl.getContextAttributes();
            if (attributes.xrCompatible !== true) gl.makeXRCompatible();
            const layerInit = {
                antialias: attributes.antialias,
                alpha: attributes.alpha,
                depth: attributes.depth,
                stencil: attributes.stencil,
                framebufferScaleFactor: framebufferScaleFactor
            };
            // eslint-disable-next-line no-undef
            const baseLayer = new XRWebGLLayer(session, gl, layerInit);
            session.updateRenderState({
                baseLayer: baseLayer
            });
            session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);
            //
            session.addEventListener('inputsourceschange', updateInputSources);
        }
    };
    function updateInputSources(event) {
        const inputSources = session.inputSources;
        // Assign inputSources to available controllers
        for(let i146 = 0; i146 < controllers.length; i146++)inputSourcesMap.set(inputSources[i146], controllers[i146]);
        // Notify disconnected
        for(let i144 = 0; i144 < event.removed.length; i144++){
            const inputSource = event.removed[i144];
            const controller = inputSourcesMap.get(inputSource);
            if (controller) {
                controller.dispatchEvent({
                    type: 'disconnected',
                    data: inputSource
                });
                inputSourcesMap.delete(inputSource);
            }
        }
        // Notify connected
        for(let i145 = 0; i145 < event.added.length; i145++){
            const inputSource = event.added[i145];
            const controller = inputSourcesMap.get(inputSource);
            if (controller) controller.dispatchEvent({
                type: 'connected',
                data: inputSource
            });
        }
    }
    //
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    /**
	 * @author jsantell / https://www.jsantell.com/
	 *
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */ function setProjectionFromUnion(camera, cameraL, cameraR) {
        cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
        cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
        const ipd = cameraLPos.distanceTo(cameraRPos);
        const projL = cameraL.projectionMatrix.elements;
        const projR = cameraR.projectionMatrix.elements;
        // VR systems will have identical far and near planes, and
        // most likely identical top and bottom frustum extents.
        // Use the left camera for these values.
        const near = projL[14] / (projL[10] - 1);
        const far = projL[14] / (projL[10] + 1);
        const topFov = (projL[9] + 1) / projL[5];
        const bottomFov = (projL[9] - 1) / projL[5];
        const leftFov = (projL[8] - 1) / projL[0];
        const rightFov = (projR[8] + 1) / projR[0];
        const left = near * leftFov;
        const right = near * rightFov;
        // Calculate the new camera's position offset from the
        // left camera. xOffset should be roughly half `ipd`.
        const zOffset = ipd / (-leftFov + rightFov);
        const xOffset = zOffset * -leftFov;
        // TODO: Better way to apply this offset?
        cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
        camera.translateX(xOffset);
        camera.translateZ(zOffset);
        camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        // Find the union of the frustum values of the cameras and scale
        // the values so that the near plane's position does not change in world space,
        // although must now be relative to the new union camera.
        const near2 = near + zOffset;
        const far2 = far + zOffset;
        const left2 = left - xOffset;
        const right2 = right + (ipd - xOffset);
        const top2 = topFov * far / far2 * near2;
        const bottom2 = bottomFov * far / far2 * near2;
        camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }
    function updateCamera(camera, parent) {
        if (parent === null) camera.matrixWorld.copy(camera.matrix);
        else camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    }
    this.getCamera = function(camera) {
        cameraVR.near = cameraR1.near = cameraL1.near = camera.near;
        cameraVR.far = cameraR1.far = cameraL1.far = camera.far;
        if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
            // Note that the new renderState won't apply until the next frame. See #18320
            session.updateRenderState({
                depthNear: cameraVR.near,
                depthFar: cameraVR.far
            });
            _currentDepthNear = cameraVR.near;
            _currentDepthFar = cameraVR.far;
        }
        const parent = camera.parent;
        const cameras = cameraVR.cameras;
        updateCamera(cameraVR, parent);
        for(let i148 = 0; i148 < cameras.length; i148++)updateCamera(cameras[i148], parent);
        // update camera and its children
        camera.matrixWorld.copy(cameraVR.matrixWorld);
        const children = camera.children;
        for(let i147 = 0, l = children.length; i147 < l; i147++)children[i147].updateMatrixWorld(true);
        // update projection matrix for proper view frustum culling
        if (cameras.length === 2) setProjectionFromUnion(cameraVR, cameraL1, cameraR1);
        else // assume single camera setup (AR)
        cameraVR.projectionMatrix.copy(cameraL1.projectionMatrix);
        return cameraVR;
    };
    // Animation Loop
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
        pose = frame.getViewerPose(referenceSpace);
        if (pose !== null) {
            const views = pose.views;
            const baseLayer = session.renderState.baseLayer;
            renderer.setFramebuffer(baseLayer.framebuffer);
            let cameraVRNeedsUpdate = false;
            // check if it's necessary to rebuild cameraVR's camera list
            if (views.length !== cameraVR.cameras.length) {
                cameraVR.cameras.length = 0;
                cameraVRNeedsUpdate = true;
            }
            for(let i149 = 0; i149 < views.length; i149++){
                const view = views[i149];
                const viewport = baseLayer.getViewport(view);
                const camera = cameras1[i149];
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i149 === 0) cameraVR.matrix.copy(camera.matrix);
                if (cameraVRNeedsUpdate === true) cameraVR.cameras.push(camera);
            }
        }
        //
        const inputSources = session.inputSources;
        for(let i150 = 0; i150 < controllers.length; i150++){
            const controller = controllers[i150];
            const inputSource = inputSources[i150];
            controller.update(inputSource, frame, referenceSpace);
        }
        if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
    };
    this.dispose = function() {};
}
Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
/**
 * @author mrdoob / http://mrdoob.com/
 */ function WebGLMaterials(properties) {
    function refreshFogUniforms(uniforms, fog) {
        uniforms.fogColor.value.copy(fog.color);
        if (fog.isFog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
        } else if (fog.isFogExp2) uniforms.fogDensity.value = fog.density;
    }
    function refreshMaterialUniforms(uniforms, material, environment, pixelRatio, height) {
        if (material.isMeshBasicMaterial) refreshUniformsCommon(uniforms, material);
        else if (material.isMeshLambertMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsLambert(uniforms, material);
        } else if (material.isMeshToonMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsToon(uniforms, material);
        } else if (material.isMeshPhongMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsPhong(uniforms, material);
        } else if (material.isMeshStandardMaterial) {
            refreshUniformsCommon(uniforms, material, environment);
            if (material.isMeshPhysicalMaterial) refreshUniformsPhysical(uniforms, material, environment);
            else refreshUniformsStandard(uniforms, material, environment);
        } else if (material.isMeshMatcapMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsMatcap(uniforms, material);
        } else if (material.isMeshDepthMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDepth(uniforms, material);
        } else if (material.isMeshDistanceMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDistance(uniforms, material);
        } else if (material.isMeshNormalMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsNormal(uniforms, material);
        } else if (material.isLineBasicMaterial) {
            refreshUniformsLine(uniforms, material);
            if (material.isLineDashedMaterial) refreshUniformsDash(uniforms, material);
        } else if (material.isPointsMaterial) refreshUniformsPoints(uniforms, material, pixelRatio, height);
        else if (material.isSpriteMaterial) refreshUniformsSprites(uniforms, material);
        else if (material.isShadowMaterial) {
            uniforms.color.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
        } else if (material.isShaderMaterial) material.uniformsNeedUpdate = false; // #15581
    }
    function refreshUniformsCommon(uniforms, material, environment) {
        uniforms.opacity.value = material.opacity;
        if (material.color) uniforms.diffuse.value.copy(material.color);
        if (material.emissive) uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        if (material.specularMap) uniforms.specularMap.value = material.specularMap;
        const envMap = material.envMap || environment;
        if (envMap) {
            uniforms.envMap.value = envMap;
            uniforms.flipEnvMap.value = envMap.isCubeTexture ? -1 : 1;
            uniforms.reflectivity.value = material.reflectivity;
            uniforms.refractionRatio.value = material.refractionRatio;
            uniforms.maxMipLevel.value = properties.get(envMap).__maxMipLevel;
        }
        if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.aoMap) {
            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;
        }
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. normal map
        // 4. bump map
        // 5. alpha map
        // 6. emissive map
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.specularMap) uvScaleMap = material.specularMap;
        else if (material.displacementMap) uvScaleMap = material.displacementMap;
        else if (material.normalMap) uvScaleMap = material.normalMap;
        else if (material.bumpMap) uvScaleMap = material.bumpMap;
        else if (material.roughnessMap) uvScaleMap = material.roughnessMap;
        else if (material.metalnessMap) uvScaleMap = material.metalnessMap;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        else if (material.emissiveMap) uvScaleMap = material.emissiveMap;
        if (uvScaleMap !== undefined) {
            // backwards compatibility
            if (uvScaleMap.isWebGLRenderTarget) uvScaleMap = uvScaleMap.texture;
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
        // uv repeat and offset setting priorities for uv2
        // 1. ao map
        // 2. light map
        let uv2ScaleMap;
        if (material.aoMap) uv2ScaleMap = material.aoMap;
        else if (material.lightMap) uv2ScaleMap = material.lightMap;
        if (uv2ScaleMap !== undefined) {
            // backwards compatibility
            if (uv2ScaleMap.isWebGLRenderTarget) uv2ScaleMap = uv2ScaleMap.texture;
            if (uv2ScaleMap.matrixAutoUpdate === true) uv2ScaleMap.updateMatrix();
            uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
        }
    }
    function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size * pixelRatio;
        uniforms.scale.value = height * 0.5;
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. alpha map
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsSprites(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.rotation.value = material.rotation;
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. alpha map
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsLambert(uniforms, material) {
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
    }
    function refreshUniformsPhong(uniforms, material) {
        uniforms.specular.value.copy(material.specular);
        uniforms.shininess.value = Math.max(material.shininess, 0.0001); // to prevent pow( 0.0, 0.0 )
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsToon(uniforms, material) {
        if (material.gradientMap) uniforms.gradientMap.value = material.gradientMap;
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsStandard(uniforms, material, environment) {
        uniforms.roughness.value = material.roughness;
        uniforms.metalness.value = material.metalness;
        if (material.roughnessMap) uniforms.roughnessMap.value = material.roughnessMap;
        if (material.metalnessMap) uniforms.metalnessMap.value = material.metalnessMap;
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        if (material.envMap || environment) //uniforms.envMap.value = material.envMap; // part of uniforms common
        uniforms.envMapIntensity.value = material.envMapIntensity;
    }
    function refreshUniformsPhysical(uniforms, material, environment) {
        refreshUniformsStandard(uniforms, material, environment);
        uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common
        uniforms.clearcoat.value = material.clearcoat;
        uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
        if (material.sheen) uniforms.sheen.value.copy(material.sheen);
        if (material.clearcoatMap) uniforms.clearcoatMap.value = material.clearcoatMap;
        if (material.clearcoatRoughnessMap) uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        if (material.clearcoatNormalMap) {
            uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
            uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
            if (material.side === BackSide) uniforms.clearcoatNormalScale.value.negate();
        }
        uniforms.transparency.value = material.transparency;
    }
    function refreshUniformsMatcap(uniforms, material) {
        if (material.matcap) uniforms.matcap.value = material.matcap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsDepth(uniforms, material) {
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsDistance(uniforms, material) {
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        uniforms.referencePosition.value.copy(material.referencePosition);
        uniforms.nearDistance.value = material.nearDistance;
        uniforms.farDistance.value = material.farDistance;
    }
    function refreshUniformsNormal(uniforms, material) {
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    return {
        refreshFogUniforms: refreshFogUniforms,
        refreshMaterialUniforms: refreshMaterialUniforms
    };
}
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */ function WebGLRenderer(parameters1) {
    parameters1 = parameters1 || {};
    const _canvas2 = parameters1.canvas !== undefined ? parameters1.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'), _context1 = parameters1.context !== undefined ? parameters1.context : null, _alpha = parameters1.alpha !== undefined ? parameters1.alpha : false, _depth = parameters1.depth !== undefined ? parameters1.depth : true, _stencil = parameters1.stencil !== undefined ? parameters1.stencil : true, _antialias = parameters1.antialias !== undefined ? parameters1.antialias : false, _premultipliedAlpha = parameters1.premultipliedAlpha !== undefined ? parameters1.premultipliedAlpha : true, _preserveDrawingBuffer = parameters1.preserveDrawingBuffer !== undefined ? parameters1.preserveDrawingBuffer : false, _powerPreference = parameters1.powerPreference !== undefined ? parameters1.powerPreference : 'default', _failIfMajorPerformanceCaveat = parameters1.failIfMajorPerformanceCaveat !== undefined ? parameters1.failIfMajorPerformanceCaveat : false;
    let currentRenderList = null;
    let currentRenderState = null;
    // public properties
    this.domElement = _canvas2;
    // Debug configuration container
    this.debug = {
        /**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */ checkShaderErrors: true
    };
    // clearing
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    // scene graph
    this.sortObjects = true;
    // user-defined clipping
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    // physically based shading
    this.gammaFactor = 2; // for backwards compatibility
    this.outputEncoding = LinearEncoding;
    // physical lights
    this.physicallyCorrectLights = false;
    // tone mapping
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    // morphs
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    // internal properties
    const _this = this;
    let _isContextLost = false;
    // internal state cache
    let _framebuffer = null;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentFramebuffer = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    let _currentArrayCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    //
    let _width = _canvas2.width;
    let _height = _canvas2.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    // frustum
    const _frustum = new Frustum();
    // clipping
    const _clipping = new WebGLClipping();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    // camera matrices cache
    const _projScreenMatrix = new Matrix4();
    const _vector3 = new Vector3();
    const _emptyScene = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: true
    };
    function getTargetPixelRatio() {
        return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    // initialize
    let _gl = _context1;
    function getContext(contextNames, contextAttributes) {
        for(let i151 = 0; i151 < contextNames.length; i151++){
            const contextName = contextNames[i151];
            const context = _canvas2.getContext(contextName, contextAttributes);
            if (context !== null) return context;
        }
        return null;
    }
    try {
        const contextAttributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer,
            powerPreference: _powerPreference,
            failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
        };
        // event listeners must be registered before WebGL context is created, see #12753
        _canvas2.addEventListener('webglcontextlost', onContextLost, false);
        _canvas2.addEventListener('webglcontextrestored', onContextRestore, false);
        if (_gl === null) {
            const contextNames = [
                'webgl2',
                'webgl',
                'experimental-webgl'
            ];
            if (_this.isWebGL1Renderer === true) contextNames.shift();
            _gl = getContext(contextNames, contextAttributes);
            if (_gl === null) {
                if (getContext(contextNames)) throw new Error('Error creating WebGL context with your selected attributes.');
                else throw new Error('Error creating WebGL context.');
            }
        }
        // Some experimental-webgl implementations do not have getShaderPrecisionFormat
        if (_gl.getShaderPrecisionFormat === undefined) _gl.getShaderPrecisionFormat = function() {
            return {
                'rangeMin': 1,
                'rangeMax': 1,
                'precision': 1
            };
        };
    } catch (error) {
        console.error('THREE.WebGLRenderer: ' + error.message);
        throw error;
    }
    let extensions, capabilities, state, info;
    let properties, textures, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates;
    function initGLContext() {
        extensions = new WebGLExtensions(_gl);
        capabilities = new WebGLCapabilities(_gl, extensions, parameters1);
        if (capabilities.isWebGL2 === false) {
            extensions.get('WEBGL_depth_texture');
            extensions.get('OES_texture_float');
            extensions.get('OES_texture_half_float');
            extensions.get('OES_texture_half_float_linear');
            extensions.get('OES_standard_derivatives');
            extensions.get('OES_element_index_uint');
            extensions.get('OES_vertex_array_object');
            extensions.get('ANGLE_instanced_arrays');
        }
        extensions.get('OES_texture_float_linear');
        utils = new WebGLUtils(_gl, extensions, capabilities);
        state = new WebGLState(_gl, extensions, capabilities);
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
        info = new WebGLInfo(_gl);
        properties = new WebGLProperties();
        textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
        attributes = new WebGLAttributes(_gl, capabilities);
        bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
        geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
        objects = new WebGLObjects(_gl, geometries, attributes, info);
        morphtargets = new WebGLMorphtargets(_gl);
        programCache = new WebGLPrograms(_this, extensions, capabilities, bindingStates);
        materials = new WebGLMaterials(properties);
        renderLists = new WebGLRenderLists();
        renderStates = new WebGLRenderStates();
        background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);
        bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
        indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
        info.programs = programCache.programs;
        _this.capabilities = capabilities;
        _this.extensions = extensions;
        _this.properties = properties;
        _this.renderLists = renderLists;
        _this.state = state;
        _this.info = info;
    }
    initGLContext();
    // xr
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    // shadow map
    const shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
    this.shadowMap = shadowMap;
    // API
    this.getContext = function() {
        return _gl;
    };
    this.getContextAttributes = function() {
        return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
        const extension = extensions.get('WEBGL_lose_context');
        if (extension) extension.loseContext();
    };
    this.forceContextRestore = function() {
        const extension = extensions.get('WEBGL_lose_context');
        if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function() {
        return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
        if (value === undefined) return;
        _pixelRatio = value;
        this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
        if (target === undefined) {
            console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
            target = new Vector2();
        }
        return target.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle) {
        if (xr.isPresenting) {
            console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
            return;
        }
        _width = width;
        _height = height;
        _canvas2.width = Math.floor(width * _pixelRatio);
        _canvas2.height = Math.floor(height * _pixelRatio);
        if (updateStyle !== false) {
            _canvas2.style.width = width + 'px';
            _canvas2.style.height = height + 'px';
        }
        this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
        if (target === undefined) {
            console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
            target = new Vector2();
        }
        return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
        _width = width;
        _height = height;
        _pixelRatio = pixelRatio;
        _canvas2.width = Math.floor(width * pixelRatio);
        _canvas2.height = Math.floor(height * pixelRatio);
        this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target) {
        if (target === undefined) {
            console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
            target = new Vector4();
        }
        return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
        return target.copy(_viewport);
    };
    this.setViewport = function(x, y, width, height) {
        if (x.isVector4) _viewport.set(x.x, x.y, x.z, x.w);
        else _viewport.set(x, y, width, height);
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
        return target.copy(_scissor);
    };
    this.setScissor = function(x, y, width, height) {
        if (x.isVector4) _scissor.set(x.x, x.y, x.z, x.w);
        else _scissor.set(x, y, width, height);
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
        return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
        state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
        _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
        _transparentSort = method;
    };
    // Clearing
    this.getClearColor = function() {
        return background.getClearColor();
    };
    this.setClearColor = function() {
        background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
        return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
        background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color, depth, stencil) {
        let bits = 0;
        if (color === undefined || color) bits |= 16384;
        if (depth === undefined || depth) bits |= 256;
        if (stencil === undefined || stencil) bits |= 1024;
        _gl.clear(bits);
    };
    this.clearColor = function() {
        this.clear(true, false, false);
    };
    this.clearDepth = function() {
        this.clear(false, true, false);
    };
    this.clearStencil = function() {
        this.clear(false, false, true);
    };
    //
    this.dispose = function() {
        _canvas2.removeEventListener('webglcontextlost', onContextLost, false);
        _canvas2.removeEventListener('webglcontextrestored', onContextRestore, false);
        renderLists.dispose();
        renderStates.dispose();
        properties.dispose();
        objects.dispose();
        bindingStates.dispose();
        xr.dispose();
        animation.stop();
    };
    // Events
    function onContextLost(event) {
        event.preventDefault();
        console.log('THREE.WebGLRenderer: Context Lost.');
        _isContextLost = true;
    }
    function onContextRestore() {
        console.log('THREE.WebGLRenderer: Context Restored.');
        _isContextLost = false;
        initGLContext();
    }
    function onMaterialDispose(event) {
        const material = event.target;
        material.removeEventListener('dispose', onMaterialDispose);
        deallocateMaterial(material);
    }
    // Buffer deallocation
    function deallocateMaterial(material) {
        releaseMaterialProgramReference(material);
        properties.remove(material);
    }
    function releaseMaterialProgramReference(material) {
        const programInfo = properties.get(material).program;
        material.program = undefined;
        if (programInfo !== undefined) programCache.releaseProgram(programInfo);
    }
    // Buffer rendering
    function renderObjectImmediate(object1, program) {
        object1.render(function(object) {
            _this.renderBufferImmediate(object, program);
        });
    }
    this.renderBufferImmediate = function(object, program) {
        bindingStates.initAttributes();
        const buffers = properties.get(object);
        if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
        if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
        if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
        if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
        const programAttributes = program.getAttributes();
        if (object.hasPositions) {
            _gl.bindBuffer(34962, buffers.position);
            _gl.bufferData(34962, object.positionArray, 35048);
            bindingStates.enableAttribute(programAttributes.position);
            _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
        }
        if (object.hasNormals) {
            _gl.bindBuffer(34962, buffers.normal);
            _gl.bufferData(34962, object.normalArray, 35048);
            bindingStates.enableAttribute(programAttributes.normal);
            _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
        }
        if (object.hasUvs) {
            _gl.bindBuffer(34962, buffers.uv);
            _gl.bufferData(34962, object.uvArray, 35048);
            bindingStates.enableAttribute(programAttributes.uv);
            _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
        }
        if (object.hasColors) {
            _gl.bindBuffer(34962, buffers.color);
            _gl.bufferData(34962, object.colorArray, 35048);
            bindingStates.enableAttribute(programAttributes.color);
            _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
        }
        bindingStates.disableUnusedAttributes();
        _gl.drawArrays(4, 0, object.count);
        object.count = 0;
    };
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
        if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)
        const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
        const program = setProgram(camera, scene, material, object);
        state.setMaterial(material, frontFaceCW);
        //
        let index = geometry.index;
        const position = geometry.attributes.position;
        //
        if (index === null) {
            if (position === undefined || position.count === 0) return;
        } else if (index.count === 0) return;
        //
        let rangeFactor = 1;
        if (material.wireframe === true) {
            index = geometries.getWireframeAttribute(geometry);
            rangeFactor = 2;
        }
        if (material.morphTargets || material.morphNormals) morphtargets.update(object, geometry, material, program);
        bindingStates.setup(object, material, program, geometry, index);
        let attribute;
        let renderer = bufferRenderer;
        if (index !== null) {
            attribute = attributes.get(index);
            renderer = indexedBufferRenderer;
            renderer.setIndex(attribute);
        }
        //
        const dataCount = index !== null ? index.count : position.count;
        const rangeStart = geometry.drawRange.start * rangeFactor;
        const rangeCount = geometry.drawRange.count * rangeFactor;
        const groupStart = group !== null ? group.start * rangeFactor : 0;
        const groupCount = group !== null ? group.count * rangeFactor : Infinity;
        const drawStart = Math.max(rangeStart, groupStart);
        const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
        const drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (drawCount === 0) return;
        //
        if (object.isMesh) {
            if (material.wireframe === true) {
                state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                renderer.setMode(1);
            } else renderer.setMode(4);
        } else if (object.isLine) {
            let lineWidth = material.linewidth;
            if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material
            state.setLineWidth(lineWidth * getTargetPixelRatio());
            if (object.isLineSegments) renderer.setMode(1);
            else if (object.isLineLoop) renderer.setMode(2);
            else renderer.setMode(3);
        } else if (object.isPoints) renderer.setMode(0);
        else if (object.isSprite) renderer.setMode(4);
        if (object.isInstancedMesh) renderer.renderInstances(geometry, drawStart, drawCount, object.count);
        else if (geometry.isInstancedBufferGeometry) {
            const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
            renderer.renderInstances(geometry, drawStart, drawCount, instanceCount);
        } else renderer.render(drawStart, drawCount);
    };
    // Compile
    this.compile = function(scene, camera) {
        currentRenderState = renderStates.get(scene, camera);
        currentRenderState.init();
        scene.traverse(function(object) {
            if (object.isLight) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            }
        });
        currentRenderState.setupLights(camera);
        const compiled = new WeakMap();
        scene.traverse(function(object) {
            let material = object.material;
            if (material) {
                if (Array.isArray(material)) for(let i152 = 0; i152 < material.length; i152++){
                    let material2 = material[i152];
                    if (compiled.has(material2) === false) {
                        initMaterial(material2, scene, object);
                        compiled.set(material2);
                    }
                }
                else if (compiled.has(material) === false) {
                    initMaterial(material, scene, object);
                    compiled.set(material);
                }
            }
        });
    };
    // Animation Loop
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
        if (xr.isPresenting) return;
        if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof window !== 'undefined') animation.setContext(window);
    this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
        xr.setAnimationLoop(callback);
        callback === null ? animation.stop() : animation.start();
    };
    // Rendering
    this.render = function(scene, camera) {
        let renderTarget, forceClear;
        if (arguments[2] !== undefined) {
            console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
            renderTarget = arguments[2];
        }
        if (arguments[3] !== undefined) {
            console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
            forceClear = arguments[3];
        }
        if (camera !== undefined && camera.isCamera !== true) {
            console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
            return;
        }
        if (_isContextLost === true) return;
        // reset caching for this frame
        bindingStates.resetDefaultState();
        _currentMaterialId = -1;
        _currentCamera = null;
        // update scene graph
        if (scene.autoUpdate === true) scene.updateMatrixWorld();
        // update camera matrices and frustum
        if (camera.parent === null) camera.updateMatrixWorld();
        if (xr.enabled === true && xr.isPresenting === true) camera = xr.getCamera(camera);
        //
        if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
        currentRenderState = renderStates.get(scene, camera);
        currentRenderState.init();
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromProjectionMatrix(_projScreenMatrix);
        _localClippingEnabled = this.localClippingEnabled;
        _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
        currentRenderList = renderLists.get(scene, camera);
        currentRenderList.init();
        projectObject(scene, camera, 0, _this.sortObjects);
        currentRenderList.finish();
        if (_this.sortObjects === true) currentRenderList.sort(_opaqueSort, _transparentSort);
        //
        if (_clippingEnabled === true) _clipping.beginShadows();
        const shadowsArray = currentRenderState.state.shadowsArray;
        shadowMap.render(shadowsArray, scene, camera);
        currentRenderState.setupLights(camera);
        if (_clippingEnabled === true) _clipping.endShadows();
        //
        if (this.info.autoReset === true) this.info.reset();
        if (renderTarget !== undefined) this.setRenderTarget(renderTarget);
        //
        background.render(currentRenderList, scene, camera, forceClear);
        // render scene
        const opaqueObjects = currentRenderList.opaque;
        const transparentObjects = currentRenderList.transparent;
        if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
        if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
        //
        if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
        //
        if (_currentRenderTarget !== null) {
            // Generate mipmap if we're using any kind of mipmap filtering
            textures.updateRenderTargetMipmap(_currentRenderTarget);
            // resolve multisample renderbuffers to a single-sample texture if necessary
            textures.updateMultisampleRenderTarget(_currentRenderTarget);
        }
        // Ensure depth buffer writing is enabled so it can be cleared on next render
        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);
        state.setPolygonOffset(false);
        // _gl.finish();
        currentRenderList = null;
        currentRenderState = null;
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible) {
            if (object.isGroup) groupOrder = object.renderOrder;
            else if (object.isLOD) {
                if (object.autoUpdate === true) object.update(camera);
            } else if (object.isLight) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            } else if (object.isSprite) {
                if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                    if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    const geometry = objects.update(object);
                    const material = object.material;
                    if (material.visible) currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                }
            } else if (object.isImmediateRenderObject) {
                if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
            } else if (object.isMesh || object.isLine || object.isPoints) {
                if (object.isSkinnedMesh) // update skeleton only once in a frame
                {
                    if (object.skeleton.frame !== info.render.frame) {
                        object.skeleton.update();
                        object.skeleton.frame = info.render.frame;
                    }
                }
                if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                    if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    const geometry = objects.update(object);
                    const material = object.material;
                    if (Array.isArray(material)) {
                        const groups = geometry.groups;
                        for(let i153 = 0, l = groups.length; i153 < l; i153++){
                            const group = groups[i153];
                            const groupMaterial = material[group.materialIndex];
                            if (groupMaterial && groupMaterial.visible) currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                        }
                    } else if (material.visible) currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                }
            }
        }
        const children = object.children;
        for(let i154 = 0, l = children.length; i154 < l; i154++)projectObject(children[i154], camera, groupOrder, sortObjects);
    }
    function renderObjects(renderList, scene, camera) {
        const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
        for(let i155 = 0, l = renderList.length; i155 < l; i155++){
            const renderItem = renderList[i155];
            const object = renderItem.object;
            const geometry = renderItem.geometry;
            const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
            const group = renderItem.group;
            if (camera.isArrayCamera) {
                _currentArrayCamera = camera;
                const cameras = camera.cameras;
                for(let j = 0, jl = cameras.length; j < jl; j++){
                    const camera2 = cameras[j];
                    if (object.layers.test(camera2.layers)) {
                        state.viewport(_currentViewport.copy(camera2.viewport));
                        currentRenderState.setupLights(camera2);
                        renderObject(object, scene, camera2, geometry, material, group);
                    }
                }
            } else {
                _currentArrayCamera = null;
                renderObject(object, scene, camera, geometry, material, group);
            }
        }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
        object.onBeforeRender(_this, scene, camera, geometry, material, group);
        currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        if (object.isImmediateRenderObject) {
            const program = setProgram(camera, scene, material, object);
            state.setMaterial(material);
            bindingStates.reset();
            renderObjectImmediate(object, program);
        } else _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        object.onAfterRender(_this, scene, camera, geometry, material, group);
        currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
    }
    function initMaterial(material, scene, object) {
        if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        const shadowsArray = currentRenderState.state.shadowsArray;
        const lightsStateVersion = lights.state.version;
        const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object);
        const programCacheKey = programCache.getProgramCacheKey(parameters);
        let program = materialProperties.program;
        let programChange = true;
        if (program === undefined) // new material
        material.addEventListener('dispose', onMaterialDispose);
        else if (program.cacheKey !== programCacheKey) // changed glsl or parameters
        releaseMaterialProgramReference(material);
        else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
            materialProperties.lightsStateVersion = lightsStateVersion;
            programChange = false;
        } else if (parameters.shaderID !== undefined) // same glsl and uniform list
        return;
        else // only rebuild uniform list
        programChange = false;
        if (programChange) {
            program = programCache.acquireProgram(parameters, programCacheKey);
            materialProperties.program = program;
            materialProperties.uniforms = parameters.uniforms;
            materialProperties.outputEncoding = parameters.outputEncoding;
            material.program = program;
        }
        const programAttributes = program.getAttributes();
        if (material.morphTargets) {
            material.numSupportedMorphTargets = 0;
            for(let i156 = 0; i156 < _this.maxMorphTargets; i156++)if (programAttributes['morphTarget' + i156] >= 0) material.numSupportedMorphTargets++;
        }
        if (material.morphNormals) {
            material.numSupportedMorphNormals = 0;
            for(let i157 = 0; i157 < _this.maxMorphNormals; i157++)if (programAttributes['morphNormal' + i157] >= 0) material.numSupportedMorphNormals++;
        }
        const uniforms = materialProperties.uniforms;
        if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
            materialProperties.numClippingPlanes = _clipping.numPlanes;
            materialProperties.numIntersection = _clipping.numIntersection;
            uniforms.clippingPlanes = _clipping.uniform;
        }
        materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
        materialProperties.fog = scene.fog;
        // store the light setup it was created for
        materialProperties.needsLights = materialNeedsLights(material);
        materialProperties.lightsStateVersion = lightsStateVersion;
        if (materialProperties.needsLights) {
            // wire up the material to this renderer's lighting state
            uniforms.ambientLightColor.value = lights.state.ambient;
            uniforms.lightProbe.value = lights.state.probe;
            uniforms.directionalLights.value = lights.state.directional;
            uniforms.directionalLightShadows.value = lights.state.directionalShadow;
            uniforms.spotLights.value = lights.state.spot;
            uniforms.spotLightShadows.value = lights.state.spotShadow;
            uniforms.rectAreaLights.value = lights.state.rectArea;
            uniforms.pointLights.value = lights.state.point;
            uniforms.pointLightShadows.value = lights.state.pointShadow;
            uniforms.hemisphereLights.value = lights.state.hemi;
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
            uniforms.spotShadowMap.value = lights.state.spotShadowMap;
            uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
            uniforms.pointShadowMap.value = lights.state.pointShadowMap;
            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        // TODO (abelnation): add area lights shadow info to uniforms
        }
        const progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
        materialProperties.uniformsList = uniformsList;
    }
    function setProgram(camera, scene, material, object) {
        if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
        textures.resetTextureUnits();
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        if (_clippingEnabled === true) {
            if (_localClippingEnabled === true || camera !== _currentCamera) {
                const useCache = camera === _currentCamera && material.id === _currentMaterialId;
                // we might want to call this function with some ClippingGroup
                // object instead of the material, once it becomes feasible
                // (#8465, #8379)
                _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
            }
        }
        if (material.version === materialProperties.__version) {
            if (materialProperties.program === undefined) initMaterial(material, scene, object);
            else if (material.fog && materialProperties.fog !== fog) initMaterial(material, scene, object);
            else if (materialProperties.environment !== environment) initMaterial(material, scene, object);
            else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) initMaterial(material, scene, object);
            else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) initMaterial(material, scene, object);
            else if (materialProperties.outputEncoding !== encoding) initMaterial(material, scene, object);
        } else {
            initMaterial(material, scene, object);
            materialProperties.__version = material.version;
        }
        let refreshProgram = false;
        let refreshMaterial = false;
        let refreshLights = false;
        const program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
        if (state.useProgram(program.program)) {
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
            _currentMaterialId = material.id;
            refreshMaterial = true;
        }
        if (refreshProgram || _currentCamera !== camera) {
            p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
            if (capabilities.logarithmicDepthBuffer) p_uniforms.setValue(_gl, 'logDepthBufFC', 2 / (Math.log(camera.far + 1) / Math.LN2));
            if (_currentCamera !== camera) {
                _currentCamera = camera;
                // lighting uniforms depend on the camera so enforce an update
                // now, in case this material supports lights - or later, when
                // the next material that does gets activated:
                refreshMaterial = true; // set to true on material change
                refreshLights = true; // remains set until update done
            }
            // load material specific uniforms
            // (shader material also gets them for the sake of genericity)
            if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
                const uCamPos = p_uniforms.map.cameraPosition;
                if (uCamPos !== undefined) uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
            }
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
        }
        // skinning uniforms must be set even if material didn't change
        // auto-setting of texture unit for bone texture must go before other textures
        // otherwise textures used for skinning can take over texture units reserved for other material textures
        if (material.skinning) {
            p_uniforms.setOptional(_gl, object, 'bindMatrix');
            p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
            const skeleton = object.skeleton;
            if (skeleton) {
                const bones = skeleton.bones;
                if (capabilities.floatVertexTextures) {
                    if (skeleton.boneTexture === undefined) {
                        // layout (1 matrix = 4 pixels)
                        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                        //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                        //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                        //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                        //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
                        let size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix
                        size = MathUtils.ceilPowerOfTwo(size);
                        size = Math.max(size, 4);
                        const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
                        boneMatrices.set(skeleton.boneMatrices); // copy current values
                        const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
                        skeleton.boneMatrices = boneMatrices;
                        skeleton.boneTexture = boneTexture;
                        skeleton.boneTextureSize = size;
                    }
                    p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
                    p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
                } else p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
            }
        }
        if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
            materialProperties.receiveShadow = object.receiveShadow;
            p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
        }
        if (refreshMaterial) {
            p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
            if (materialProperties.needsLights) // the current material requires lighting info
            // note: all lighting uniforms are always set correctly
            // they simply reference the renderer's state for their
            // values
            //
            // use the current material's .needsUpdate flags to set
            // the GL state when required
            markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            // refresh uniforms common to several materials
            if (fog && material.fog) materials.refreshFogUniforms(m_uniforms, fog);
            materials.refreshMaterialUniforms(m_uniforms, material, environment, _pixelRatio, _height);
            // RectAreaLight Texture
            // TODO (mrdoob): Find a nicer implementation
            if (m_uniforms.ltc_1 !== undefined) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
            if (m_uniforms.ltc_2 !== undefined) m_uniforms.ltc_2.value = UniformsLib.LTC_2;
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        }
        if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
            material.uniformsNeedUpdate = false;
        }
        if (material.isSpriteMaterial) p_uniforms.setValue(_gl, 'center', object.center);
        // common matrices
        p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
        p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
        p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
        return program;
    }
    // If uniforms are marked as clean, they don't need to be loaded to the GPU.
    function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.lightProbe.needsUpdate = value;
        uniforms.directionalLights.needsUpdate = value;
        uniforms.directionalLightShadows.needsUpdate = value;
        uniforms.pointLights.needsUpdate = value;
        uniforms.pointLightShadows.needsUpdate = value;
        uniforms.spotLights.needsUpdate = value;
        uniforms.spotLightShadows.needsUpdate = value;
        uniforms.rectAreaLights.needsUpdate = value;
        uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
        return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    //
    this.setFramebuffer = function(value) {
        if (_framebuffer !== value && _currentRenderTarget === null) _gl.bindFramebuffer(36160, value);
        _framebuffer = value;
    };
    this.getActiveCubeFace = function() {
        return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
        return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
        return _currentRenderTarget;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace, activeMipmapLevel) {
        _currentRenderTarget = renderTarget;
        _currentActiveCubeFace = activeCubeFace;
        _currentActiveMipmapLevel = activeMipmapLevel;
        if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) textures.setupRenderTarget(renderTarget);
        let framebuffer = _framebuffer;
        let isCube = false;
        if (renderTarget) {
            const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget) {
                framebuffer = __webglFramebuffer[activeCubeFace || 0];
                isCube = true;
            } else if (renderTarget.isWebGLMultisampleRenderTarget) framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
            else framebuffer = __webglFramebuffer;
            _currentViewport.copy(renderTarget.viewport);
            _currentScissor.copy(renderTarget.scissor);
            _currentScissorTest = renderTarget.scissorTest;
        } else {
            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
            _currentScissorTest = _scissorTest;
        }
        if (_currentFramebuffer !== framebuffer) {
            _gl.bindFramebuffer(36160, framebuffer);
            _currentFramebuffer = framebuffer;
        }
        state.viewport(_currentViewport);
        state.scissor(_currentScissor);
        state.setScissorTest(_currentScissorTest);
        if (isCube) {
            const textureProperties = properties.get(renderTarget.texture);
            _gl.framebufferTexture2D(36160, 36064, 34069 + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipmapLevel || 0);
        }
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
            return;
        }
        let framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) framebuffer = framebuffer[activeCubeFaceIndex];
        if (framebuffer) {
            let restore = false;
            if (framebuffer !== _currentFramebuffer) {
                _gl.bindFramebuffer(36160, framebuffer);
                restore = true;
            }
            try {
                const texture = renderTarget.texture;
                const textureFormat = texture.format;
                const textureType = texture.type;
                if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                    return;
                }
                if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get('EXT_color_buffer_float') : extensions.get('EXT_color_buffer_half_float')))) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                    return;
                }
                if (_gl.checkFramebufferStatus(36160) === 36053) // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
                {
                    if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                } else console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
            } finally{
                if (restore) _gl.bindFramebuffer(36160, _currentFramebuffer);
            }
        }
    };
    this.copyFramebufferToTexture = function(position, texture, level) {
        if (level === undefined) level = 0;
        const levelScale = Math.pow(2, -level);
        const width = Math.floor(texture.image.width * levelScale);
        const height = Math.floor(texture.image.height * levelScale);
        const glFormat = utils.convert(texture.format);
        textures.setTexture2D(texture, 0);
        _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
        state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level) {
        if (level === undefined) level = 0;
        const width = srcTexture.image.width;
        const height = srcTexture.image.height;
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        textures.setTexture2D(dstTexture, 0);
        // As another texture upload may have changed pixelStorei
        // parameters, make sure they are correct for the dstTexture
        _gl.pixelStorei(37440, dstTexture.flipY);
        _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(3317, dstTexture.unpackAlignment);
        if (srcTexture.isDataTexture) _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
        else if (srcTexture.isCompressedTexture) _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        else _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
        // Generate mipmaps only when copying level 0
        if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);
        state.unbindTexture();
    };
    this.initTexture = function(texture) {
        textures.setTexture2D(texture, 0);
        state.unbindTexture();
    };
    if (typeof __THREE_DEVTOOLS__ !== 'undefined') __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: this
    })); // eslint-disable-line no-undef
}
/**
 * @author Mugen87 / https://github.com/Mugen87
 */ function WebGL1Renderer(parameters) {
    WebGLRenderer.call(this, parameters);
}
WebGL1Renderer.prototype = Object.assign(Object.create(WebGLRenderer.prototype), {
    constructor: WebGL1Renderer,
    isWebGL1Renderer: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */ function FogExp2(color, density) {
    this.name = '';
    this.color = new Color(color);
    this.density = density !== undefined ? density : 0.00025;
}
Object.assign(FogExp2.prototype, {
    isFogExp2: true,
    clone: function() {
        return new FogExp2(this.color, this.density);
    },
    toJSON: function() {
        return {
            type: 'FogExp2',
            color: this.color.getHex(),
            density: this.density
        };
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */ function Fog(color, near, far) {
    this.name = '';
    this.color = new Color(color);
    this.near = near !== undefined ? near : 1;
    this.far = far !== undefined ? far : 1000;
}
Object.assign(Fog.prototype, {
    isFog: true,
    clone: function() {
        return new Fog(this.color, this.near, this.far);
    },
    toJSON: function() {
        return {
            type: 'Fog',
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */ function InterleavedBuffer(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== undefined ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0;
    this.uuid = MathUtils.generateUUID();
}
Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {
    set: function(value) {
        if (value === true) this.version++;
    }
});
Object.assign(InterleavedBuffer.prototype, {
    isInterleavedBuffer: true,
    onUploadCallback: function() {},
    setUsage: function(value) {
        this.usage = value;
        return this;
    },
    copy: function(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
    },
    copyAt: function(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for(let i158 = 0, l = this.stride; i158 < l; i158++)this.array[index1 + i158] = attribute.array[index2 + i158];
        return this;
    },
    set: function(value, offset) {
        if (offset === undefined) offset = 0;
        this.array.set(value, offset);
        return this;
    },
    clone: function(data) {
        if (data.arrayBuffers === undefined) data.arrayBuffers = {};
        if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = MathUtils.generateUUID();
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
        const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
        const ib = new InterleavedBuffer(array, this.stride);
        ib.setUsage(this.usage);
        return ib;
    },
    onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
    },
    toJSON: function(data) {
        if (data.arrayBuffers === undefined) data.arrayBuffers = {};
        // generate UUID for array buffer if necessary
        if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = MathUtils.generateUUID();
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
        //
        return {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        };
    }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */ const _vector$6 = new Vector3();
function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
    this.name = '';
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
}
Object.defineProperties(InterleavedBufferAttribute.prototype, {
    count: {
        get: function() {
            return this.data.count;
        }
    },
    array: {
        get: function() {
            return this.data.array;
        }
    }
});
Object.assign(InterleavedBufferAttribute.prototype, {
    isInterleavedBufferAttribute: true,
    applyMatrix4: function(m) {
        for(let i159 = 0, l = this.data.count; i159 < l; i159++){
            _vector$6.x = this.getX(i159);
            _vector$6.y = this.getY(i159);
            _vector$6.z = this.getZ(i159);
            _vector$6.applyMatrix4(m);
            this.setXYZ(i159, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
    },
    setX: function(index, x) {
        this.data.array[index * this.data.stride + this.offset] = x;
        return this;
    },
    setY: function(index, y) {
        this.data.array[index * this.data.stride + this.offset + 1] = y;
        return this;
    },
    setZ: function(index, z) {
        this.data.array[index * this.data.stride + this.offset + 2] = z;
        return this;
    },
    setW: function(index, w) {
        this.data.array[index * this.data.stride + this.offset + 3] = w;
        return this;
    },
    getX: function(index) {
        return this.data.array[index * this.data.stride + this.offset];
    },
    getY: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 1];
    },
    getZ: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 2];
    },
    getW: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 3];
    },
    setXY: function(index, x, y) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        return this;
    },
    setXYZ: function(index, x, y, z) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        return this;
    },
    setXYZW: function(index, x, y, z, w) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        this.data.array[index + 3] = w;
        return this;
    },
    clone: function(data) {
        if (data === undefined) {
            console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
            const array = [];
            for(let i160 = 0; i160 < this.count; i160++){
                const index = i160 * this.data.stride + this.offset;
                for(let j = 0; j < this.itemSize; j++)array.push(this.data.array[index + j]);
            }
            return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
        } else {
            if (data.interleavedBuffers === undefined) data.interleavedBuffers = {};
            if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
            return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
    },
    toJSON: function(data) {
        if (data === undefined) {
            console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
            const array = [];
            for(let i161 = 0; i161 < this.count; i161++){
                const index = i161 * this.data.stride + this.offset;
                for(let j = 0; j < this.itemSize; j++)array.push(this.data.array[index + j]);
            }
            // deinterleave data and save it as an ordinary buffer attribute for now
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: array,
                normalized: this.normalized
            };
        } else {
            // save as true interlaved attribtue
            if (data.interleavedBuffers === undefined) data.interleavedBuffers = {};
            if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
            return {
                isInterleavedBufferAttribute: true,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            };
        }
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */ function SpriteMaterial(parameters) {
    Material.call(this);
    this.type = 'SpriteMaterial';
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
}
SpriteMaterial.prototype = Object.create(Material.prototype);
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;
SpriteMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
};
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */ let _geometry;
const _intersectPoint = new Vector3();
const _worldScale = new Vector3();
const _mvPosition = new Vector3();
const _alignedPosition = new Vector2();
const _rotatedPosition = new Vector2();
const _viewWorldMatrix = new Matrix4();
const _vA$1 = new Vector3();
const _vB$1 = new Vector3();
const _vC$1 = new Vector3();
const _uvA$1 = new Vector2();
const _uvB$1 = new Vector2();
const _uvC$1 = new Vector2();
function Sprite(material) {
    Object3D.call(this);
    this.type = 'Sprite';
    if (_geometry === undefined) {
        _geometry = new BufferGeometry();
        const float32Array = new Float32Array([
            -0.5,
            -0.5,
            0,
            0,
            0,
            0.5,
            -0.5,
            0,
            1,
            0,
            0.5,
            0.5,
            0,
            1,
            1,
            -0.5,
            0.5,
            0,
            0,
            1
        ]);
        const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
        _geometry.setIndex([
            0,
            1,
            2,
            0,
            2,
            3
        ]);
        _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
        _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== undefined ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
}
Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Sprite,
    isSprite: true,
    raycast: function(raycaster, intersects2) {
        if (raycaster.camera === null) console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
        _worldScale.setFromMatrixScale(this.matrixWorld);
        _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
        _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) _worldScale.multiplyScalar(-_mvPosition.z);
        const rotation = this.material.rotation;
        let sin, cos;
        if (rotation !== 0) {
            cos = Math.cos(rotation);
            sin = Math.sin(rotation);
        }
        const center = this.center;
        transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        _uvA$1.set(0, 0);
        _uvB$1.set(1, 0);
        _uvC$1.set(1, 1);
        // check first triangle
        let intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);
        if (intersect === null) {
            // check second triangle
            transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
            _uvB$1.set(0, 1);
            intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);
            if (intersect === null) return;
        }
        const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects2.push({
            distance: distance,
            point: _intersectPoint.clone(),
            uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
            face: null,
            object: this
        });
    },
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        if (source.center !== undefined) this.center.copy(source.center);
        this.material = source.material;
        return this;
    }
});
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
    // compute position in camera space
    _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
    // to check if rotation is not zero
    if (sin !== undefined) {
        _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
        _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
    } else _rotatedPosition.copy(_alignedPosition);
    vertexPosition.copy(mvPosition);
    vertexPosition.x += _rotatedPosition.x;
    vertexPosition.y += _rotatedPosition.y;
    // transform to world space
    vertexPosition.applyMatrix4(_viewWorldMatrix);
}
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */ const _v1$4 = new Vector3();
const _v2$2 = new Vector3();
function LOD() {
    Object3D.call(this);
    this._currentLevel = 0;
    this.type = 'LOD';
    Object.defineProperties(this, {
        levels: {
            enumerable: true,
            value: []
        }
    });
    this.autoUpdate = true;
}
LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: LOD,
    isLOD: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source, false);
        const levels = source.levels;
        for(let i162 = 0, l = levels.length; i162 < l; i162++){
            const level = levels[i162];
            this.addLevel(level.object.clone(), level.distance);
        }
        this.autoUpdate = source.autoUpdate;
        return this;
    },
    addLevel: function(object, distance) {
        if (distance === undefined) distance = 0;
        distance = Math.abs(distance);
        const levels = this.levels;
        let l;
        for(l = 0; l < levels.length; l++){
            if (distance < levels[l].distance) break;
        }
        levels.splice(l, 0, {
            distance: distance,
            object: object
        });
        this.add(object);
        return this;
    },
    getCurrentLevel: function() {
        return this._currentLevel;
    },
    getObjectForDistance: function(distance) {
        const levels = this.levels;
        if (levels.length > 0) {
            let i163, l;
            for(i163 = 1, l = levels.length; i163 < l; i163++){
                if (distance < levels[i163].distance) break;
            }
            return levels[i163 - 1].object;
        }
        return null;
    },
    raycast: function(raycaster, intersects3) {
        const levels = this.levels;
        if (levels.length > 0) {
            _v1$4.setFromMatrixPosition(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(_v1$4);
            this.getObjectForDistance(distance).raycast(raycaster, intersects3);
        }
    },
    update: function(camera) {
        const levels = this.levels;
        if (levels.length > 1) {
            _v1$4.setFromMatrixPosition(camera.matrixWorld);
            _v2$2.setFromMatrixPosition(this.matrixWorld);
            const distance = _v1$4.distanceTo(_v2$2) / camera.zoom;
            levels[0].object.visible = true;
            let i164, l;
            for(i164 = 1, l = levels.length; i164 < l; i164++){
                if (distance >= levels[i164].distance) {
                    levels[i164 - 1].object.visible = false;
                    levels[i164].object.visible = true;
                } else break;
            }
            this._currentLevel = i164 - 1;
            for(; i164 < l; i164++)levels[i164].object.visible = false;
        }
    },
    toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        if (this.autoUpdate === false) data.object.autoUpdate = false;
        data.object.levels = [];
        const levels = this.levels;
        for(let i165 = 0, l = levels.length; i165 < l; i165++){
            const level = levels[i165];
            data.object.levels.push({
                object: level.object.uuid,
                distance: level.distance
            });
        }
        return data;
    }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */ function SkinnedMesh(geometry, material) {
    if (geometry && geometry.isGeometry) console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    Mesh.call(this, geometry, material);
    this.type = 'SkinnedMesh';
    this.bindMode = 'attached';
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
}
SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: SkinnedMesh,
    isSkinnedMesh: true,
    copy: function(source) {
        Mesh.prototype.copy.call(this, source);
        this.bindMode = source.bindMode;
        this.bindMatrix.copy(source.bindMatrix);
        this.bindMatrixInverse.copy(source.bindMatrixInverse);
        this.skeleton = source.skeleton;
        return this;
    },
    bind: function(skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === undefined) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.getInverse(bindMatrix);
    },
    pose: function() {
        this.skeleton.pose();
    },
    normalizeSkinWeights: function() {
        const vector = new Vector4();
        const skinWeight = this.geometry.attributes.skinWeight;
        for(let i166 = 0, l = skinWeight.count; i166 < l; i166++){
            vector.x = skinWeight.getX(i166);
            vector.y = skinWeight.getY(i166);
            vector.z = skinWeight.getZ(i166);
            vector.w = skinWeight.getW(i166);
            const scale = 1 / vector.manhattanLength();
            if (scale !== Infinity) vector.multiplyScalar(scale);
            else vector.set(1, 0, 0, 0); // do something reasonable
            skinWeight.setXYZW(i166, vector.x, vector.y, vector.z, vector.w);
        }
    },
    updateMatrixWorld: function(force) {
        Mesh.prototype.updateMatrixWorld.call(this, force);
        if (this.bindMode === 'attached') this.bindMatrixInverse.getInverse(this.matrixWorld);
        else if (this.bindMode === 'detached') this.bindMatrixInverse.getInverse(this.bindMatrix);
        else console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
    },
    boneTransform: function() {
        const basePosition = new Vector3();
        const skinIndex = new Vector4();
        const skinWeight = new Vector4();
        const vector = new Vector3();
        const matrix = new Matrix4();
        return function(index, target) {
            const skeleton = this.skeleton;
            const geometry = this.geometry;
            skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
            skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
            basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
            target.set(0, 0, 0);
            for(let i167 = 0; i167 < 4; i167++){
                const weight = skinWeight.getComponent(i167);
                if (weight !== 0) {
                    const boneIndex = skinIndex.getComponent(i167);
                    matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
                    target.addScaledVector(vector.copy(basePosition).applyMatrix4(matrix), weight);
                }
            }
            return target.applyMatrix4(this.bindMatrixInverse);
        };
    }()
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */ const _offsetMatrix = new Matrix4();
const _identityMatrix = new Matrix4();
function Skeleton(bones, boneInverses) {
    // copy the bone array
    bones = bones || [];
    this.bones = bones.slice(0);
    this.boneMatrices = new Float32Array(this.bones.length * 16);
    this.frame = -1;
    // use the supplied bone inverses or calculate the inverses
    if (boneInverses === undefined) this.calculateInverses();
    else if (this.bones.length === boneInverses.length) this.boneInverses = boneInverses.slice(0);
    else {
        console.warn('THREE.Skeleton boneInverses is the wrong length.');
        this.boneInverses = [];
        for(let i168 = 0, il = this.bones.length; i168 < il; i168++)this.boneInverses.push(new Matrix4());
    }
}
Object.assign(Skeleton.prototype, {
    calculateInverses: function() {
        this.boneInverses = [];
        for(let i169 = 0, il = this.bones.length; i169 < il; i169++){
            const inverse = new Matrix4();
            if (this.bones[i169]) inverse.getInverse(this.bones[i169].matrixWorld);
            this.boneInverses.push(inverse);
        }
    },
    pose: function() {
        // recover the bind-time world matrices
        for(let i171 = 0, il = this.bones.length; i171 < il; i171++){
            const bone = this.bones[i171];
            if (bone) bone.matrixWorld.getInverse(this.boneInverses[i171]);
        }
        // compute the local matrices, positions, rotations and scales
        for(let i170 = 0, il19 = this.bones.length; i170 < il19; i170++){
            const bone = this.bones[i170];
            if (bone) {
                if (bone.parent && bone.parent.isBone) {
                    bone.matrix.getInverse(bone.parent.matrixWorld);
                    bone.matrix.multiply(bone.matrixWorld);
                } else bone.matrix.copy(bone.matrixWorld);
                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
        }
    },
    update: function() {
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        const boneMatrices = this.boneMatrices;
        const boneTexture = this.boneTexture;
        // flatten bone matrices to array
        for(let i172 = 0, il = bones.length; i172 < il; i172++){
            // compute the offset between the current and the original transform
            const matrix = bones[i172] ? bones[i172].matrixWorld : _identityMatrix;
            _offsetMatrix.multiplyMatrices(matrix, boneInverses[i172]);
            _offsetMatrix.toArray(boneMatrices, i172 * 16);
        }
        if (boneTexture !== undefined) boneTexture.needsUpdate = true;
    },
    clone: function() {
        return new Skeleton(this.bones, this.boneInverses);
    },
    getBoneByName: function(name) {
        for(let i173 = 0, il = this.bones.length; i173 < il; i173++){
            const bone = this.bones[i173];
            if (bone.name === name) return bone;
        }
        return undefined;
    },
    dispose: function() {
        if (this.boneTexture) {
            this.boneTexture.dispose();
            this.boneTexture = undefined;
        }
    }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */ function Bone() {
    Object3D.call(this);
    this.type = 'Bone';
}
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Bone,
    isBone: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ const _instanceLocalMatrix = new Matrix4();
const _instanceWorldMatrix = new Matrix4();
const _instanceIntersects = [];
const _mesh = new Mesh();
function InstancedMesh(geometry, material, count) {
    Mesh.call(this, geometry, material);
    this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
    this.count = count;
    this.frustumCulled = false;
}
InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: InstancedMesh,
    isInstancedMesh: true,
    copy: function(source) {
        Mesh.prototype.copy.call(this, source);
        this.instanceMatrix.copy(source.instanceMatrix);
        this.count = source.count;
        return this;
    },
    getMatrixAt: function(index, matrix) {
        matrix.fromArray(this.instanceMatrix.array, index * 16);
    },
    raycast: function(raycaster, intersects4) {
        const matrixWorld = this.matrixWorld;
        const raycastTimes = this.count;
        _mesh.geometry = this.geometry;
        _mesh.material = this.material;
        if (_mesh.material === undefined) return;
        for(let instanceId = 0; instanceId < raycastTimes; instanceId++){
            // calculate the world matrix for each instance
            this.getMatrixAt(instanceId, _instanceLocalMatrix);
            _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
            // the mesh represents this single instance
            _mesh.matrixWorld = _instanceWorldMatrix;
            _mesh.raycast(raycaster, _instanceIntersects);
            // process the result of raycast
            for(let i174 = 0, l = _instanceIntersects.length; i174 < l; i174++){
                const intersect = _instanceIntersects[i174];
                intersect.instanceId = instanceId;
                intersect.object = this;
                intersects4.push(intersect);
            }
            _instanceIntersects.length = 0;
        }
    },
    setMatrixAt: function(index, matrix) {
        matrix.toArray(this.instanceMatrix.array, index * 16);
    },
    updateMorphTargets: function() {}
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */ function LineBasicMaterial(parameters) {
    Material.call(this);
    this.type = 'LineBasicMaterial';
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = 'round';
    this.linejoin = 'round';
    this.morphTargets = false;
    this.setValues(parameters);
}
LineBasicMaterial.prototype = Object.create(Material.prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;
LineBasicMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.morphTargets = source.morphTargets;
    return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ const _start = new Vector3();
const _end = new Vector3();
const _inverseMatrix$1 = new Matrix4();
const _ray$1 = new Ray();
const _sphere$2 = new Sphere();
function Line(geometry, material, mode) {
    if (mode === 1) console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');
    Object3D.call(this);
    this.type = 'Line';
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new LineBasicMaterial();
    this.updateMorphTargets();
}
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Line,
    isLine: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    },
    computeLineDistances: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            // we assume non-indexed geometry
            if (geometry.index === null) {
                const positionAttribute = geometry.attributes.position;
                const lineDistances = [
                    0
                ];
                for(let i175 = 1, l = positionAttribute.count; i175 < l; i175++){
                    _start.fromBufferAttribute(positionAttribute, i175 - 1);
                    _end.fromBufferAttribute(positionAttribute, i175);
                    lineDistances[i175] = lineDistances[i175 - 1];
                    lineDistances[i175] += _start.distanceTo(_end);
                }
                geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
            } else console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        } else if (geometry.isGeometry) {
            const vertices = geometry.vertices;
            const lineDistances = geometry.lineDistances;
            lineDistances[0] = 0;
            for(let i176 = 1, l = vertices.length; i176 < l; i176++){
                lineDistances[i176] = lineDistances[i176 - 1];
                lineDistances[i176] += vertices[i176 - 1].distanceTo(vertices[i176]);
            }
        }
        return this;
    },
    raycast: function(raycaster, intersects5) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Line.threshold;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$2.copy(geometry.boundingSphere);
        _sphere$2.applyMatrix4(matrixWorld);
        _sphere$2.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere$2) === false) return;
        //
        _inverseMatrix$1.getInverse(matrixWorld);
        _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        const vStart = new Vector3();
        const vEnd = new Vector3();
        const interSegment = new Vector3();
        const interRay = new Vector3();
        const step = this && this.isLineSegments ? 2 : 1;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positions = attributes.position.array;
            if (index !== null) {
                const indices = index.array;
                for(let i177 = 0, l = indices.length - 1; i177 < l; i177 += step){
                    const a = indices[i177];
                    const b = indices[i177 + 1];
                    vStart.fromArray(positions, a * 3);
                    vEnd.fromArray(positions, b * 3);
                    const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                    if (distSq > localThresholdSq) continue;
                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                    const distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far) continue;
                    intersects5.push({
                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i177,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            } else for(let i178 = 0, l = positions.length / 3 - 1; i178 < l; i178 += step){
                vStart.fromArray(positions, 3 * i178);
                vEnd.fromArray(positions, 3 * i178 + 3);
                const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq) continue;
                interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far) continue;
                intersects5.push({
                    distance: distance,
                    // What do we want? intersection point on the ray or on the segment??
                    // point: raycaster.ray.at( distance ),
                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                    index: i178,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
        } else if (geometry.isGeometry) {
            const vertices = geometry.vertices;
            const nbVertices = vertices.length;
            for(let i179 = 0; i179 < nbVertices - 1; i179 += step){
                const distSq = _ray$1.distanceSqToSegment(vertices[i179], vertices[i179 + 1], interRay, interSegment);
                if (distSq > localThresholdSq) continue;
                interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far) continue;
                intersects5.push({
                    distance: distance,
                    // What do we want? intersection point on the ray or on the segment??
                    // point: raycaster.ray.at( distance ),
                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                    index: i179,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
        }
    },
    updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ const _start$1 = new Vector3();
const _end$1 = new Vector3();
function LineSegments(geometry, material) {
    Line.call(this, geometry, material);
    this.type = 'LineSegments';
}
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineSegments,
    isLineSegments: true,
    computeLineDistances: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            // we assume non-indexed geometry
            if (geometry.index === null) {
                const positionAttribute = geometry.attributes.position;
                const lineDistances = [];
                for(let i180 = 0, l = positionAttribute.count; i180 < l; i180 += 2){
                    _start$1.fromBufferAttribute(positionAttribute, i180);
                    _end$1.fromBufferAttribute(positionAttribute, i180 + 1);
                    lineDistances[i180] = i180 === 0 ? 0 : lineDistances[i180 - 1];
                    lineDistances[i180 + 1] = lineDistances[i180] + _start$1.distanceTo(_end$1);
                }
                geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
            } else console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        } else if (geometry.isGeometry) {
            const vertices = geometry.vertices;
            const lineDistances = geometry.lineDistances;
            for(let i181 = 0, l = vertices.length; i181 < l; i181 += 2){
                _start$1.copy(vertices[i181]);
                _end$1.copy(vertices[i181 + 1]);
                lineDistances[i181] = i181 === 0 ? 0 : lineDistances[i181 - 1];
                lineDistances[i181 + 1] = lineDistances[i181] + _start$1.distanceTo(_end$1);
            }
        }
        return this;
    }
});
/**
 * @author mgreter / http://github.com/mgreter
 */ function LineLoop(geometry, material) {
    Line.call(this, geometry, material);
    this.type = 'LineLoop';
}
LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineLoop,
    isLineLoop: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */ function PointsMaterial(parameters) {
    Material.call(this);
    this.type = 'PointsMaterial';
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.setValues(parameters);
}
PointsMaterial.prototype = Object.create(Material.prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;
PointsMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
};
/**
 * @author alteredq / http://alteredqualia.com/
 */ const _inverseMatrix$2 = new Matrix4();
const _ray$2 = new Ray();
const _sphere$3 = new Sphere();
const _position$1 = new Vector3();
function Points(geometry, material) {
    Object3D.call(this);
    this.type = 'Points';
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    this.material = material !== undefined ? material : new PointsMaterial();
    this.updateMorphTargets();
}
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Points,
    isPoints: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    },
    raycast: function(raycaster, intersects6) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Points.threshold;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$3.copy(geometry.boundingSphere);
        _sphere$3.applyMatrix4(matrixWorld);
        _sphere$3.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;
        //
        _inverseMatrix$2.getInverse(matrixWorld);
        _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positions = attributes.position.array;
            if (index !== null) {
                const indices = index.array;
                for(let i182 = 0, il = indices.length; i182 < il; i182++){
                    const a = indices[i182];
                    _position$1.fromArray(positions, a * 3);
                    testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects6, this);
                }
            } else for(let i183 = 0, l = positions.length / 3; i183 < l; i183++){
                _position$1.fromArray(positions, i183 * 3);
                testPoint(_position$1, i183, localThresholdSq, matrixWorld, raycaster, intersects6, this);
            }
        } else {
            const vertices = geometry.vertices;
            for(let i184 = 0, l = vertices.length; i184 < l; i184++)testPoint(vertices[i184], i184, localThresholdSq, matrixWorld, raycaster, intersects6, this);
        }
    },
    updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    }
});
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects7, object) {
    const rayPointDistanceSq = _ray$2.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
        const intersectPoint = new Vector3();
        _ray$2.closestPointToPoint(point, intersectPoint);
        intersectPoint.applyMatrix4(matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects7.push({
            distance: distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint,
            index: index,
            face: null,
            object: object
        });
    }
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== undefined ? format : RGBFormat;
    this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    this.generateMipmaps = false;
}
VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
    constructor: VideoTexture,
    isVideoTexture: true,
    update: function() {
        const video = this.image;
        if (video.readyState >= video.HAVE_CURRENT_DATA) this.needsUpdate = true;
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */ function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
        width: width,
        height: height
    };
    this.mipmaps = mipmaps;
    // no flipping for cube textures
    // (also flipping doesn't work for compressed textures )
    this.flipY = false;
    // can't generate mipmaps for compressed textures
    // mips must be embedded in DDS files
    this.generateMipmaps = false;
}
CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;
/**
 * @author mrdoob / http://mrdoob.com/
 */ function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
}
CanvasTexture.prototype = Object.create(Texture.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;
/**
 * @author Matt DesLauriers / @mattdesl
 * @author atix / arthursilber.de
 */ function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== undefined ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
    if (type === undefined && format === DepthFormat) type = UnsignedShortType;
    if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {
        width: width,
        height: height
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
}
DepthTexture.prototype = Object.create(Texture.prototype);
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ function WireframeGeometry(geometry) {
    BufferGeometry.call(this);
    this.type = 'WireframeGeometry';
    // buffer
    const vertices = [];
    // helper variables
    const edge = [
        0,
        0
    ], edges = {};
    const keys = [
        'a',
        'b',
        'c'
    ];
    // different logic for Geometry and BufferGeometry
    if (geometry && geometry.isGeometry) {
        // create a data structure that contains all edges without duplicates
        const faces = geometry.faces;
        for(let i185 = 0, l = faces.length; i185 < l; i185++){
            const face = faces[i185];
            for(let j = 0; j < 3; j++){
                const edge1 = face[keys[j]];
                const edge2 = face[keys[(j + 1) % 3]];
                edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
                edge[1] = Math.max(edge1, edge2);
                const key = edge[0] + ',' + edge[1];
                if (edges[key] === undefined) edges[key] = {
                    index1: edge[0],
                    index2: edge[1]
                };
            }
        }
        // generate vertices
        for(const key in edges){
            const e = edges[key];
            let vertex = geometry.vertices[e.index1];
            vertices.push(vertex.x, vertex.y, vertex.z);
            vertex = geometry.vertices[e.index2];
            vertices.push(vertex.x, vertex.y, vertex.z);
        }
    } else if (geometry && geometry.isBufferGeometry) {
        let vertex = new Vector3();
        if (geometry.index !== null) {
            // indexed BufferGeometry
            const position = geometry.attributes.position;
            const indices = geometry.index;
            let groups = geometry.groups;
            if (groups.length === 0) groups = [
                {
                    start: 0,
                    count: indices.count,
                    materialIndex: 0
                }
            ];
            // create a data structure that contains all eges without duplicates
            for(let o = 0, ol = groups.length; o < ol; ++o){
                const group = groups[o];
                const start = group.start;
                const count = group.count;
                for(let i186 = start, l = start + count; i186 < l; i186 += 3)for(let j = 0; j < 3; j++){
                    const edge1 = indices.getX(i186 + j);
                    const edge2 = indices.getX(i186 + (j + 1) % 3);
                    edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
                    edge[1] = Math.max(edge1, edge2);
                    const key = edge[0] + ',' + edge[1];
                    if (edges[key] === undefined) edges[key] = {
                        index1: edge[0],
                        index2: edge[1]
                    };
                }
            }
            // generate vertices
            for(const key in edges){
                const e = edges[key];
                vertex.fromBufferAttribute(position, e.index1);
                vertices.push(vertex.x, vertex.y, vertex.z);
                vertex.fromBufferAttribute(position, e.index2);
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        } else {
            // non-indexed BufferGeometry
            const position = geometry.attributes.position;
            for(let i187 = 0, l = position.count / 3; i187 < l; i187++)for(let j = 0; j < 3; j++){
                // three edges per triangle, an edge is represented as (index1, index2)
                // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
                const index1 = 3 * i187 + j;
                vertex.fromBufferAttribute(position, index1);
                vertices.push(vertex.x, vertex.y, vertex.z);
                const index2 = 3 * i187 + (j + 1) % 3;
                vertex.fromBufferAttribute(position, index2);
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
    }
    // build geometry
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
}
WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
WireframeGeometry.prototype.constructor = WireframeGeometry;
/**
 * @author zz85 / https://github.com/zz85
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */ // ParametricGeometry
function ParametricGeometry(func, slices, stacks) {
    Geometry.call(this);
    this.type = 'ParametricGeometry';
    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };
    this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
    this.mergeVertices();
}
ParametricGeometry.prototype = Object.create(Geometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
// ParametricBufferGeometry
function ParametricBufferGeometry(func, slices, stacks) {
    BufferGeometry.call(this);
    this.type = 'ParametricBufferGeometry';
    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };
    // buffers
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const EPS = 0.00001;
    const normal = new Vector3();
    const p0 = new Vector3(), p1 = new Vector3();
    const pu = new Vector3(), pv = new Vector3();
    if (func.length < 3) console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
    // generate vertices, normals and uvs
    const sliceCount = slices + 1;
    for(let i189 = 0; i189 <= stacks; i189++){
        const v = i189 / stacks;
        for(let j = 0; j <= slices; j++){
            const u = j / slices;
            // vertex
            func(u, v, p0);
            vertices.push(p0.x, p0.y, p0.z);
            // normal
            // approximate tangent vectors via finite differences
            if (u - EPS >= 0) {
                func(u - EPS, v, p1);
                pu.subVectors(p0, p1);
            } else {
                func(u + EPS, v, p1);
                pu.subVectors(p1, p0);
            }
            if (v - EPS >= 0) {
                func(u, v - EPS, p1);
                pv.subVectors(p0, p1);
            } else {
                func(u, v + EPS, p1);
                pv.subVectors(p1, p0);
            }
            // cross product of tangent vectors returns surface normal
            normal.crossVectors(pu, pv).normalize();
            normals.push(normal.x, normal.y, normal.z);
            // uv
            uvs.push(u, v);
        }
    }
    // generate indices
    for(let i188 = 0; i188 < stacks; i188++)for(let j = 0; j < slices; j++){
        const a = i188 * sliceCount + j;
        const b = i188 * sliceCount + j + 1;
        const c = (i188 + 1) * sliceCount + j + 1;
        const d = (i188 + 1) * sliceCount + j;
        // faces one and two
        indices.push(a, b, d);
        indices.push(b, c, d);
    }
    // build geometry
    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
}
ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */ // PolyhedronGeometry
function PolyhedronGeometry(vertices, indices, radius, detail) {
    Geometry.call(this);
    this.type = 'PolyhedronGeometry';
    this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
    };
    this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
    this.mergeVertices();
}
PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
// PolyhedronBufferGeometry
function PolyhedronBufferGeometry(vertices, indices, radius1, detail1) {
    BufferGeometry.call(this);
    this.type = 'PolyhedronBufferGeometry';
    this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius1,
        detail: detail1
    };
    radius1 = radius1 || 1;
    detail1 = detail1 || 0;
    // default buffer data
    const vertexBuffer = [];
    const uvBuffer = [];
    // the subdivision creates the vertex buffer data
    subdivide(detail1);
    // all vertices should lie on a conceptual sphere with a given radius
    applyRadius(radius1);
    // finally, create the uv data
    generateUVs();
    // build non-indexed geometry
    this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
    if (detail1 === 0) this.computeVertexNormals(); // flat normals
    else this.normalizeNormals(); // smooth normals
    // helper functions
    function subdivide(detail) {
        const a = new Vector3();
        const b = new Vector3();
        const c = new Vector3();
        // iterate over all faces and apply a subdivison with the given detail value
        for(let i190 = 0; i190 < indices.length; i190 += 3){
            // get the vertices of the face
            getVertexByIndex(indices[i190 + 0], a);
            getVertexByIndex(indices[i190 + 1], b);
            getVertexByIndex(indices[i190 + 2], c);
            // perform subdivision
            subdivideFace(a, b, c, detail);
        }
    }
    function subdivideFace(a, b, c, detail) {
        const cols = Math.pow(2, detail);
        // we use this multidimensional array as a data structure for creating the subdivision
        const v = [];
        // construct all of the vertices for this subdivision
        for(let i192 = 0; i192 <= cols; i192++){
            v[i192] = [];
            const aj = a.clone().lerp(c, i192 / cols);
            const bj = b.clone().lerp(c, i192 / cols);
            const rows = cols - i192;
            for(let j = 0; j <= rows; j++)if (j === 0 && i192 === cols) v[i192][j] = aj;
            else v[i192][j] = aj.clone().lerp(bj, j / rows);
        }
        // construct all of the faces
        for(let i191 = 0; i191 < cols; i191++)for(let j = 0; j < 2 * (cols - i191) - 1; j++){
            const k = Math.floor(j / 2);
            if (j % 2 === 0) {
                pushVertex(v[i191][k + 1]);
                pushVertex(v[i191 + 1][k]);
                pushVertex(v[i191][k]);
            } else {
                pushVertex(v[i191][k + 1]);
                pushVertex(v[i191 + 1][k + 1]);
                pushVertex(v[i191 + 1][k]);
            }
        }
    }
    function applyRadius(radius) {
        const vertex = new Vector3();
        // iterate over the entire buffer and apply the radius to each vertex
        for(let i193 = 0; i193 < vertexBuffer.length; i193 += 3){
            vertex.x = vertexBuffer[i193 + 0];
            vertex.y = vertexBuffer[i193 + 1];
            vertex.z = vertexBuffer[i193 + 2];
            vertex.normalize().multiplyScalar(radius);
            vertexBuffer[i193 + 0] = vertex.x;
            vertexBuffer[i193 + 1] = vertex.y;
            vertexBuffer[i193 + 2] = vertex.z;
        }
    }
    function generateUVs() {
        const vertex = new Vector3();
        for(let i194 = 0; i194 < vertexBuffer.length; i194 += 3){
            vertex.x = vertexBuffer[i194 + 0];
            vertex.y = vertexBuffer[i194 + 1];
            vertex.z = vertexBuffer[i194 + 2];
            const u = azimuth1(vertex) / 2 / Math.PI + 0.5;
            const v = inclination(vertex) / Math.PI + 0.5;
            uvBuffer.push(u, 1 - v);
        }
        correctUVs();
        correctSeam();
    }
    function correctSeam() {
        // handle case when face straddles the seam, see #3269
        for(let i195 = 0; i195 < uvBuffer.length; i195 += 6){
            // uv data of a single face
            const x0 = uvBuffer[i195 + 0];
            const x1 = uvBuffer[i195 + 2];
            const x2 = uvBuffer[i195 + 4];
            const max = Math.max(x0, x1, x2);
            const min = Math.min(x0, x1, x2);
            // 0.9 is somewhat arbitrary
            if (max > 0.9 && min < 0.1) {
                if (x0 < 0.2) uvBuffer[i195 + 0] += 1;
                if (x1 < 0.2) uvBuffer[i195 + 2] += 1;
                if (x2 < 0.2) uvBuffer[i195 + 4] += 1;
            }
        }
    }
    function pushVertex(vertex) {
        vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }
    function getVertexByIndex(index, vertex) {
        const stride = index * 3;
        vertex.x = vertices[stride + 0];
        vertex.y = vertices[stride + 1];
        vertex.z = vertices[stride + 2];
    }
    function correctUVs() {
        const a = new Vector3();
        const b = new Vector3();
        const c = new Vector3();
        const centroid = new Vector3();
        const uvA = new Vector2();
        const uvB = new Vector2();
        const uvC = new Vector2();
        for(let i196 = 0, j = 0; i196 < vertexBuffer.length; i196 += 9, j += 6){
            a.set(vertexBuffer[i196 + 0], vertexBuffer[i196 + 1], vertexBuffer[i196 + 2]);
            b.set(vertexBuffer[i196 + 3], vertexBuffer[i196 + 4], vertexBuffer[i196 + 5]);
            c.set(vertexBuffer[i196 + 6], vertexBuffer[i196 + 7], vertexBuffer[i196 + 8]);
            uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
            uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
            uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
            centroid.copy(a).add(b).add(c).divideScalar(3);
            const azi = azimuth1(centroid);
            correctUV(uvA, j + 0, a, azi);
            correctUV(uvB, j + 2, b, azi);
            correctUV(uvC, j + 4, c, azi);
        }
    }
    function correctUV(uv, stride, vector, azimuth) {
        if (azimuth < 0 && uv.x === 1) uvBuffer[stride] = uv.x - 1;
        if (vector.x === 0 && vector.z === 0) uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
    }
    // Angle around the Y axis, counter-clockwise when looking from above.
    function azimuth1(vector) {
        return Math.atan2(vector.z, -vector.x);
    }
    // Angle above the XZ plane.
    function inclination(vector) {
        return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
}
PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */ // TetrahedronGeometry
function TetrahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = 'TetrahedronGeometry';
    this.parameters = {
        radius: radius,
        detail: detail
    };
    this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
    this.mergeVertices();
}
TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
// TetrahedronBufferGeometry
function TetrahedronBufferGeometry(radius, detail) {
    const vertices = [
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        1,
        -1,
        -1
    ];
    const indices = [
        2,
        1,
        0,
        0,
        3,
        2,
        1,
        3,
        0,
        2,
        3,
        1
    ];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'TetrahedronBufferGeometry';
    this.parameters = {
        radius: radius,
        detail: detail
    };
}
TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */ // OctahedronGeometry
function OctahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = 'OctahedronGeometry';
    this.parameters = {
        radius: radius,
        detail: detail
    };
    this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
    this.mergeVertices();
}
OctahedronGeometry.prototype = Object.create(Geometry.prototype);
OctahedronGeometry.prototype.constructor = OctahedronGeometry;
// OctahedronBufferGeometry
function OctahedronBufferGeometry(radius, detail) {
    const vertices = [
        1,
        0,
        0,
        -1,
        0,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        0,
        0,
        1,
        0,
        0,
        -1
    ];
    const indices = [
        0,
        2,
        4,
        0,
        4,
        3,
        0,
        3,
        5,
        0,
        5,
        2,
        1,
        2,
        5,
        1,
        5,
        3,
        1,
        3,
        4,
        1,
        4,
        2
    ];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'OctahedronBufferGeometry';
    this.parameters = {
        radius: radius,
        detail: detail
    };
}
OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */ // IcosahedronGeometry
function IcosahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = 'IcosahedronGeometry';
    this.parameters = {
        radius: radius,
        detail: detail
    };
    this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
    this.mergeVertices();
}
IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
// IcosahedronBufferGeometry
function IcosahedronBufferGeometry(radius, detail) {
    const t = (1 + Math.sqrt(5)) / 2;
    const vertices = [
        -1,
        t,
        0,
        1,
        t,
        0,
        -1,
        -t,
        0,
        1,
        -t,
        0,
        0,
        -1,
        t,
        0,
        1,
        t,
        0,
        -1,
        -t,
        0,
        1,
        -t,
        t,
        0,
        -1,
        t,
        0,
        1,
        -t,
        0,
        -1,
        -t,
        0,
        1
    ];
    const indices = [
        0,
        11,
        5,
        0,
        5,
        1,
        0,
        1,
        7,
        0,
        7,
        10,
        0,
        10,
        11,
        1,
        5,
        9,
        5,
        11,
        4,
        11,
        10,
        2,
        10,
        7,
        6,
        7,
        1,
        8,
        3,
        9,
        4,
        3,
        4,
        2,
        3,
        2,
        6,
        3,
        6,
        8,
        3,
        8,
        9,
        4,
        9,
        5,
        2,
        4,
        11,
        6,
        2,
        10,
        8,
        6,
        7,
        9,
        8,
        1
    ];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'IcosahedronBufferGeometry';
    this.parameters = {
        radius: radius,
        detail: detail
    };
}
IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
/**
 * @author Abe Pazos / https://hamoid.com
 * @author Mugen87 / https://github.com/Mugen87
 */ // DodecahedronGeometry
function DodecahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = 'DodecahedronGeometry';
    this.parameters = {
        radius: radius,
        detail: detail
    };
    this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
    this.mergeVertices();
}
DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
// DodecahedronBufferGeometry
function DodecahedronBufferGeometry(radius, detail) {
    const t = (1 + Math.sqrt(5)) / 2;
    const r = 1 / t;
    const vertices = [
        // (Â±1, Â±1, Â±1)
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        // (0, Â±1/Ï†, Â±Ï†)
        0,
        -r,
        -t,
        0,
        -r,
        t,
        0,
        r,
        -t,
        0,
        r,
        t,
        // (Â±1/Ï†, Â±Ï†, 0)
        -r,
        -t,
        0,
        -r,
        t,
        0,
        r,
        -t,
        0,
        r,
        t,
        0,
        // (Â±Ï†, 0, Â±1/Ï†)
        -t,
        0,
        -r,
        t,
        0,
        -r,
        -t,
        0,
        r,
        t,
        0,
        r
    ];
    const indices = [
        3,
        11,
        7,
        3,
        7,
        15,
        3,
        15,
        13,
        7,
        19,
        17,
        7,
        17,
        6,
        7,
        6,
        15,
        17,
        4,
        8,
        17,
        8,
        10,
        17,
        10,
        6,
        8,
        0,
        16,
        8,
        16,
        2,
        8,
        2,
        10,
        0,
        12,
        1,
        0,
        1,
        18,
        0,
        18,
        16,
        6,
        10,
        2,
        6,
        2,
        13,
        6,
        13,
        15,
        2,
        16,
        18,
        2,
        18,
        3,
        2,
        3,
        13,
        18,
        1,
        9,
        18,
        9,
        11,
        18,
        11,
        3,
        4,
        14,
        12,
        4,
        12,
        0,
        4,
        0,
        8,
        11,
        9,
        5,
        11,
        5,
        19,
        11,
        19,
        7,
        19,
        5,
        14,
        19,
        14,
        4,
        19,
        4,
        17,
        1,
        12,
        14,
        1,
        14,
        5,
        1,
        5,
        9
    ];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = 'DodecahedronBufferGeometry';
    this.parameters = {
        radius: radius,
        detail: detail
    };
}
DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
/**
 * @author oosmoxiecode / https://github.com/oosmoxiecode
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 * @author Mugen87 / https://github.com/Mugen87
 *
 */ // TubeGeometry
function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
    Geometry.call(this);
    this.type = 'TubeGeometry';
    this.parameters = {
        path: path,
        tubularSegments: tubularSegments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed
    };
    if (taper !== undefined) console.warn('THREE.TubeGeometry: taper has been removed.');
    const bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
    // expose internals
    this.tangents = bufferGeometry.tangents;
    this.normals = bufferGeometry.normals;
    this.binormals = bufferGeometry.binormals;
    // create geometry
    this.fromBufferGeometry(bufferGeometry);
    this.mergeVertices();
}
TubeGeometry.prototype = Object.create(Geometry.prototype);
TubeGeometry.prototype.constructor = TubeGeometry;
// TubeBufferGeometry
function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
    BufferGeometry.call(this);
    this.type = 'TubeBufferGeometry';
    this.parameters = {
        path: path,
        tubularSegments: tubularSegments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed
    };
    tubularSegments = tubularSegments || 64;
    radius = radius || 1;
    radialSegments = radialSegments || 8;
    closed = closed || false;
    const frames = path.computeFrenetFrames(tubularSegments, closed);
    // expose internals
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    // helper variables
    const vertex = new Vector3();
    const normal = new Vector3();
    const uv = new Vector2();
    let P = new Vector3();
    // buffer
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    // create buffer data
    generateBufferData();
    // build geometry
    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    // functions
    function generateBufferData() {
        for(let i197 = 0; i197 < tubularSegments; i197++)generateSegment(i197);
        // if the geometry is not closed, generate the last row of vertices and normals
        // at the regular position on the given path
        //
        // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
        generateSegment(closed === false ? tubularSegments : 0);
        // uvs are generated in a separate function.
        // this makes it easy compute correct values for closed geometries
        generateUVs();
        // finally create faces
        generateIndices();
    }
    function generateSegment(i198) {
        // we use getPointAt to sample evenly distributed points from the given path
        P = path.getPointAt(i198 / tubularSegments, P);
        // retrieve corresponding normal and binormal
        const N = frames.normals[i198];
        const B = frames.binormals[i198];
        // generate normals and vertices for the current segment
        for(let j = 0; j <= radialSegments; j++){
            const v = j / radialSegments * Math.PI * 2;
            const sin = Math.sin(v);
            const cos = -Math.cos(v);
            // normal
            normal.x = cos * N.x + sin * B.x;
            normal.y = cos * N.y + sin * B.y;
            normal.z = cos * N.z + sin * B.z;
            normal.normalize();
            normals.push(normal.x, normal.y, normal.z);
            // vertex
            vertex.x = P.x + radius * normal.x;
            vertex.y = P.y + radius * normal.y;
            vertex.z = P.z + radius * normal.z;
            vertices.push(vertex.x, vertex.y, vertex.z);
        }
    }
    function generateIndices() {
        for(let j = 1; j <= tubularSegments; j++)for(let i199 = 1; i199 <= radialSegments; i199++){
            const a = (radialSegments + 1) * (j - 1) + (i199 - 1);
            const b = (radialSegments + 1) * j + (i199 - 1);
            const c = (radialSegments + 1) * j + i199;
            const d = (radialSegments + 1) * (j - 1) + i199;
            // faces
            indices.push(a, b, d);
            indices.push(b, c, d);
        }
    }
    function generateUVs() {
        for(let i200 = 0; i200 <= tubularSegments; i200++)for(let j = 0; j <= radialSegments; j++){
            uv.x = i200 / tubularSegments;
            uv.y = j / radialSegments;
            uvs.push(uv.x, uv.y);
        }
    }
}
TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
TubeBufferGeometry.prototype.toJSON = function() {
    const data = BufferGeometry.prototype.toJSON.call(this);
    data.path = this.parameters.path.toJSON();
    return data;
};
/**
 * @author oosmoxiecode
 * @author Mugen87 / https://github.com/Mugen87
 *
 * based on http://www.blackpawn.com/texts/pqtorus/
 */ // TorusKnotGeometry
function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
    Geometry.call(this);
    this.type = 'TorusKnotGeometry';
    this.parameters = {
        radius: radius,
        tube: tube,
        tubularSegments: tubularSegments,
        radialSegments: radialSegments,
        p: p,
        q: q
    };
    if (heightScale !== undefined) console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');
    this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
    this.mergeVertices();
}
TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
// TorusKnotBufferGeometry
function TorusKnotBufferGeometry(radius3, tube, tubularSegments, radialSegments, p6, q1) {
    BufferGeometry.call(this);
    this.type = 'TorusKnotBufferGeometry';
    this.parameters = {
        radius: radius3,
        tube: tube,
        tubularSegments: tubularSegments,
        radialSegments: radialSegments,
        p: p6,
        q: q1
    };
    radius3 = radius3 || 1;
    tube = tube || 0.4;
    tubularSegments = Math.floor(tubularSegments) || 64;
    radialSegments = Math.floor(radialSegments) || 8;
    p6 = p6 || 2;
    q1 = q1 || 3;
    // buffers
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    // helper variables
    const vertex = new Vector3();
    const normal = new Vector3();
    const P1 = new Vector3();
    const P2 = new Vector3();
    const B = new Vector3();
    const T = new Vector3();
    const N = new Vector3();
    // generate vertices, normals and uvs
    for(let i202 = 0; i202 <= tubularSegments; ++i202){
        // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
        const u = i202 / tubularSegments * p6 * Math.PI * 2;
        // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
        // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
        calculatePositionOnCurve(u, p6, q1, radius3, P1);
        calculatePositionOnCurve(u + 0.01, p6, q1, radius3, P2);
        // calculate orthonormal basis
        T.subVectors(P2, P1);
        N.addVectors(P2, P1);
        B.crossVectors(T, N);
        N.crossVectors(B, T);
        // normalize B, N. T can be ignored, we don't use it
        B.normalize();
        N.normalize();
        for(let j = 0; j <= radialSegments; ++j){
            // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
            // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
            const v = j / radialSegments * Math.PI * 2;
            const cx = -tube * Math.cos(v);
            const cy = tube * Math.sin(v);
            // now calculate the final vertex position.
            // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
            vertex.x = P1.x + (cx * N.x + cy * B.x);
            vertex.y = P1.y + (cx * N.y + cy * B.y);
            vertex.z = P1.z + (cx * N.z + cy * B.z);
            vertices.push(vertex.x, vertex.y, vertex.z);
            // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
            normal.subVectors(vertex, P1).normalize();
            normals.push(normal.x, normal.y, normal.z);
            // uv
            uvs.push(i202 / tubularSegments);
            uvs.push(j / radialSegments);
        }
    }
    // generate indices
    for(let j = 1; j <= tubularSegments; j++)for(let i201 = 1; i201 <= radialSegments; i201++){
        // indices
        const a = (radialSegments + 1) * (j - 1) + (i201 - 1);
        const b = (radialSegments + 1) * j + (i201 - 1);
        const c = (radialSegments + 1) * j + i201;
        const d = (radialSegments + 1) * (j - 1) + i201;
        // faces
        indices.push(a, b, d);
        indices.push(b, c, d);
    }
    // build geometry
    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    // this function calculates the current position on the torus curve
    function calculatePositionOnCurve(u, p, q, radius, position) {
        const cu = Math.cos(u);
        const su = Math.sin(u);
        const quOverP = q / p * u;
        const cs = Math.cos(quOverP);
        position.x = radius * (2 + cs) * 0.5 * cu;
        position.y = radius * (2 + cs) * su * 0.5;
        position.z = radius * Math.sin(quOverP) * 0.5;
    }
}
TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ // TorusGeometry
function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
    Geometry.call(this);
    this.type = 'TorusGeometry';
    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
    };
    this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
    this.mergeVertices();
}
TorusGeometry.prototype = Object.create(Geometry.prototype);
TorusGeometry.prototype.constructor = TorusGeometry;
// TorusBufferGeometry
function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
    BufferGeometry.call(this);
    this.type = 'TorusBufferGeometry';
    this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
    };
    radius = radius || 1;
    tube = tube || 0.4;
    radialSegments = Math.floor(radialSegments) || 8;
    tubularSegments = Math.floor(tubularSegments) || 6;
    arc = arc || Math.PI * 2;
    // buffers
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    // helper variables
    const center = new Vector3();
    const vertex = new Vector3();
    const normal = new Vector3();
    // generate vertices, normals and uvs
    for(let j = 0; j <= radialSegments; j++)for(let i204 = 0; i204 <= tubularSegments; i204++){
        const u = i204 / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2;
        // vertex
        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        vertices.push(vertex.x, vertex.y, vertex.z);
        // normal
        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        // uv
        uvs.push(i204 / tubularSegments);
        uvs.push(j / radialSegments);
    }
    // generate indices
    for(let j3 = 1; j3 <= radialSegments; j3++)for(let i203 = 1; i203 <= tubularSegments; i203++){
        // indices
        const a = (tubularSegments + 1) * j3 + i203 - 1;
        const b = (tubularSegments + 1) * (j3 - 1) + i203 - 1;
        const c = (tubularSegments + 1) * (j3 - 1) + i203;
        const d = (tubularSegments + 1) * j3 + i203;
        // faces
        indices.push(a, b, d);
        indices.push(b, c, d);
    }
    // build geometry
    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
}
TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
/**
 * @author Mugen87 / https://github.com/Mugen87
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */ const Earcut = {
    triangulate: function(data, holeIndices, dim) {
        dim = dim || 2;
        let hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) return triangles;
        let minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for(let i205 = dim; i205 < outerLen; i205 += dim){
                x = data[i205];
                y = data[i205 + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
};
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    let i206, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) for(i206 = start; i206 < end; i206 += dim)last = insertNode(i206, data[i206], data[i206 + 1], last);
    else for(i206 = end - dim; i206 >= start; i206 -= dim)last = insertNode(i206, data[i206], data[i206 + 1], last);
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    let p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
        } else p = p.next;
    }while (again || p !== end)
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) splitEarcut(ear, triangles, dim, minX, minY, invSize);
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    let a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    let p = ear.next.next;
    while(p !== ear.prev){
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    let a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // triangle bbox; min & max are calculated like this for speed
    let minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
    // z-order range for the current triangle bbox;
    let minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p = ear.prevZ, n = ear.nextZ;
    // look for points inside the triangle in both directions
    while(p && p.z >= minZ && n && n.z <= maxZ){
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while(p && p.z >= minZ){
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    // look for remaining points in increasing z-order
    while(n && n.z <= maxZ){
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
        let a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    }while (p !== start)
    return filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    let a = start;
    do {
        let b = a.next.next;
        while(b !== a.prev){
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                let c = splitPolygon(a, b);
                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    }while (a !== start)
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    let queue = [], i207, len, start, end, list;
    for(i207 = 0, len = holeIndices.length; i207 < len; i207++){
        start = holeIndices[i207] * dim;
        end = i207 < len - 1 ? holeIndices[i207 + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for(i207 = 0; i207 < queue.length; i207++){
        eliminateHole(queue[i207], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        const b = splitPolygon(outerNode, hole);
        // filter collinear points around the cuts
        filterPoints(outerNode, outerNode.next);
        filterPoints(b, b.next);
    }
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    let p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            let x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    }while (p !== outerNode)
    if (!m) return null;
    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    let stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }while (p !== stop)
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start)
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    let i208, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i208 = 0; i208 < inSize; i208++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1)
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    let p = start, leftmost = start;
    do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
    }while (p !== start)
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px1, py1) {
    return (cx - px1) * (ay - py1) - (ax - px1) * (cy - py1) >= 0 && (ax - px1) * (by - py1) - (bx - px1) * (ay - py1) >= 0 && (bx - px1) * (cy - py1) - (cx - px1) * (by - py1) >= 0;
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}
// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case
    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    let p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
    }while (p !== a)
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    let p = a, inside = false, px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
    do {
        if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a)
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    let a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i209, x, y, last) {
    const p = new Node(i209, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i210, x, y) {
    // vertex index in coordinates array
    this.i = i210;
    // vertex coordinates
    this.x = x;
    this.y = y;
    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = null;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
function signedArea(data, start, end, dim) {
    let sum = 0;
    for(let i211 = start, j = end - dim; i211 < end; i211 += dim){
        sum += (data[j] - data[i211]) * (data[i211 + 1] + data[j + 1]);
        j = i211;
    }
    return sum;
}
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */ const ShapeUtils = {
    // calculate area of the contour polygon
    area: function(contour) {
        const n = contour.length;
        let a = 0;
        for(let p = n - 1, q = 0; q < n; p = q++)a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        return a * 0.5;
    },
    isClockWise: function(pts) {
        return ShapeUtils.area(pts) < 0;
    },
    triangulateShape: function(contour, holes) {
        const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
        const holeIndices = []; // array of hole indices
        const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
        removeDupEndPts(contour);
        addContour(vertices, contour);
        //
        let holeIndex = contour.length;
        holes.forEach(removeDupEndPts);
        for(let i213 = 0; i213 < holes.length; i213++){
            holeIndices.push(holeIndex);
            holeIndex += holes[i213].length;
            addContour(vertices, holes[i213]);
        }
        //
        const triangles = Earcut.triangulate(vertices, holeIndices);
        //
        for(let i212 = 0; i212 < triangles.length; i212 += 3)faces.push(triangles.slice(i212, i212 + 3));
        return faces;
    }
};
function removeDupEndPts(points) {
    const l = points.length;
    if (l > 2 && points[l - 1].equals(points[0])) points.pop();
}
function addContour(vertices, contour) {
    for(let i214 = 0; i214 < contour.length; i214++){
        vertices.push(contour[i214].x);
        vertices.push(contour[i214].y);
    }
}
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */ // ExtrudeGeometry
function ExtrudeGeometry(shapes, options) {
    Geometry.call(this);
    this.type = 'ExtrudeGeometry';
    this.parameters = {
        shapes: shapes,
        options: options
    };
    this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
    this.mergeVertices();
}
ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
ExtrudeGeometry.prototype.toJSON = function() {
    const data = Geometry.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON(shapes, options, data);
};
// ExtrudeBufferGeometry
function ExtrudeBufferGeometry(shapes, options) {
    BufferGeometry.call(this);
    this.type = 'ExtrudeBufferGeometry';
    this.parameters = {
        shapes: shapes,
        options: options
    };
    shapes = Array.isArray(shapes) ? shapes : [
        shapes
    ];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for(let i215 = 0, l = shapes.length; i215 < l; i215++){
        const shape = shapes[i215];
        addShape(shape);
    }
    // build geometry
    this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    // functions
    function addShape(shape) {
        const placeholder = [];
        // options
        const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
        const steps = options.steps !== undefined ? options.steps : 1;
        let depth = options.depth !== undefined ? options.depth : 100;
        let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
        let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
        let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
        let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
        let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
        const extrudePath = options.extrudePath;
        const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;
        // deprecated options
        if (options.amount !== undefined) {
            console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
            depth = options.amount;
        }
        //
        let extrudePts, extrudeByPath = false;
        let splineTube, binormal, normal, position2;
        if (extrudePath) {
            extrudePts = extrudePath.getSpacedPoints(steps);
            extrudeByPath = true;
            bevelEnabled = false; // bevels not supported for path extrusion
            // SETUP TNB variables
            // TODO1 - have a .isClosed in spline?
            splineTube = extrudePath.computeFrenetFrames(steps, false);
            // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
            binormal = new Vector3();
            normal = new Vector3();
            position2 = new Vector3();
        }
        // Safeguards if bevels are not enabled
        if (!bevelEnabled) {
            bevelSegments = 0;
            bevelThickness = 0;
            bevelSize = 0;
            bevelOffset = 0;
        }
        // Variables initialization
        const shapePoints = shape.extractPoints(curveSegments);
        let vertices = shapePoints.shape;
        const holes = shapePoints.holes;
        const reverse = !ShapeUtils.isClockWise(vertices);
        if (reverse) {
            vertices = vertices.reverse();
            // Maybe we should also check if holes are in the opposite direction, just to be safe ...
            for(let h = 0, hl = holes.length; h < hl; h++){
                const ahole = holes[h];
                if (ShapeUtils.isClockWise(ahole)) holes[h] = ahole.reverse();
            }
        }
        const faces = ShapeUtils.triangulateShape(vertices, holes);
        /* Vertices */ const contour1 = vertices; // vertices has all points but contour has only points of circumference
        for(let h2 = 0, hl2 = holes.length; h2 < hl2; h2++){
            const ahole = holes[h2];
            vertices = vertices.concat(ahole);
        }
        function scalePt2(pt, vec, size) {
            if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
            return vec.clone().multiplyScalar(size).add(pt);
        }
        const vlen = vertices.length, flen = faces.length;
        // Find directions for point movement
        function getBevelVec(inPt, inPrev, inNext) {
            // computes for inPt the corresponding point inPt' on a new contour
            //   shifted by 1 unit (length of normalized vector) to the left
            // if we walk along contour clockwise, this new contour is outside the old one
            //
            // inPt' is the intersection of the two lines parallel to the two
            //  adjacent edges of inPt at a distance of 1 unit on the left side.
            let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
            // good reading for geometry algorithms (here: line-line intersection)
            // http://geomalgorithms.com/a05-_intersect-1.html
            const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
            const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
            const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
            // check for collinear edges
            const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
            if (Math.abs(collinear0) > Number.EPSILON) {
                // not collinear
                // length of vectors for normalizing
                const v_prev_len = Math.sqrt(v_prev_lensq);
                const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                // shift adjacent points by unit vectors to the left
                const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                const ptNextShift_x = inNext.x - v_next_y / v_next_len;
                const ptNextShift_y = inNext.y + v_next_x / v_next_len;
                // scaling factor for v_prev to intersection point
                const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                // vector from inPt to intersection point
                v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                // Don't normalize!, otherwise sharp corners become ugly
                //  but prevent crazy spikes
                const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                if (v_trans_lensq <= 2) return new Vector2(v_trans_x, v_trans_y);
                else shrink_by = Math.sqrt(v_trans_lensq / 2);
            } else {
                // handle special case of collinear edges
                let direction_eq = false; // assumes: opposite
                if (v_prev_x > Number.EPSILON) {
                    if (v_next_x > Number.EPSILON) direction_eq = true;
                } else {
                    if (v_prev_x < -Number.EPSILON) {
                        if (v_next_x < -Number.EPSILON) direction_eq = true;
                    } else if (Math.sign(v_prev_y) === Math.sign(v_next_y)) direction_eq = true;
                }
                if (direction_eq) {
                    // console.log("Warning: lines are a straight sequence");
                    v_trans_x = -v_prev_y;
                    v_trans_y = v_prev_x;
                    shrink_by = Math.sqrt(v_prev_lensq);
                } else {
                    // console.log("Warning: lines are a straight spike");
                    v_trans_x = v_prev_x;
                    v_trans_y = v_prev_y;
                    shrink_by = Math.sqrt(v_prev_lensq / 2);
                }
            }
            return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
        }
        const contourMovements = [];
        for(let i218 = 0, il = contour1.length, j4 = il - 1, k1 = i218 + 1; i218 < il; i218++, j4++, k1++){
            if (j4 === il) j4 = 0;
            if (k1 === il) k1 = 0;
            //  (j)---(i)---(k)
            // console.log('i,j,k', i, j , k)
            contourMovements[i218] = getBevelVec(contour1[i218], contour1[j4], contour1[k1]);
        }
        const holesMovements = [];
        let oneHoleMovements, verticesMovements = contourMovements.concat();
        for(let h1 = 0, hl1 = holes.length; h1 < hl1; h1++){
            const ahole = holes[h1];
            oneHoleMovements = [];
            for(let i219 = 0, il = ahole.length, j = il - 1, k = i219 + 1; i219 < il; i219++, j++, k++){
                if (j === il) j = 0;
                if (k === il) k = 0;
                //  (j)---(i)---(k)
                oneHoleMovements[i219] = getBevelVec(ahole[i219], ahole[j], ahole[k]);
            }
            holesMovements.push(oneHoleMovements);
            verticesMovements = verticesMovements.concat(oneHoleMovements);
        }
        // Loop bevelSegments, 1 for the front, 1 for the back
        for(let b4 = 0; b4 < bevelSegments; b4++){
            //for ( b = bevelSegments; b > 0; b -- ) {
            const t = b4 / bevelSegments;
            const z = bevelThickness * Math.cos(t * Math.PI / 2);
            const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
            // contract shape
            for(let i220 = 0, il = contour1.length; i220 < il; i220++){
                const vert = scalePt2(contour1[i220], contourMovements[i220], bs);
                v(vert.x, vert.y, -z);
            }
            // expand holes
            for(let h = 0, hl = holes.length; h < hl; h++){
                const ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for(let i221 = 0, il = ahole.length; i221 < il; i221++){
                    const vert = scalePt2(ahole[i221], oneHoleMovements[i221], bs);
                    v(vert.x, vert.y, -z);
                }
            }
        }
        const bs = bevelSize + bevelOffset;
        // Back facing vertices
        for(let i216 = 0; i216 < vlen; i216++){
            const vert = bevelEnabled ? scalePt2(vertices[i216], verticesMovements[i216], bs) : vertices[i216];
            if (!extrudeByPath) v(vert.x, vert.y, 0);
            else {
                // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
                normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                position2.copy(extrudePts[0]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
            }
        }
        // Add stepped vertices...
        // Including front facing vertices
        for(let s4 = 1; s4 <= steps; s4++)for(let i217 = 0; i217 < vlen; i217++){
            const vert = bevelEnabled ? scalePt2(vertices[i217], verticesMovements[i217], bs) : vertices[i217];
            if (!extrudeByPath) v(vert.x, vert.y, depth / steps * s4);
            else {
                // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
                normal.copy(splineTube.normals[s4]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[s4]).multiplyScalar(vert.y);
                position2.copy(extrudePts[s4]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
            }
        }
        // Add bevel segments planes
        //for ( b = 1; b <= bevelSegments; b ++ ) {
        for(let b3 = bevelSegments - 1; b3 >= 0; b3--){
            const t = b3 / bevelSegments;
            const z = bevelThickness * Math.cos(t * Math.PI / 2);
            const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
            // contract shape
            for(let i222 = 0, il = contour1.length; i222 < il; i222++){
                const vert = scalePt2(contour1[i222], contourMovements[i222], bs);
                v(vert.x, vert.y, depth + z);
            }
            // expand holes
            for(let h = 0, hl = holes.length; h < hl; h++){
                const ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for(let i223 = 0, il = ahole.length; i223 < il; i223++){
                    const vert = scalePt2(ahole[i223], oneHoleMovements[i223], bs);
                    if (!extrudeByPath) v(vert.x, vert.y, depth + z);
                    else v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                }
            }
        }
        /* Faces */ // Top and bottom faces
        buildLidFaces();
        // Sides faces
        buildSideFaces();
        /////  Internal functions
        function buildLidFaces() {
            const start = verticesArray.length / 3;
            if (bevelEnabled) {
                let layer = 0; // steps + 1
                let offset = vlen * layer;
                // Bottom faces
                for(let i225 = 0; i225 < flen; i225++){
                    const face = faces[i225];
                    f3(face[2] + offset, face[1] + offset, face[0] + offset);
                }
                layer = steps + bevelSegments * 2;
                offset = vlen * layer;
                // Top faces
                for(let i224 = 0; i224 < flen; i224++){
                    const face = faces[i224];
                    f3(face[0] + offset, face[1] + offset, face[2] + offset);
                }
            } else {
                // Bottom faces
                for(let i227 = 0; i227 < flen; i227++){
                    const face = faces[i227];
                    f3(face[2], face[1], face[0]);
                }
                // Top faces
                for(let i226 = 0; i226 < flen; i226++){
                    const face = faces[i226];
                    f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                }
            }
            scope.addGroup(start, verticesArray.length / 3 - start, 0);
        }
        // Create faces for the z-sides of the shape
        function buildSideFaces() {
            const start = verticesArray.length / 3;
            let layeroffset = 0;
            sidewalls(contour1, layeroffset);
            layeroffset += contour1.length;
            for(let h = 0, hl = holes.length; h < hl; h++){
                const ahole = holes[h];
                sidewalls(ahole, layeroffset);
                //, true
                layeroffset += ahole.length;
            }
            scope.addGroup(start, verticesArray.length / 3 - start, 1);
        }
        function sidewalls(contour, layeroffset) {
            let i228 = contour.length;
            while(--i228 >= 0){
                const j = i228;
                let k = i228 - 1;
                if (k < 0) k = contour.length - 1;
                //console.log('b', i,j, i-1, k,vertices.length);
                for(let s = 0, sl = steps + bevelSegments * 2; s < sl; s++){
                    const slen1 = vlen * s;
                    const slen2 = vlen * (s + 1);
                    const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                    f4(a, b, c, d);
                }
            }
        }
        function v(x, y, z) {
            placeholder.push(x);
            placeholder.push(y);
            placeholder.push(z);
        }
        function f3(a, b, c) {
            addVertex(a);
            addVertex(b);
            addVertex(c);
            const nextIndex = verticesArray.length / 3;
            const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[2]);
        }
        function f4(a, b, c, d) {
            addVertex(a);
            addVertex(b);
            addVertex(d);
            addVertex(b);
            addVertex(c);
            addVertex(d);
            const nextIndex = verticesArray.length / 3;
            const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[3]);
            addUV(uvs[1]);
            addUV(uvs[2]);
            addUV(uvs[3]);
        }
        function addVertex(index) {
            verticesArray.push(placeholder[index * 3 + 0]);
            verticesArray.push(placeholder[index * 3 + 1]);
            verticesArray.push(placeholder[index * 3 + 2]);
        }
        function addUV(vector2) {
            uvArray.push(vector2.x);
            uvArray.push(vector2.y);
        }
    }
}
ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
ExtrudeBufferGeometry.prototype.toJSON = function() {
    const data = BufferGeometry.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON(shapes, options, data);
};
//
const WorldUVGenerator = {
    generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        return [
            new Vector2(a_x, a_y),
            new Vector2(b_x, b_y),
            new Vector2(c_x, c_y)
        ];
    },
    generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const a_z = vertices[indexA * 3 + 2];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const b_z = vertices[indexB * 3 + 2];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        const c_z = vertices[indexC * 3 + 2];
        const d_x = vertices[indexD * 3];
        const d_y = vertices[indexD * 3 + 1];
        const d_z = vertices[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < 0.01) return [
            new Vector2(a_x, 1 - a_z),
            new Vector2(b_x, 1 - b_z),
            new Vector2(c_x, 1 - c_z),
            new Vector2(d_x, 1 - d_z)
        ];
        else return [
            new Vector2(a_y, 1 - a_z),
            new Vector2(b_y, 1 - b_z),
            new Vector2(c_y, 1 - c_z),
            new Vector2(d_y, 1 - d_z)
        ];
    }
};
function toJSON(shapes, options, data) {
    //
    data.shapes = [];
    if (Array.isArray(shapes)) for(let i229 = 0, l = shapes.length; i229 < l; i229++){
        const shape = shapes[i229];
        data.shapes.push(shape.uuid);
    }
    else data.shapes.push(shapes.uuid);
    //
    if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
    return data;
}
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */ // TextGeometry
function TextGeometry(text, parameters) {
    Geometry.call(this);
    this.type = 'TextGeometry';
    this.parameters = {
        text: text,
        parameters: parameters
    };
    this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
    this.mergeVertices();
}
TextGeometry.prototype = Object.create(Geometry.prototype);
TextGeometry.prototype.constructor = TextGeometry;
// TextBufferGeometry
function TextBufferGeometry(text, parameters) {
    parameters = parameters || {};
    const font = parameters.font;
    if (!(font && font.isFont)) {
        console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
        return new Geometry();
    }
    const shapes = font.generateShapes(text, parameters.size);
    // translate parameters to ExtrudeGeometry API
    parameters.depth = parameters.height !== undefined ? parameters.height : 50;
    // defaults
    if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
    if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
    if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
    ExtrudeBufferGeometry.call(this, shapes, parameters);
    this.type = 'TextBufferGeometry';
}
TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
TextBufferGeometry.prototype.constructor = TextBufferGeometry;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 */ // SphereGeometry
function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = 'SphereGeometry';
    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
    this.mergeVertices();
}
SphereGeometry.prototype = Object.create(Geometry.prototype);
SphereGeometry.prototype.constructor = SphereGeometry;
// SphereBufferGeometry
function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = 'SphereBufferGeometry';
    this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    radius = radius || 1;
    widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
    heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
    phiStart = phiStart !== undefined ? phiStart : 0;
    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex = new Vector3();
    const normal = new Vector3();
    // buffers
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    // generate vertices, normals and uvs
    for(let iy = 0; iy <= heightSegments; iy++){
        const verticesRow = [];
        const v = iy / heightSegments;
        // special case for the poles
        let uOffset = 0;
        if (iy == 0 && thetaStart == 0) uOffset = 0.5 / widthSegments;
        else if (iy == heightSegments && thetaEnd == Math.PI) uOffset = -0.5 / widthSegments;
        for(let ix = 0; ix <= widthSegments; ix++){
            const u = ix / widthSegments;
            // vertex
            vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
            vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
            vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
            vertices.push(vertex.x, vertex.y, vertex.z);
            // normal
            normal.copy(vertex).normalize();
            normals.push(normal.x, normal.y, normal.z);
            // uv
            uvs.push(u + uOffset, 1 - v);
            verticesRow.push(index++);
        }
        grid.push(verticesRow);
    }
    // indices
    for(let iy3 = 0; iy3 < heightSegments; iy3++)for(let ix = 0; ix < widthSegments; ix++){
        const a = grid[iy3][ix + 1];
        const b = grid[iy3][ix];
        const c = grid[iy3 + 1][ix];
        const d = grid[iy3 + 1][ix + 1];
        if (iy3 !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (iy3 !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
    }
    // build geometry
    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
}
SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
/**
 * @author Kaleb Murphy
 * @author Mugen87 / https://github.com/Mugen87
 */ // RingGeometry
function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = 'RingGeometry';
    this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
    this.mergeVertices();
}
RingGeometry.prototype = Object.create(Geometry.prototype);
RingGeometry.prototype.constructor = RingGeometry;
// RingBufferGeometry
function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = 'RingBufferGeometry';
    this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    innerRadius = innerRadius || 0.5;
    outerRadius = outerRadius || 1;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
    phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;
    // buffers
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    // some helper variables
    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex = new Vector3();
    const uv = new Vector2();
    // generate vertices, normals and uvs
    for(let j = 0; j <= phiSegments; j++){
        for(let i230 = 0; i230 <= thetaSegments; i230++){
            // values are generate from the inside of the ring to the outside
            const segment = thetaStart + i230 / thetaSegments * thetaLength;
            // vertex
            vertex.x = radius * Math.cos(segment);
            vertex.y = radius * Math.sin(segment);
            vertices.push(vertex.x, vertex.y, vertex.z);
            // normal
            normals.push(0, 0, 1);
            // uv
            uv.x = (vertex.x / outerRadius + 1) / 2;
            uv.y = (vertex.y / outerRadius + 1) / 2;
            uvs.push(uv.x, uv.y);
        }
        // increase the radius for next row of vertices
        radius += radiusStep;
    }
    // indices
    for(let j5 = 0; j5 < phiSegments; j5++){
        const thetaSegmentLevel = j5 * (thetaSegments + 1);
        for(let i231 = 0; i231 < thetaSegments; i231++){
            const segment = i231 + thetaSegmentLevel;
            const a = segment;
            const b = segment + thetaSegments + 1;
            const c = segment + thetaSegments + 2;
            const d = segment + 1;
            // faces
            indices.push(a, b, d);
            indices.push(b, c, d);
        }
    }
    // build geometry
    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
}
RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
RingBufferGeometry.prototype.constructor = RingBufferGeometry;
/**
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 * @author Mugen87 / https://github.com/Mugen87
 */ // LatheGeometry
function LatheGeometry(points, segments, phiStart, phiLength) {
    Geometry.call(this);
    this.type = 'LatheGeometry';
    this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
    };
    this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
    this.mergeVertices();
}
LatheGeometry.prototype = Object.create(Geometry.prototype);
LatheGeometry.prototype.constructor = LatheGeometry;
// LatheBufferGeometry
function LatheBufferGeometry(points, segments, phiStart, phiLength) {
    BufferGeometry.call(this);
    this.type = 'LatheBufferGeometry';
    this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
    };
    segments = Math.floor(segments) || 12;
    phiStart = phiStart || 0;
    phiLength = phiLength || Math.PI * 2;
    // clamp phiLength so it's in range of [ 0, 2PI ]
    phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2);
    // buffers
    const indices = [];
    const vertices = [];
    const uvs = [];
    // helper variables
    const inverseSegments = 1 / segments;
    const vertex = new Vector3();
    const uv = new Vector2();
    // generate vertices and uvs
    for(let i233 = 0; i233 <= segments; i233++){
        const phi = phiStart + i233 * inverseSegments * phiLength;
        const sin = Math.sin(phi);
        const cos = Math.cos(phi);
        for(let j = 0; j <= points.length - 1; j++){
            // vertex
            vertex.x = points[j].x * sin;
            vertex.y = points[j].y;
            vertex.z = points[j].x * cos;
            vertices.push(vertex.x, vertex.y, vertex.z);
            // uv
            uv.x = i233 / segments;
            uv.y = j / (points.length - 1);
            uvs.push(uv.x, uv.y);
        }
    }
    // indices
    for(let i232 = 0; i232 < segments; i232++)for(let j = 0; j < points.length - 1; j++){
        const base = j + i232 * points.length;
        const a = base;
        const b = base + points.length;
        const c = base + points.length + 1;
        const d = base + 1;
        // faces
        indices.push(a, b, d);
        indices.push(b, c, d);
    }
    // build geometry
    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    // generate normals
    this.computeVertexNormals();
    // if the geometry is closed, we need to average the normals along the seam.
    // because the corresponding vertices are identical (but still have different UVs).
    if (phiLength === Math.PI * 2) {
        const normals = this.attributes.normal.array;
        const n1 = new Vector3();
        const n2 = new Vector3();
        const n = new Vector3();
        // this is the buffer offset for the last line of vertices
        const base = segments * points.length * 3;
        for(let i234 = 0, j = 0; i234 < points.length; i234++, j += 3){
            // select the normal of the vertex in the first line
            n1.x = normals[j + 0];
            n1.y = normals[j + 1];
            n1.z = normals[j + 2];
            // select the normal of the vertex in the last line
            n2.x = normals[base + j + 0];
            n2.y = normals[base + j + 1];
            n2.z = normals[base + j + 2];
            // average normals
            n.addVectors(n1, n2).normalize();
            // assign the new values to both normals
            normals[j + 0] = normals[base + j + 0] = n.x;
            normals[j + 1] = normals[base + j + 1] = n.y;
            normals[j + 2] = normals[base + j + 2] = n.z;
        }
    }
}
LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
/**
 * @author jonobr1 / http://jonobr1.com
 * @author Mugen87 / https://github.com/Mugen87
 */ // ShapeGeometry
function ShapeGeometry(shapes, curveSegments) {
    Geometry.call(this);
    this.type = 'ShapeGeometry';
    if (typeof curveSegments === 'object') {
        console.warn('THREE.ShapeGeometry: Options parameter has been removed.');
        curveSegments = curveSegments.curveSegments;
    }
    this.parameters = {
        shapes: shapes,
        curveSegments: curveSegments
    };
    this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
    this.mergeVertices();
}
ShapeGeometry.prototype = Object.create(Geometry.prototype);
ShapeGeometry.prototype.constructor = ShapeGeometry;
ShapeGeometry.prototype.toJSON = function() {
    const data = Geometry.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    return toJSON$1(shapes, data);
};
// ShapeBufferGeometry
function ShapeBufferGeometry(shapes, curveSegments) {
    BufferGeometry.call(this);
    this.type = 'ShapeBufferGeometry';
    this.parameters = {
        shapes: shapes,
        curveSegments: curveSegments
    };
    curveSegments = curveSegments || 12;
    // buffers
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    // helper variables
    let groupStart = 0;
    let groupCount = 0;
    // allow single and array values for "shapes" parameter
    if (Array.isArray(shapes) === false) addShape(shapes);
    else for(let i235 = 0; i235 < shapes.length; i235++){
        addShape(shapes[i235]);
        this.addGroup(groupStart, groupCount, i235); // enables MultiMaterial support
        groupStart += groupCount;
        groupCount = 0;
    }
    // build geometry
    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    // helper functions
    function addShape(shape) {
        const indexOffset = vertices.length / 3;
        const points = shape.extractPoints(curveSegments);
        let shapeVertices = points.shape;
        const shapeHoles = points.holes;
        // check direction of vertices
        if (ShapeUtils.isClockWise(shapeVertices) === false) shapeVertices = shapeVertices.reverse();
        for(let i239 = 0, l = shapeHoles.length; i239 < l; i239++){
            const shapeHole = shapeHoles[i239];
            if (ShapeUtils.isClockWise(shapeHole) === true) shapeHoles[i239] = shapeHole.reverse();
        }
        const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
        // join vertices of inner and outer paths to a single array
        for(let i236 = 0, l3 = shapeHoles.length; i236 < l3; i236++){
            const shapeHole = shapeHoles[i236];
            shapeVertices = shapeVertices.concat(shapeHole);
        }
        // vertices, normals, uvs
        for(let i237 = 0, l4 = shapeVertices.length; i237 < l4; i237++){
            const vertex = shapeVertices[i237];
            vertices.push(vertex.x, vertex.y, 0);
            normals.push(0, 0, 1);
            uvs.push(vertex.x, vertex.y); // world uvs
        }
        // incides
        for(let i238 = 0, l5 = faces.length; i238 < l5; i238++){
            const face = faces[i238];
            const a = face[0] + indexOffset;
            const b = face[1] + indexOffset;
            const c = face[2] + indexOffset;
            indices.push(a, b, c);
            groupCount += 3;
        }
    }
}
ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
ShapeBufferGeometry.prototype.toJSON = function() {
    const data = BufferGeometry.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    return toJSON$1(shapes, data);
};
//
function toJSON$1(shapes, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) for(let i240 = 0, l = shapes.length; i240 < l; i240++){
        const shape = shapes[i240];
        data.shapes.push(shape.uuid);
    }
    else data.shapes.push(shapes.uuid);
    return data;
}
/**
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */ function EdgesGeometry(geometry, thresholdAngle) {
    BufferGeometry.call(this);
    this.type = 'EdgesGeometry';
    this.parameters = {
        thresholdAngle: thresholdAngle
    };
    thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;
    // buffer
    const vertices = [];
    // helper variables
    const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
    const edge = [
        0,
        0
    ], edges = {};
    let edge1, edge2, key;
    const keys = [
        'a',
        'b',
        'c'
    ];
    // prepare source geometry
    let geometry2;
    if (geometry.isBufferGeometry) {
        geometry2 = new Geometry();
        geometry2.fromBufferGeometry(geometry);
    } else geometry2 = geometry.clone();
    geometry2.mergeVertices();
    geometry2.computeFaceNormals();
    const sourceVertices = geometry2.vertices;
    const faces = geometry2.faces;
    // now create a data structure where each entry represents an edge with its adjoining faces
    for(let i241 = 0, l = faces.length; i241 < l; i241++){
        const face = faces[i241];
        for(let j = 0; j < 3; j++){
            edge1 = face[keys[j]];
            edge2 = face[keys[(j + 1) % 3]];
            edge[0] = Math.min(edge1, edge2);
            edge[1] = Math.max(edge1, edge2);
            key = edge[0] + ',' + edge[1];
            if (edges[key] === undefined) edges[key] = {
                index1: edge[0],
                index2: edge[1],
                face1: i241,
                face2: undefined
            };
            else edges[key].face2 = i241;
        }
    }
    // generate vertices
    for(key in edges){
        const e = edges[key];
        // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
        if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
            let vertex = sourceVertices[e.index1];
            vertices.push(vertex.x, vertex.y, vertex.z);
            vertex = sourceVertices[e.index2];
            vertices.push(vertex.x, vertex.y, vertex.z);
        }
    }
    // build geometry
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
}
EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
EdgesGeometry.prototype.constructor = EdgesGeometry;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ // CylinderGeometry
function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = 'CylinderGeometry';
    this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
    this.mergeVertices();
}
CylinderGeometry.prototype = Object.create(Geometry.prototype);
CylinderGeometry.prototype.constructor = CylinderGeometry;
// CylinderBufferGeometry
function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = 'CylinderBufferGeometry';
    this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    const scope = this;
    radiusTop = radiusTop !== undefined ? radiusTop : 1;
    radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
    height = height || 1;
    radialSegments = Math.floor(radialSegments) || 8;
    heightSegments = Math.floor(heightSegments) || 1;
    openEnded = openEnded !== undefined ? openEnded : false;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    // buffers
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    // helper variables
    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    // generate geometry
    generateTorso();
    if (openEnded === false) {
        if (radiusTop > 0) generateCap(true);
        if (radiusBottom > 0) generateCap(false);
    }
    // build geometry
    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
        const normal = new Vector3();
        const vertex = new Vector3();
        let groupCount = 0;
        // this will be used to calculate the normal
        const slope = (radiusBottom - radiusTop) / height;
        // generate vertices, normals and uvs
        for(let y = 0; y <= heightSegments; y++){
            const indexRow = [];
            const v = y / heightSegments;
            // calculate the radius of the current row
            const radius = v * (radiusBottom - radiusTop) + radiusTop;
            for(let x = 0; x <= radialSegments; x++){
                const u = x / radialSegments;
                const theta = u * thetaLength + thetaStart;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                // vertex
                vertex.x = radius * sinTheta;
                vertex.y = -v * height + halfHeight;
                vertex.z = radius * cosTheta;
                vertices.push(vertex.x, vertex.y, vertex.z);
                // normal
                normal.set(sinTheta, slope, cosTheta).normalize();
                normals.push(normal.x, normal.y, normal.z);
                // uv
                uvs.push(u, 1 - v);
                // save index of vertex in respective row
                indexRow.push(index++);
            }
            // now save vertices of the row in our index array
            indexArray.push(indexRow);
        }
        // generate indices
        for(let x = 0; x < radialSegments; x++)for(let y3 = 0; y3 < heightSegments; y3++){
            // we use the index array to access the correct indices
            const a = indexArray[y3][x];
            const b = indexArray[y3 + 1][x];
            const c = indexArray[y3 + 1][x + 1];
            const d = indexArray[y3][x + 1];
            // faces
            indices.push(a, b, d);
            indices.push(b, c, d);
            // update group counter
            groupCount += 6;
        }
        // add a group to the geometry. this will ensure multi material support
        scope.addGroup(groupStart, groupCount, 0);
        // calculate new start value for groups
        groupStart += groupCount;
    }
    function generateCap(top) {
        let centerIndexStart, centerIndexEnd;
        const uv = new Vector2();
        const vertex = new Vector3();
        let groupCount = 0;
        const radius = top === true ? radiusTop : radiusBottom;
        const sign2 = top === true ? 1 : -1;
        // save the index of the first center vertex
        centerIndexStart = index;
        // first we generate the center vertex data of the cap.
        // because the geometry needs one set of uvs per face,
        // we must generate a center vertex per face/segment
        for(let x = 1; x <= radialSegments; x++){
            // vertex
            vertices.push(0, halfHeight * sign2, 0);
            // normal
            normals.push(0, sign2, 0);
            // uv
            uvs.push(0.5, 0.5);
            // increase index
            index++;
        }
        // save the index of the last center vertex
        centerIndexEnd = index;
        // now we generate the surrounding vertices, normals and uvs
        for(let x3 = 0; x3 <= radialSegments; x3++){
            const u = x3 / radialSegments;
            const theta = u * thetaLength + thetaStart;
            const cosTheta = Math.cos(theta);
            const sinTheta = Math.sin(theta);
            // vertex
            vertex.x = radius * sinTheta;
            vertex.y = halfHeight * sign2;
            vertex.z = radius * cosTheta;
            vertices.push(vertex.x, vertex.y, vertex.z);
            // normal
            normals.push(0, sign2, 0);
            // uv
            uv.x = cosTheta * 0.5 + 0.5;
            uv.y = sinTheta * 0.5 * sign2 + 0.5;
            uvs.push(uv.x, uv.y);
            // increase index
            index++;
        }
        // generate indices
        for(let x4 = 0; x4 < radialSegments; x4++){
            const c = centerIndexStart + x4;
            const i242 = centerIndexEnd + x4;
            if (top === true) // face top
            indices.push(i242, i242 + 1, c);
            else // face bottom
            indices.push(i242 + 1, i242, c);
            groupCount += 3;
        }
        // add a group to the geometry. this will ensure multi material support
        scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
        // calculate new start value for groups
        groupStart += groupCount;
    }
}
CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
/**
 * @author abelnation / http://github.com/abelnation
 */ // ConeGeometry
function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = 'ConeGeometry';
    this.parameters = {
        radius: radius,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
}
ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
ConeGeometry.prototype.constructor = ConeGeometry;
// ConeBufferGeometry
function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = 'ConeBufferGeometry';
    this.parameters = {
        radius: radius,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
}
ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 * @author hughes
 */ // CircleGeometry
function CircleGeometry(radius, segments, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = 'CircleGeometry';
    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
    this.mergeVertices();
}
CircleGeometry.prototype = Object.create(Geometry.prototype);
CircleGeometry.prototype.constructor = CircleGeometry;
// CircleBufferGeometry
function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = 'CircleBufferGeometry';
    this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
    };
    radius = radius || 1;
    segments = segments !== undefined ? Math.max(3, segments) : 8;
    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    // buffers
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    // helper variables
    const vertex = new Vector3();
    const uv = new Vector2();
    // center point
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for(let s = 0, i244 = 3; s <= segments; s++, i244 += 3){
        const segment = thetaStart + s / segments * thetaLength;
        // vertex
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z);
        // normal
        normals.push(0, 0, 1);
        // uvs
        uv.x = (vertices[i244] / radius + 1) / 2;
        uv.y = (vertices[i244 + 1] / radius + 1) / 2;
        uvs.push(uv.x, uv.y);
    }
    // indices
    for(let i243 = 1; i243 <= segments; i243++)indices.push(i243, i243 + 1, 0);
    // build geometry
    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
}
CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
var Geometries = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    WireframeGeometry: WireframeGeometry,
    ParametricGeometry: ParametricGeometry,
    ParametricBufferGeometry: ParametricBufferGeometry,
    TetrahedronGeometry: TetrahedronGeometry,
    TetrahedronBufferGeometry: TetrahedronBufferGeometry,
    OctahedronGeometry: OctahedronGeometry,
    OctahedronBufferGeometry: OctahedronBufferGeometry,
    IcosahedronGeometry: IcosahedronGeometry,
    IcosahedronBufferGeometry: IcosahedronBufferGeometry,
    DodecahedronGeometry: DodecahedronGeometry,
    DodecahedronBufferGeometry: DodecahedronBufferGeometry,
    PolyhedronGeometry: PolyhedronGeometry,
    PolyhedronBufferGeometry: PolyhedronBufferGeometry,
    TubeGeometry: TubeGeometry,
    TubeBufferGeometry: TubeBufferGeometry,
    TorusKnotGeometry: TorusKnotGeometry,
    TorusKnotBufferGeometry: TorusKnotBufferGeometry,
    TorusGeometry: TorusGeometry,
    TorusBufferGeometry: TorusBufferGeometry,
    TextGeometry: TextGeometry,
    TextBufferGeometry: TextBufferGeometry,
    SphereGeometry: SphereGeometry,
    SphereBufferGeometry: SphereBufferGeometry,
    RingGeometry: RingGeometry,
    RingBufferGeometry: RingBufferGeometry,
    PlaneGeometry: PlaneGeometry,
    PlaneBufferGeometry: PlaneBufferGeometry,
    LatheGeometry: LatheGeometry,
    LatheBufferGeometry: LatheBufferGeometry,
    ShapeGeometry: ShapeGeometry,
    ShapeBufferGeometry: ShapeBufferGeometry,
    ExtrudeGeometry: ExtrudeGeometry,
    ExtrudeBufferGeometry: ExtrudeBufferGeometry,
    EdgesGeometry: EdgesGeometry,
    ConeGeometry: ConeGeometry,
    ConeBufferGeometry: ConeBufferGeometry,
    CylinderGeometry: CylinderGeometry,
    CylinderBufferGeometry: CylinderBufferGeometry,
    CircleGeometry: CircleGeometry,
    CircleBufferGeometry: CircleBufferGeometry,
    BoxGeometry: BoxGeometry,
    BoxBufferGeometry: BoxBufferGeometry
});
/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  color: <THREE.Color>
 * }
 */ function ShadowMaterial(parameters) {
    Material.call(this);
    this.type = 'ShadowMaterial';
    this.color = new Color(0);
    this.transparent = true;
    this.setValues(parameters);
}
ShadowMaterial.prototype = Object.create(Material.prototype);
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;
ShadowMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ function RawShaderMaterial(parameters) {
    ShaderMaterial.call(this, parameters);
    this.type = 'RawShaderMaterial';
}
RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshStandardMaterial(parameters) {
    Material.call(this);
    this.defines = {
        'STANDARD': ''
    };
    this.type = 'MeshStandardMaterial';
    this.color = new Color(16777215); // diffuse
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.vertexTangents = false;
    this.setValues(parameters);
}
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.defines = {
        'STANDARD': ''
    };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.vertexTangents = source.vertexTangents;
    return this;
};
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *
 *  sheen: <Color>,
 *
 *  transparency: <float>
 * }
 */ function MeshPhysicalMaterial(parameters) {
    MeshStandardMaterial.call(this);
    this.defines = {
        'STANDARD': '',
        'PHYSICAL': ''
    };
    this.type = 'MeshPhysicalMaterial';
    this.clearcoat = 0;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.reflectivity = 0.5; // maps to F0 = 0.04
    this.sheen = null; // null will disable sheen bsdf
    this.transparency = 0;
    this.setValues(parameters);
}
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function(source) {
    MeshStandardMaterial.prototype.copy.call(this, source);
    this.defines = {
        'STANDARD': '',
        'PHYSICAL': ''
    };
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.reflectivity = source.reflectivity;
    if (source.sheen) this.sheen = (this.sheen || new Color()).copy(source.sheen);
    else this.sheen = null;
    this.transparency = source.transparency;
    return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshPhongMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshPhongMaterial';
    this.color = new Color(16777215); // diffuse
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
}
MeshPhongMaterial.prototype = Object.create(Material.prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
MeshPhongMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * @author takahirox / http://github.com/takahirox
 *
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshToonMaterial(parameters) {
    Material.call(this);
    this.defines = {
        'TOON': ''
    };
    this.type = 'MeshToonMaterial';
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
}
MeshToonMaterial.prototype = Object.create(Material.prototype);
MeshToonMaterial.prototype.constructor = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;
MeshToonMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshNormalMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshNormalMaterial';
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
}
MeshNormalMaterial.prototype = Object.create(Material.prototype);
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
MeshNormalMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshLambertMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshLambertMaterial';
    this.color = new Color(16777215); // diffuse
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
}
MeshLambertMaterial.prototype = Object.create(Material.prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
MeshLambertMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshMatcapMaterial(parameters) {
    Material.call(this);
    this.defines = {
        'MATCAP': ''
    };
    this.type = 'MeshMatcapMaterial';
    this.color = new Color(16777215); // diffuse
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
}
MeshMatcapMaterial.prototype = Object.create(Material.prototype);
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
MeshMatcapMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.defines = {
        'MATCAP': ''
    };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */ function LineDashedMaterial(parameters) {
    LineBasicMaterial.call(this);
    this.type = 'LineDashedMaterial';
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
}
LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;
LineDashedMaterial.prototype.copy = function(source) {
    LineBasicMaterial.prototype.copy.call(this, source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
};
var Materials = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ShadowMaterial: ShadowMaterial,
    SpriteMaterial: SpriteMaterial,
    RawShaderMaterial: RawShaderMaterial,
    ShaderMaterial: ShaderMaterial,
    PointsMaterial: PointsMaterial,
    MeshPhysicalMaterial: MeshPhysicalMaterial,
    MeshStandardMaterial: MeshStandardMaterial,
    MeshPhongMaterial: MeshPhongMaterial,
    MeshToonMaterial: MeshToonMaterial,
    MeshNormalMaterial: MeshNormalMaterial,
    MeshLambertMaterial: MeshLambertMaterial,
    MeshDepthMaterial: MeshDepthMaterial,
    MeshDistanceMaterial: MeshDistanceMaterial,
    MeshBasicMaterial: MeshBasicMaterial,
    MeshMatcapMaterial: MeshMatcapMaterial,
    LineDashedMaterial: LineDashedMaterial,
    LineBasicMaterial: LineBasicMaterial,
    Material: Material
});
/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */ const AnimationUtils = {
    // same as Array.prototype.slice, but also works on typed arrays
    arraySlice: function(array, from, to) {
        if (AnimationUtils.isTypedArray(array)) // in ios9 array.subarray(from, undefined) will return empty array
        // but array.subarray(from) or array.subarray(from, len) is correct
        return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
        return array.slice(from, to);
    },
    // converts an array to a specific type
    convertArray: function(array, type, forceClone) {
        if (!array || !forceClone && array.constructor === type) return array;
        if (typeof type.BYTES_PER_ELEMENT === 'number') return new type(array); // create typed array
        return Array.prototype.slice.call(array); // create Array
    },
    isTypedArray: function(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    // returns an array by which times and values can be sorted
    getKeyframeOrder: function(times) {
        function compareTime(i246, j) {
            return times[i246] - times[j];
        }
        const n = times.length;
        const result = new Array(n);
        for(let i245 = 0; i245 !== n; ++i245)result[i245] = i245;
        result.sort(compareTime);
        return result;
    },
    // uses the array previously returned by 'getKeyframeOrder' to sort data
    sortedArray: function(values, stride, order) {
        const nValues = values.length;
        const result = new values.constructor(nValues);
        for(let i247 = 0, dstOffset = 0; dstOffset !== nValues; ++i247){
            const srcOffset = order[i247] * stride;
            for(let j = 0; j !== stride; ++j)result[dstOffset++] = values[srcOffset + j];
        }
        return result;
    },
    // function for parsing AOS keyframe formats
    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
        let i248 = 1, key = jsonKeys[0];
        while(key !== undefined && key[valuePropertyName] === undefined)key = jsonKeys[i248++];
        if (key === undefined) return; // no data
        let value = key[valuePropertyName];
        if (value === undefined) return; // no data
        if (Array.isArray(value)) do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                values.push.apply(values, value); // push all elements
            }
            key = jsonKeys[i248++];
        }while (key !== undefined)
        else if (value.toArray !== undefined) // ...assume THREE.Math-ish
        do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                value.toArray(values, values.length);
            }
            key = jsonKeys[i248++];
        }while (key !== undefined)
        else // otherwise push as-is
        do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                values.push(value);
            }
            key = jsonKeys[i248++];
        }while (key !== undefined)
    },
    subclip: function(sourceClip, name, startFrame, endFrame, fps) {
        fps = fps || 30;
        const clip = sourceClip.clone();
        clip.name = name;
        const tracks = [];
        for(let i251 = 0; i251 < clip.tracks.length; ++i251){
            const track = clip.tracks[i251];
            const valueSize = track.getValueSize();
            const times = [];
            const values = [];
            for(let j = 0; j < track.times.length; ++j){
                const frame = track.times[j] * fps;
                if (frame < startFrame || frame >= endFrame) continue;
                times.push(track.times[j]);
                for(let k = 0; k < valueSize; ++k)values.push(track.values[j * valueSize + k]);
            }
            if (times.length === 0) continue;
            track.times = AnimationUtils.convertArray(times, track.times.constructor);
            track.values = AnimationUtils.convertArray(values, track.values.constructor);
            tracks.push(track);
        }
        clip.tracks = tracks;
        // find minimum .times value across all tracks in the trimmed clip
        let minStartTime = Infinity;
        for(let i249 = 0; i249 < clip.tracks.length; ++i249)if (minStartTime > clip.tracks[i249].times[0]) minStartTime = clip.tracks[i249].times[0];
        // shift all tracks such that clip begins at t=0
        for(let i250 = 0; i250 < clip.tracks.length; ++i250)clip.tracks[i250].shift(-1 * minStartTime);
        clip.resetDuration();
        return clip;
    },
    makeClipAdditive: function(targetClip, referenceFrame, referenceClip, fps) {
        if (referenceFrame === undefined) referenceFrame = 0;
        if (referenceClip === undefined) referenceClip = targetClip;
        if (fps === undefined || fps <= 0) fps = 30;
        const numTracks = targetClip.tracks.length;
        const referenceTime = referenceFrame / fps;
        // Make each track's values relative to the values at the reference frame
        for(let i252 = 0; i252 < numTracks; ++i252){
            const referenceTrack = referenceClip.tracks[i252];
            const referenceTrackType = referenceTrack.ValueTypeName;
            // Skip this track if it's non-numeric
            if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue;
            // Find the track in the target clip whose name and type matches the reference track
            const targetTrack = targetClip.tracks.find(function(track) {
                return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
            });
            if (targetTrack === undefined) continue;
            const valueSize = referenceTrack.getValueSize();
            const lastIndex = referenceTrack.times.length - 1;
            let referenceValue;
            // Find the value to subtract out of the track
            if (referenceTime <= referenceTrack.times[0]) // Reference frame is earlier than the first keyframe, so just use the first keyframe
            referenceValue = AnimationUtils.arraySlice(referenceTrack.values, 0, referenceTrack.valueSize);
            else if (referenceTime >= referenceTrack.times[lastIndex]) {
                // Reference frame is after the last keyframe, so just use the last keyframe
                const startIndex = lastIndex * valueSize;
                referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex);
            } else {
                // Interpolate to the reference value
                const interpolant = referenceTrack.createInterpolant();
                interpolant.evaluate(referenceTime);
                referenceValue = interpolant.resultBuffer;
            }
            // Conjugate the quaternion
            if (referenceTrackType === 'quaternion') {
                const referenceQuat = new Quaternion(referenceValue[0], referenceValue[1], referenceValue[2], referenceValue[3]).normalize().conjugate();
                referenceQuat.toArray(referenceValue);
            }
            // Subtract the reference value from all of the track values
            const numTimes = targetTrack.times.length;
            for(let j = 0; j < numTimes; ++j){
                const valueStart = j * valueSize;
                if (referenceTrackType === 'quaternion') // Multiply the conjugate for quaternion track types
                Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
                else // Subtract each value for all other numeric track types
                for(let k = 0; k < valueSize; ++k)targetTrack.values[valueStart + k] -= referenceValue[k];
            }
        }
        targetClip.blendMode = AdditiveAnimationBlendMode;
        return targetClip;
    }
};
/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */ function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
}
Object.assign(Interpolant.prototype, {
    evaluate: function(t) {
        let pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
        validate_interval: {
            seek: {
                let right;
                linear_scan: {
                    //- See http://jsperf.com/comparison-to-undefined/3
                    //- slower code:
                    //-
                    //- 				if ( t >= t1 || t1 === undefined ) {
                    forward_scan: if (!(t < t1)) {
                        for(let giveUpAt = i1 + 2;;){
                            if (t1 === undefined) {
                                if (t < t0) break forward_scan;
                                // after end
                                i1 = pp.length;
                                this._cachedIndex = i1;
                                return this.afterEnd_(i1 - 1, t, t0);
                            }
                            if (i1 === giveUpAt) break; // this loop
                            t0 = t1;
                            t1 = pp[++i1];
                            if (t < t1) break seek;
                        }
                        // prepare binary search on the right side of the index
                        right = pp.length;
                        break linear_scan;
                    }
                    //- slower code:
                    //-					if ( t < t0 || t0 === undefined ) {
                    if (!(t >= t0)) {
                        // looping?
                        const t1global = pp[1];
                        if (t < t1global) {
                            i1 = 2; // + 1, using the scan for the details
                            t0 = t1global;
                        }
                        // linear reverse scan
                        for(let giveUpAt = i1 - 2;;){
                            if (t0 === undefined) {
                                // before start
                                this._cachedIndex = 0;
                                return this.beforeStart_(0, t, t1);
                            }
                            if (i1 === giveUpAt) break; // this loop
                            t1 = t0;
                            t0 = pp[--i1 - 1];
                            if (t >= t0) break seek;
                        }
                        // prepare binary search on the left side of the index
                        right = i1;
                        i1 = 0;
                        break linear_scan;
                    }
                    break validate_interval;
                } // linear scan
                // binary search
                while(i1 < right){
                    const mid = i1 + right >>> 1;
                    if (t < pp[mid]) right = mid;
                    else i1 = mid + 1;
                }
                t1 = pp[i1];
                t0 = pp[i1 - 1];
                // check boundary cases, again
                if (t0 === undefined) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t, t1);
                }
                if (t1 === undefined) {
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.afterEnd_(i1 - 1, t0, t);
                }
            } // seek
            this._cachedIndex = i1;
            this.intervalChanged_(i1, t0, t1);
        } // validate_interval
        return this.interpolate_(i1, t0, t, t1);
    },
    settings: null,
    // Note: The indirection allows central control of many interpolants.
    // --- Protected interface
    DefaultSettings_: {},
    getSettings_: function() {
        return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function(index) {
        // copies a sample value to the result buffer
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
        for(let i253 = 0; i253 !== stride; ++i253)result[i253] = values[offset + i253];
        return result;
    },
    // Template methods for derived classes:
    interpolate_: function() {
        throw new Error('call to abstract method');
    // implementations shall return this.resultBuffer
    },
    intervalChanged_: function() {
    // empty
    }
});
// DECLARE ALIAS AFTER assign prototype
Object.assign(Interpolant.prototype, {
    //( 0, t, t0 ), returns this.resultBuffer
    beforeStart_: Interpolant.prototype.copySampleValue_,
    //( N-1, tN-1, t ), returns this.resultBuffer
    afterEnd_: Interpolant.prototype.copySampleValue_
});
/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */ function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
}
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: CubicInterpolant,
    DefaultSettings_: {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
    },
    intervalChanged_: function(i1, t0, t1) {
        let pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === undefined) switch(this.getSettings_().endingStart){
            case ZeroSlopeEnding:
                // f'(t0) = 0
                iPrev = i1;
                tPrev = 2 * t0 - t1;
                break;
            case WrapAroundEnding:
                // use the other end of the curve
                iPrev = pp.length - 2;
                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;
            default:
                // f''(t0) = 0 a.k.a. Natural Spline
                iPrev = i1;
                tPrev = t1;
        }
        if (tNext === undefined) switch(this.getSettings_().endingEnd){
            case ZeroSlopeEnding:
                // f'(tN) = 0
                iNext = i1;
                tNext = 2 * t1 - t0;
                break;
            case WrapAroundEnding:
                // use the other end of the curve
                iNext = 1;
                tNext = t1 + pp[1] - pp[0];
                break;
            default:
                // f''(tN) = 0, a.k.a. Natural Spline
                iNext = i1 - 1;
                tNext = t0;
        }
        const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
    },
    interpolate_: function(i1, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
        // evaluate polynomials
        const sP = -wP * ppp + 2 * wP * pp - wP * p;
        const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
        const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
        const sN = wN * ppp - wN * pp;
        // combine data linearly
        for(let i254 = 0; i254 !== stride; ++i254)result[i254] = sP * values[oP + i254] + s0 * values[o0 + i254] + s1 * values[o1 + i254] + sN * values[oN + i254];
        return result;
    }
});
/**
 * @author tschw
 */ function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: LinearInterpolant,
    interpolate_: function(i1, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
        for(let i255 = 0; i255 !== stride; ++i255)result[i255] = values[offset0 + i255] * weight0 + values[offset1 + i255] * weight1;
        return result;
    }
});
/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */ function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: DiscreteInterpolant,
    interpolate_: function(i1 /*, t0, t, t1 */ ) {
        return this.copySampleValue_(i1 - 1);
    }
});
/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function KeyframeTrack(name, times, values, interpolation) {
    if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
    if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
}
// Static methods
Object.assign(KeyframeTrack, {
    // Serialization (in static context, because of constructor invocation
    // and automatic invocation of .toJSON):
    toJSON: function(track) {
        const trackType = track.constructor;
        let json;
        // derived classes can define a static toJSON method
        if (trackType.toJSON !== undefined) json = trackType.toJSON(track);
        else {
            // by default, we assume the data can be serialized as-is
            json = {
                'name': track.name,
                'times': AnimationUtils.convertArray(track.times, Array),
                'values': AnimationUtils.convertArray(track.values, Array)
            };
            const interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) json.interpolation = interpolation;
        }
        json.type = track.ValueTypeName; // mandatory
        return json;
    }
});
Object.assign(KeyframeTrack.prototype, {
    constructor: KeyframeTrack,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodDiscrete: function(result) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodLinear: function(result) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: function(result) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    setInterpolation: function(interpolation) {
        let factoryMethod;
        switch(interpolation){
            case InterpolateDiscrete:
                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                break;
            case InterpolateLinear:
                factoryMethod = this.InterpolantFactoryMethodLinear;
                break;
            case InterpolateSmooth:
                factoryMethod = this.InterpolantFactoryMethodSmooth;
                break;
        }
        if (factoryMethod === undefined) {
            const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === undefined) {
                // fall back to default, unless the default itself is messed up
                if (interpolation !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(message); // fatal, in this case
            }
            console.warn('THREE.KeyframeTrack:', message);
            return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
    },
    getInterpolation: function() {
        switch(this.createInterpolant){
            case this.InterpolantFactoryMethodDiscrete:
                return InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
                return InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
                return InterpolateSmooth;
        }
    },
    getValueSize: function() {
        return this.values.length / this.times.length;
    },
    // move all keyframes either forwards or backwards in time
    shift: function(timeOffset) {
        if (timeOffset !== 0) {
            const times = this.times;
            for(let i256 = 0, n = times.length; i256 !== n; ++i256)times[i256] += timeOffset;
        }
        return this;
    },
    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    scale: function(timeScale) {
        if (timeScale !== 1) {
            const times = this.times;
            for(let i257 = 0, n = times.length; i257 !== n; ++i257)times[i257] *= timeScale;
        }
        return this;
    },
    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    trim: function(startTime, endTime) {
        const times = this.times, nKeys = times.length;
        let from = 0, to = nKeys - 1;
        while(from !== nKeys && times[from] < startTime)++from;
        while(to !== -1 && times[to] > endTime)--to;
        ++to; // inclusive -> exclusive bound
        if (from !== 0 || to !== nKeys) {
            // empty tracks are forbidden, so keep at least one keyframe
            if (from >= to) {
                to = Math.max(to, 1);
                from = to - 1;
            }
            const stride = this.getValueSize();
            this.times = AnimationUtils.arraySlice(times, from, to);
            this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
        }
        return this;
    },
    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    validate: function() {
        let valid = true;
        const valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
            console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
            valid = false;
        }
        const times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
            console.error('THREE.KeyframeTrack: Track is empty.', this);
            valid = false;
        }
        let prevTime = null;
        for(let i258 = 0; i258 !== nKeys; i258++){
            const currTime = times[i258];
            if (typeof currTime === 'number' && isNaN(currTime)) {
                console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i258, currTime);
                valid = false;
                break;
            }
            if (prevTime !== null && prevTime > currTime) {
                console.error('THREE.KeyframeTrack: Out of order keys.', this, i258, currTime, prevTime);
                valid = false;
                break;
            }
            prevTime = currTime;
        }
        if (values !== undefined) {
            if (AnimationUtils.isTypedArray(values)) for(let i259 = 0, n = values.length; i259 !== n; ++i259){
                const value = values[i259];
                if (isNaN(value)) {
                    console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i259, value);
                    valid = false;
                    break;
                }
            }
        }
        return valid;
    },
    // removes equivalent sequential keys as common in morph target sequences
    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    optimize: function() {
        // times or values may be shared with other tracks, so overwriting is unsafe
        const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
        let writeIndex = 1;
        for(let i260 = 1; i260 < lastIndex; ++i260){
            let keep = false;
            const time = times[i260];
            const timeNext = times[i260 + 1];
            // remove adjacent keyframes scheduled at the same time
            if (time !== timeNext && (i260 !== 1 || time !== time[0])) {
                if (!smoothInterpolation) {
                    // remove unnecessary keyframes same as their neighbors
                    const offset = i260 * stride, offsetP = offset - stride, offsetN = offset + stride;
                    for(let j = 0; j !== stride; ++j){
                        const value = values[offset + j];
                        if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                            keep = true;
                            break;
                        }
                    }
                } else keep = true;
            }
            // in-place compaction
            if (keep) {
                if (i260 !== writeIndex) {
                    times[writeIndex] = times[i260];
                    const readOffset = i260 * stride, writeOffset = writeIndex * stride;
                    for(let j = 0; j !== stride; ++j)values[writeOffset + j] = values[readOffset + j];
                }
                ++writeIndex;
            }
        }
        // flush last keyframe (compaction looks ahead)
        if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for(let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j)values[writeOffset + j] = values[readOffset + j];
            ++writeIndex;
        }
        if (writeIndex !== times.length) {
            this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
        } else {
            this.times = times;
            this.values = values;
        }
        return this;
    },
    clone: function() {
        const times = AnimationUtils.arraySlice(this.times, 0);
        const values = AnimationUtils.arraySlice(this.values, 0);
        const TypedKeyframeTrack = this.constructor;
        const track = new TypedKeyframeTrack(this.name, times, values);
        // Interpolant argument to constructor is not saved, so copy the factory method directly.
        track.createInterpolant = this.createInterpolant;
        return track;
    }
});
/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function BooleanKeyframeTrack(name, times, values) {
    KeyframeTrack.call(this, name, times, values);
}
BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: BooleanKeyframeTrack,
    ValueTypeName: 'bool',
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function ColorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: ColorKeyframeTrack,
    ValueTypeName: 'color'
});
/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function NumberKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: NumberKeyframeTrack,
    ValueTypeName: 'number'
});
/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */ function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: QuaternionLinearInterpolant,
    interpolate_: function(i1, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
        let offset = i1 * stride;
        for(let end = offset + stride; offset !== end; offset += 4)Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        return result;
    }
});
/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function QuaternionKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: QuaternionKeyframeTrack,
    ValueTypeName: 'quaternion',
    // ValueBufferType is inherited
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodLinear: function(result) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: undefined // not yet implemented
});
/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function StringKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: StringKeyframeTrack,
    ValueTypeName: 'string',
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function VectorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: VectorKeyframeTrack,
    ValueTypeName: 'vector'
});
/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */ function AnimationClip(name, duration, tracks, blendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration !== undefined ? duration : -1;
    this.blendMode = blendMode !== undefined ? blendMode : NormalAnimationBlendMode;
    this.uuid = MathUtils.generateUUID();
    // this means it should figure out its duration by scanning the tracks
    if (this.duration < 0) this.resetDuration();
}
function getTrackTypeForValueTypeName(typeName) {
    switch(typeName.toLowerCase()){
        case 'scalar':
        case 'double':
        case 'float':
        case 'number':
        case 'integer':
            return NumberKeyframeTrack;
        case 'vector':
        case 'vector2':
        case 'vector3':
        case 'vector4':
            return VectorKeyframeTrack;
        case 'color':
            return ColorKeyframeTrack;
        case 'quaternion':
            return QuaternionKeyframeTrack;
        case 'bool':
        case 'boolean':
            return BooleanKeyframeTrack;
        case 'string':
            return StringKeyframeTrack;
    }
    throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
}
function parseKeyframeTrack(json) {
    if (json.type === undefined) throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
    const trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === undefined) {
        const times = [], values = [];
        AnimationUtils.flattenJSON(json.keys, times, values, 'value');
        json.times = times;
        json.values = values;
    }
    // derived classes can define a static parse method
    if (trackType.parse !== undefined) return trackType.parse(json);
    else // by default, we assume a constructor compatible with the base
    return new trackType(json.name, json.times, json.values, json.interpolation);
}
Object.assign(AnimationClip, {
    parse: function(json) {
        const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
        for(let i261 = 0, n = jsonTracks.length; i261 !== n; ++i261)tracks.push(parseKeyframeTrack(jsonTracks[i261]).scale(frameTime));
        return new AnimationClip(json.name, json.duration, tracks, json.blendMode);
    },
    toJSON: function(clip) {
        const tracks = [], clipTracks = clip.tracks;
        const json = {
            'name': clip.name,
            'duration': clip.duration,
            'tracks': tracks,
            'uuid': clip.uuid,
            'blendMode': clip.blendMode
        };
        for(let i262 = 0, n = clipTracks.length; i262 !== n; ++i262)tracks.push(KeyframeTrack.toJSON(clipTracks[i262]));
        return json;
    },
    CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
        const numMorphTargets = morphTargetSequence.length;
        const tracks = [];
        for(let i263 = 0; i263 < numMorphTargets; i263++){
            let times = [];
            let values = [];
            times.push((i263 + numMorphTargets - 1) % numMorphTargets, i263, (i263 + 1) % numMorphTargets);
            values.push(0, 1, 0);
            const order = AnimationUtils.getKeyframeOrder(times);
            times = AnimationUtils.sortedArray(times, 1, order);
            values = AnimationUtils.sortedArray(values, 1, order);
            // if there is a key at the first frame, duplicate it as the
            // last frame as well for perfect loop.
            if (!noLoop && times[0] === 0) {
                times.push(numMorphTargets);
                values.push(values[0]);
            }
            tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i263].name + ']', times, values).scale(1 / fps));
        }
        return new AnimationClip(name, -1, tracks);
    },
    findByName: function(objectOrClipArray, name) {
        let clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
            const o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for(let i264 = 0; i264 < clipArray.length; i264++){
            if (clipArray[i264].name === name) return clipArray[i264];
        }
        return null;
    },
    CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
        const animationToMorphTargets = {};
        // tested with https://regex101.com/ on trick sequences
        // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
        const pattern = /^([\w-]*?)([\d]+)$/;
        // sort morph target names into animation groups based
        // patterns like Walk_001, Walk_002, Run_001, Run_002
        for(let i265 = 0, il = morphTargets.length; i265 < il; i265++){
            const morphTarget = morphTargets[i265];
            const parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
                const name = parts[1];
                let animationMorphTargets = animationToMorphTargets[name];
                if (!animationMorphTargets) animationToMorphTargets[name] = animationMorphTargets = [];
                animationMorphTargets.push(morphTarget);
            }
        }
        const clips = [];
        for(const name in animationToMorphTargets)clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
        return clips;
    },
    // parse the animation.hierarchy format
    parseAnimation: function(animation, bones) {
        if (!animation) {
            console.error('THREE.AnimationClip: No animation in JSONLoader data.');
            return null;
        }
        const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            // only return track if there are actually keys.
            if (animationKeys.length !== 0) {
                const times = [];
                const values = [];
                AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
                // empty keys are filtered out, so check again
                if (times.length !== 0) destTracks.push(new trackType(trackName, times, values));
            }
        };
        const tracks = [];
        const clipName = animation.name || 'default';
        const fps = animation.fps || 30;
        const blendMode = animation.blendMode;
        // automatic length determination in AnimationClip.
        let duration = animation.length || -1;
        const hierarchyTracks = animation.hierarchy || [];
        for(let h = 0; h < hierarchyTracks.length; h++){
            const animationKeys = hierarchyTracks[h].keys;
            // skip empty tracks
            if (!animationKeys || animationKeys.length === 0) continue;
            // process morph targets
            if (animationKeys[0].morphTargets) {
                // figure out all morph targets used in this track
                const morphTargetNames = {};
                let k;
                for(k = 0; k < animationKeys.length; k++){
                    if (animationKeys[k].morphTargets) for(let m = 0; m < animationKeys[k].morphTargets.length; m++)morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                }
                // create a track for each morph target with all zero
                // morphTargetInfluences except for the keys in which
                // the morphTarget is named.
                for(const morphTargetName in morphTargetNames){
                    const times = [];
                    const values = [];
                    for(let m = 0; m !== animationKeys[k].morphTargets.length; ++m){
                        const animationKey = animationKeys[k];
                        times.push(animationKey.time);
                        values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                    }
                    tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                }
                duration = morphTargetNames.length * (fps || 1);
            } else {
                // ...assume skeletal animation
                const boneName = '.bones[' + bones[h].name + ']';
                addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
                addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
                addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
            }
        }
        if (tracks.length === 0) return null;
        const clip = new AnimationClip(clipName, duration, tracks, blendMode);
        return clip;
    }
});
Object.assign(AnimationClip.prototype, {
    resetDuration: function() {
        const tracks = this.tracks;
        let duration = 0;
        for(let i266 = 0, n = tracks.length; i266 !== n; ++i266){
            const track = this.tracks[i266];
            duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
        return this;
    },
    trim: function() {
        for(let i267 = 0; i267 < this.tracks.length; i267++)this.tracks[i267].trim(0, this.duration);
        return this;
    },
    validate: function() {
        let valid = true;
        for(let i268 = 0; i268 < this.tracks.length; i268++)valid = valid && this.tracks[i268].validate();
        return valid;
    },
    optimize: function() {
        for(let i269 = 0; i269 < this.tracks.length; i269++)this.tracks[i269].optimize();
        return this;
    },
    clone: function() {
        const tracks = [];
        for(let i270 = 0; i270 < this.tracks.length; i270++)tracks.push(this.tracks[i270].clone());
        return new AnimationClip(this.name, this.duration, tracks, this.blendMode);
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ const Cache = {
    enabled: false,
    files: {},
    add: function(key, file) {
        if (this.enabled === false) return;
        // console.log( 'THREE.Cache', 'Adding key:', key );
        this.files[key] = file;
    },
    get: function(key) {
        if (this.enabled === false) return;
        // console.log( 'THREE.Cache', 'Checking key:', key );
        return this.files[key];
    },
    remove: function(key) {
        delete this.files[key];
    },
    clear: function() {
        this.files = {};
    }
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ function LoadingManager(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = undefined;
    const handlers = [];
    // Refer to #5689 for the reason why we don't set .onStart
    // in the constructor
    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
        itemsTotal++;
        if (isLoading === false) {
            if (scope.onStart !== undefined) scope.onStart(url, itemsLoaded, itemsTotal);
        }
        isLoading = true;
    };
    this.itemEnd = function(url) {
        itemsLoaded++;
        if (scope.onProgress !== undefined) scope.onProgress(url, itemsLoaded, itemsTotal);
        if (itemsLoaded === itemsTotal) {
            isLoading = false;
            if (scope.onLoad !== undefined) scope.onLoad();
        }
    };
    this.itemError = function(url) {
        if (scope.onError !== undefined) scope.onError(url);
    };
    this.resolveURL = function(url) {
        if (urlModifier) return urlModifier(url);
        return url;
    };
    this.setURLModifier = function(transform) {
        urlModifier = transform;
        return this;
    };
    this.addHandler = function(regex, loader) {
        handlers.push(regex, loader);
        return this;
    };
    this.removeHandler = function(regex) {
        const index = handlers.indexOf(regex);
        if (index !== -1) handlers.splice(index, 2);
        return this;
    };
    this.getHandler = function(file) {
        for(let i271 = 0, l = handlers.length; i271 < l; i271 += 2){
            const regex = handlers[i271];
            const loader = handlers[i271 + 1];
            if (regex.global) regex.lastIndex = 0; // see #17920
            if (regex.test(file)) return loader;
        }
        return null;
    };
}
const DefaultLoadingManager = new LoadingManager();
/**
 * @author alteredq / http://alteredqualia.com/
 */ function Loader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    this.crossOrigin = 'anonymous';
    this.path = '';
    this.resourcePath = '';
    this.requestHeader = {};
}
Object.assign(Loader.prototype, {
    load: function() {},
    loadAsync: function(url, onProgress) {
        const scope = this;
        return new Promise(function(resolve, reject) {
            scope.load(url, resolve, onProgress, reject);
        });
    },
    parse: function() {},
    setCrossOrigin: function(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
    },
    setPath: function(path) {
        this.path = path;
        return this;
    },
    setResourcePath: function(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
    },
    setRequestHeader: function(requestHeader) {
        this.requestHeader = requestHeader;
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ const loading = {};
function FileLoader(manager) {
    Loader.call(this, manager);
}
FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: FileLoader,
    load: function(url, onLoad, onProgress, onError) {
        if (url === undefined) url = '';
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        // Check if request is duplicate
        if (loading[url] !== undefined) {
            loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            return;
        }
        // Check for data: URI
        const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
        const dataUriRegexResult = url.match(dataUriRegex);
        let request;
        // Safari can not handle Data URIs through XMLHttpRequest so process manually
        if (dataUriRegexResult) {
            const mimeType = dataUriRegexResult[1];
            const isBase64 = !!dataUriRegexResult[2];
            let data = dataUriRegexResult[3];
            data = decodeURIComponent(data);
            if (isBase64) data = atob(data);
            try {
                let response;
                const responseType = (this.responseType || '').toLowerCase();
                switch(responseType){
                    case 'arraybuffer':
                    case 'blob':
                        const view = new Uint8Array(data.length);
                        for(let i272 = 0; i272 < data.length; i272++)view[i272] = data.charCodeAt(i272);
                        if (responseType === 'blob') response = new Blob([
                            view.buffer
                        ], {
                            type: mimeType
                        });
                        else response = view.buffer;
                        break;
                    case 'document':
                        const parser = new DOMParser();
                        response = parser.parseFromString(data, mimeType);
                        break;
                    case 'json':
                        response = JSON.parse(data);
                        break;
                    default:
                        response = data;
                        break;
                }
                // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                setTimeout(function() {
                    if (onLoad) onLoad(response);
                    scope.manager.itemEnd(url);
                }, 0);
            } catch (error) {
                // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                setTimeout(function() {
                    if (onError) onError(error);
                    scope.manager.itemError(url);
                    scope.manager.itemEnd(url);
                }, 0);
            }
        } else {
            // Initialise array for duplicate requests
            loading[url] = [];
            loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            request = new XMLHttpRequest();
            request.open('GET', url, true);
            request.addEventListener('load', function(event) {
                const response = this.response;
                const callbacks = loading[url];
                delete loading[url];
                if (this.status === 200 || this.status === 0) {
                    // Some browsers return HTTP Status 0 when using non-http protocol
                    // e.g. 'file://' or 'data://'. Handle as success.
                    if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.');
                    // Add to cache only on HTTP success, so that we do not cache
                    // error response bodies as proper responses to requests.
                    Cache.add(url, response);
                    for(let i273 = 0, il = callbacks.length; i273 < il; i273++){
                        const callback = callbacks[i273];
                        if (callback.onLoad) callback.onLoad(response);
                    }
                    scope.manager.itemEnd(url);
                } else {
                    for(let i274 = 0, il = callbacks.length; i274 < il; i274++){
                        const callback = callbacks[i274];
                        if (callback.onError) callback.onError(event);
                    }
                    scope.manager.itemError(url);
                    scope.manager.itemEnd(url);
                }
            }, false);
            request.addEventListener('progress', function(event) {
                const callbacks = loading[url];
                for(let i275 = 0, il = callbacks.length; i275 < il; i275++){
                    const callback = callbacks[i275];
                    if (callback.onProgress) callback.onProgress(event);
                }
            }, false);
            request.addEventListener('error', function(event) {
                const callbacks = loading[url];
                delete loading[url];
                for(let i276 = 0, il = callbacks.length; i276 < il; i276++){
                    const callback = callbacks[i276];
                    if (callback.onError) callback.onError(event);
                }
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            }, false);
            request.addEventListener('abort', function(event) {
                const callbacks = loading[url];
                delete loading[url];
                for(let i277 = 0, il = callbacks.length; i277 < il; i277++){
                    const callback = callbacks[i277];
                    if (callback.onError) callback.onError(event);
                }
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            }, false);
            if (this.responseType !== undefined) request.responseType = this.responseType;
            if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
            if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');
            for(const header in this.requestHeader)request.setRequestHeader(header, this.requestHeader[header]);
            request.send(null);
        }
        scope.manager.itemStart(url);
        return request;
    },
    setResponseType: function(value) {
        this.responseType = value;
        return this;
    },
    setWithCredentials: function(value) {
        this.withCredentials = value;
        return this;
    },
    setMimeType: function(value) {
        this.mimeType = value;
        return this;
    }
});
/**
 * @author bhouston / http://clara.io/
 */ function AnimationLoader(manager) {
    Loader.call(this, manager);
}
AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: AnimationLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    },
    parse: function(json) {
        const animations = [];
        for(let i278 = 0; i278 < json.length; i278++){
            const clip = AnimationClip.parse(json[i278]);
            animations.push(clip);
        }
        return animations;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */ function CompressedTextureLoader(manager) {
    Loader.call(this, manager);
}
CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: CompressedTextureLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const images = [];
        const texture = new CompressedTexture();
        texture.image = images;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setResponseType('arraybuffer');
        let loaded = 0;
        function loadTexture(i280) {
            loader.load(url[i280], function(buffer) {
                const texDatas = scope.parse(buffer, true);
                images[i280] = {
                    width: texDatas.width,
                    height: texDatas.height,
                    format: texDatas.format,
                    mipmaps: texDatas.mipmaps
                };
                loaded += 1;
                if (loaded === 6) {
                    if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, onProgress, onError);
        }
        if (Array.isArray(url)) for(let i279 = 0, il = url.length; i279 < il; ++i279)loadTexture(i279);
        else // compressed cubemap texture stored in a single DDS file
        loader.load(url, function(buffer) {
            const texDatas = scope.parse(buffer, true);
            if (texDatas.isCubemap) {
                const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                for(let f = 0; f < faces; f++){
                    images[f] = {
                        mipmaps: []
                    };
                    for(let i281 = 0; i281 < texDatas.mipmapCount; i281++){
                        images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i281]);
                        images[f].format = texDatas.format;
                        images[f].width = texDatas.width;
                        images[f].height = texDatas.height;
                    }
                }
            } else {
                texture.image.width = texDatas.width;
                texture.image.height = texDatas.height;
                texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
        }, onProgress, onError);
        return texture;
    }
});
/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */ function DataTextureLoader(manager) {
    Loader.call(this, manager);
}
DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: DataTextureLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const texture = new DataTexture();
        const loader = new FileLoader(this.manager);
        loader.setResponseType('arraybuffer');
        loader.setPath(this.path);
        loader.load(url, function(buffer) {
            const texData = scope.parse(buffer);
            if (!texData) return;
            if (texData.image !== undefined) texture.image = texData.image;
            else if (texData.data !== undefined) {
                texture.image.width = texData.width;
                texture.image.height = texData.height;
                texture.image.data = texData.data;
            }
            texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
            texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
            texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
            texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
            texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
            if (texData.format !== undefined) texture.format = texData.format;
            if (texData.type !== undefined) texture.type = texData.type;
            if (texData.mipmaps !== undefined) {
                texture.mipmaps = texData.mipmaps;
                texture.minFilter = LinearMipmapLinearFilter; // presumably...
            }
            if (texData.mipmapCount === 1) texture.minFilter = LinearFilter;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function ImageLoader(manager) {
    Loader.call(this, manager);
}
ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: ImageLoader,
    load: function(url, onLoad, onProgress, onError) {
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
        function onImageLoad() {
            image.removeEventListener('load', onImageLoad, false);
            image.removeEventListener('error', onImageError, false);
            Cache.add(url, this);
            if (onLoad) onLoad(this);
            scope.manager.itemEnd(url);
        }
        function onImageError(event) {
            image.removeEventListener('load', onImageLoad, false);
            image.removeEventListener('error', onImageError, false);
            if (onError) onError(event);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
        }
        image.addEventListener('load', onImageLoad, false);
        image.addEventListener('error', onImageError, false);
        if (url.substr(0, 5) !== 'data:') {
            if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
        }
        scope.manager.itemStart(url);
        image.src = url;
        return image;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function CubeTextureLoader(manager) {
    Loader.call(this, manager);
}
CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: CubeTextureLoader,
    load: function(urls, onLoad, onProgress, onError) {
        const texture = new CubeTexture();
        const loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        let loaded = 0;
        function loadTexture(i283) {
            loader.load(urls[i283], function(image) {
                texture.images[i283] = image;
                loaded++;
                if (loaded === 6) {
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, undefined, onError);
        }
        for(let i282 = 0; i282 < urls.length; ++i282)loadTexture(i282);
        return texture;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function TextureLoader(manager) {
    Loader.call(this, manager);
}
TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: TextureLoader,
    load: function(url, onLoad, onProgress, onError) {
        const texture = new Texture();
        const loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        loader.load(url, function(image) {
            texture.image = image;
            // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
            const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
            texture.format = isJPEG ? RGBFormat : RGBAFormat;
            texture.needsUpdate = true;
            if (onLoad !== undefined) onLoad(texture);
        }, onProgress, onError);
        return texture;
    }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/ /**************************************************************
 *	Abstract Curve base class
 **************************************************************/ function Curve() {
    this.type = 'Curve';
    this.arcLengthDivisions = 200;
}
Object.assign(Curve.prototype, {
    // Virtual base class method to overwrite and implement in subclasses
    //	- t [0 .. 1]
    getPoint: function() {
        console.warn('THREE.Curve: .getPoint() not implemented.');
        return null;
    },
    // Get point at relative position in curve according to arc length
    // - u [0 .. 1]
    getPointAt: function(u, optionalTarget) {
        const t = this.getUtoTmapping(u);
        return this.getPoint(t, optionalTarget);
    },
    // Get sequence of points using getPoint( t )
    getPoints: function(divisions) {
        if (divisions === undefined) divisions = 5;
        const points = [];
        for(let d = 0; d <= divisions; d++)points.push(this.getPoint(d / divisions));
        return points;
    },
    // Get sequence of points using getPointAt( u )
    getSpacedPoints: function(divisions) {
        if (divisions === undefined) divisions = 5;
        const points = [];
        for(let d = 0; d <= divisions; d++)points.push(this.getPointAt(d / divisions));
        return points;
    },
    // Get total curve arc length
    getLength: function() {
        const lengths = this.getLengths();
        return lengths[lengths.length - 1];
    },
    // Get list of cumulative segment lengths
    getLengths: function(divisions) {
        if (divisions === undefined) divisions = this.arcLengthDivisions;
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = false;
        const cache = [];
        let current, last = this.getPoint(0);
        let sum = 0;
        cache.push(0);
        for(let p = 1; p <= divisions; p++){
            current = this.getPoint(p / divisions);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
        }
        this.cacheArcLengths = cache;
        return cache; // { sums: cache, sum: sum }; Sum is in the last element.
    },
    updateArcLengths: function() {
        this.needsUpdate = true;
        this.getLengths();
    },
    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
    getUtoTmapping: function(u, distance) {
        const arcLengths = this.getLengths();
        let i284 = 0, il = arcLengths.length;
        let targetArcLength; // The targeted u distance value to get
        if (distance) targetArcLength = distance;
        else targetArcLength = u * arcLengths[il - 1];
        // binary search for the index with largest value smaller than target u distance
        let low = 0, high = il - 1, comparison;
        while(low <= high){
            i284 = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
            comparison = arcLengths[i284] - targetArcLength;
            if (comparison < 0) low = i284 + 1;
            else if (comparison > 0) high = i284 - 1;
            else {
                high = i284;
                break;
            // DONE
            }
        }
        i284 = high;
        if (arcLengths[i284] === targetArcLength) return i284 / (il - 1);
        // we could get finer grain at lengths, or use simple interpolation between two points
        const lengthBefore = arcLengths[i284];
        const lengthAfter = arcLengths[i284 + 1];
        const segmentLength = lengthAfter - lengthBefore;
        // determine where we are between the 'before' and 'after' points
        const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        // add that fractional amount to t
        const t = (i284 + segmentFraction) / (il - 1);
        return t;
    },
    // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation
    getTangent: function(t, optionalTarget) {
        const delta = 0.0001;
        let t1 = t - delta;
        let t2 = t + delta;
        // Capping in case of danger
        if (t1 < 0) t1 = 0;
        if (t2 > 1) t2 = 1;
        const pt1 = this.getPoint(t1);
        const pt2 = this.getPoint(t2);
        const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
        tangent.copy(pt2).sub(pt1).normalize();
        return tangent;
    },
    getTangentAt: function(u, optionalTarget) {
        const t = this.getUtoTmapping(u);
        return this.getTangent(t, optionalTarget);
    },
    computeFrenetFrames: function(segments, closed) {
        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
        const normal = new Vector3();
        const tangents = [];
        const normals = [];
        const binormals = [];
        const vec = new Vector3();
        const mat = new Matrix4();
        // compute the tangent vectors for each segment on the curve
        for(let i286 = 0; i286 <= segments; i286++){
            const u = i286 / segments;
            tangents[i286] = this.getTangentAt(u, new Vector3());
            tangents[i286].normalize();
        }
        // select an initial normal vector perpendicular to the first tangent vector,
        // and in the direction of the minimum tangent xyz component
        normals[0] = new Vector3();
        binormals[0] = new Vector3();
        let min = Number.MAX_VALUE;
        const tx = Math.abs(tangents[0].x);
        const ty = Math.abs(tangents[0].y);
        const tz = Math.abs(tangents[0].z);
        if (tx <= min) {
            min = tx;
            normal.set(1, 0, 0);
        }
        if (ty <= min) {
            min = ty;
            normal.set(0, 1, 0);
        }
        if (tz <= min) normal.set(0, 0, 1);
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
        // compute the slowly-varying normal and binormal vectors for each segment on the curve
        for(let i285 = 1; i285 <= segments; i285++){
            normals[i285] = normals[i285 - 1].clone();
            binormals[i285] = binormals[i285 - 1].clone();
            vec.crossVectors(tangents[i285 - 1], tangents[i285]);
            if (vec.length() > Number.EPSILON) {
                vec.normalize();
                const theta = Math.acos(MathUtils.clamp(tangents[i285 - 1].dot(tangents[i285]), -1, 1)); // clamp for floating pt errors
                normals[i285].applyMatrix4(mat.makeRotationAxis(vec, theta));
            }
            binormals[i285].crossVectors(tangents[i285], normals[i285]);
        }
        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
        if (closed === true) {
            let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
            theta /= segments;
            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) theta = -theta;
            for(let i287 = 1; i287 <= segments; i287++){
                // twist a little...
                normals[i287].applyMatrix4(mat.makeRotationAxis(tangents[i287], theta * i287));
                binormals[i287].crossVectors(tangents[i287], normals[i287]);
            }
        }
        return {
            tangents: tangents,
            normals: normals,
            binormals: binormals
        };
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
    },
    toJSON: function() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'Curve',
                generator: 'Curve.toJSON'
            }
        };
        data.arcLengthDivisions = this.arcLengthDivisions;
        data.type = this.type;
        return data;
    },
    fromJSON: function(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
    }
});
function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    Curve.call(this);
    this.type = 'EllipseCurve';
    this.aX = aX || 0;
    this.aY = aY || 0;
    this.xRadius = xRadius || 1;
    this.yRadius = yRadius || 1;
    this.aStartAngle = aStartAngle || 0;
    this.aEndAngle = aEndAngle || 2 * Math.PI;
    this.aClockwise = aClockwise || false;
    this.aRotation = aRotation || 0;
}
EllipseCurve.prototype = Object.create(Curve.prototype);
EllipseCurve.prototype.constructor = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;
EllipseCurve.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    // ensures that deltaAngle is 0 .. 2 PI
    while(deltaAngle < 0)deltaAngle += twoPi;
    while(deltaAngle > twoPi)deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
        if (samePoints) deltaAngle = 0;
        else deltaAngle = twoPi;
    }
    if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) deltaAngle = -twoPi;
        else deltaAngle = deltaAngle - twoPi;
    }
    const angle = this.aStartAngle + t * deltaAngle;
    let x = this.aX + this.xRadius * Math.cos(angle);
    let y = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
        const cos = Math.cos(this.aRotation);
        const sin = Math.sin(this.aRotation);
        const tx = x - this.aX;
        const ty = y - this.aY;
        // Rotate the point about the center of the ellipse.
        x = tx * cos - ty * sin + this.aX;
        y = tx * sin + ty * cos + this.aY;
    }
    return point.set(x, y);
};
EllipseCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
};
EllipseCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
};
EllipseCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
};
function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = 'ArcCurve';
}
ArcCurve.prototype = Object.create(EllipseCurve.prototype);
ArcCurve.prototype.constructor = ArcCurve;
ArcCurve.prototype.isArcCurve = true;
/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */ /*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/ function CubicPoly() {
    let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
    /*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */ function init(x0, x1, t0, t1) {
        c0 = x0;
        c1 = t0;
        c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
        c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }
    return {
        initCatmullRom: function(x0, x1, x2, x3, tension) {
            init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
        },
        initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
            // compute tangents when parameterized in [t1,t2]
            let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
            let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
            // rescale tangents for parametrization in [0,1]
            t1 *= dt1;
            t2 *= dt1;
            init(x1, x2, t1, t2);
        },
        calc: function(t) {
            const t2 = t * t;
            const t3 = t2 * t;
            return c0 + c1 * t + c2 * t2 + c3 * t3;
        }
    };
}
//
const tmp = new Vector3();
const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
function CatmullRomCurve3(points, closed, curveType, tension) {
    Curve.call(this);
    this.type = 'CatmullRomCurve3';
    this.points = points || [];
    this.closed = closed || false;
    this.curveType = curveType || 'centripetal';
    this.tension = tension || 0.5;
}
CatmullRomCurve3.prototype = Object.create(Curve.prototype);
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
CatmullRomCurve3.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector3();
    const points = this.points;
    const l = points.length;
    const p = (l - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p);
    let weight = p - intPoint;
    if (this.closed) intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    else if (weight === 0 && intPoint === l - 1) {
        intPoint = l - 2;
        weight = 1;
    }
    let p0, p1, p2, p3; // 4 points
    if (this.closed || intPoint > 0) p0 = points[(intPoint - 1) % l];
    else {
        // extrapolate first point
        tmp.subVectors(points[0], points[1]).add(points[0]);
        p0 = tmp;
    }
    p1 = points[intPoint % l];
    p2 = points[(intPoint + 1) % l];
    if (this.closed || intPoint + 2 < l) p3 = points[(intPoint + 2) % l];
    else {
        // extrapolate last point
        tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
        p3 = tmp;
    }
    if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
        // init Centripetal / Chordal Catmull-Rom
        const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
        let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
        let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
        let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
        // safety check for repeated points
        if (dt1 < 0.0001) dt1 = 1;
        if (dt0 < 0.0001) dt0 = dt1;
        if (dt2 < 0.0001) dt2 = dt1;
        px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
        py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
        pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === 'catmullrom') {
        px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
        pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
};
CatmullRomCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.points = [];
    for(let i288 = 0, l = source.points.length; i288 < l; i288++){
        const point = source.points[i288];
        this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
};
CatmullRomCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.points = [];
    for(let i289 = 0, l = this.points.length; i289 < l; i289++){
        const point = this.points[i289];
        data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
};
CatmullRomCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.points = [];
    for(let i290 = 0, l = json.points.length; i290 < l; i290++){
        const point = json.points[i290];
        this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
};
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/BÃ©zier_curve
 */ function CatmullRom(t, p0, p1, p2, p3) {
    const v0 = (p2 - p0) * 0.5;
    const v1 = (p3 - p1) * 0.5;
    const t2 = t * t;
    const t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
//
function QuadraticBezierP0(t, p) {
    const k = 1 - t;
    return k * k * p;
}
function QuadraticBezierP1(t, p) {
    return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
    return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
    return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}
//
function CubicBezierP0(t, p) {
    const k = 1 - t;
    return k * k * k * p;
}
function CubicBezierP1(t, p) {
    const k = 1 - t;
    return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
    return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
    return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
    return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}
function CubicBezierCurve(v0, v1, v2, v3) {
    Curve.call(this);
    this.type = 'CubicBezierCurve';
    this.v0 = v0 || new Vector2();
    this.v1 = v1 || new Vector2();
    this.v2 = v2 || new Vector2();
    this.v3 = v3 || new Vector2();
}
CubicBezierCurve.prototype = Object.create(Curve.prototype);
CubicBezierCurve.prototype.constructor = CubicBezierCurve;
CubicBezierCurve.prototype.isCubicBezierCurve = true;
CubicBezierCurve.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
    return point;
};
CubicBezierCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
};
CubicBezierCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
};
CubicBezierCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
};
function CubicBezierCurve3(v0, v1, v2, v3) {
    Curve.call(this);
    this.type = 'CubicBezierCurve3';
    this.v0 = v0 || new Vector3();
    this.v1 = v1 || new Vector3();
    this.v2 = v2 || new Vector3();
    this.v3 = v3 || new Vector3();
}
CubicBezierCurve3.prototype = Object.create(Curve.prototype);
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
CubicBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector3();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
    return point;
};
CubicBezierCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
};
CubicBezierCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
};
CubicBezierCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
};
function LineCurve(v1, v2) {
    Curve.call(this);
    this.type = 'LineCurve';
    this.v1 = v1 || new Vector2();
    this.v2 = v2 || new Vector2();
}
LineCurve.prototype = Object.create(Curve.prototype);
LineCurve.prototype.constructor = LineCurve;
LineCurve.prototype.isLineCurve = true;
LineCurve.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector2();
    if (t === 1) point.copy(this.v2);
    else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
    }
    return point;
};
// Line curve is linear, so we can overwrite default getPointAt
LineCurve.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
};
LineCurve.prototype.getTangent = function(t, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
};
LineCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
LineCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
LineCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function LineCurve3(v1, v2) {
    Curve.call(this);
    this.type = 'LineCurve3';
    this.v1 = v1 || new Vector3();
    this.v2 = v2 || new Vector3();
}
LineCurve3.prototype = Object.create(Curve.prototype);
LineCurve3.prototype.constructor = LineCurve3;
LineCurve3.prototype.isLineCurve3 = true;
LineCurve3.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector3();
    if (t === 1) point.copy(this.v2);
    else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t).add(this.v1);
    }
    return point;
};
// Line curve is linear, so we can overwrite default getPointAt
LineCurve3.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
};
LineCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
LineCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
LineCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function QuadraticBezierCurve(v0, v1, v2) {
    Curve.call(this);
    this.type = 'QuadraticBezierCurve';
    this.v0 = v0 || new Vector2();
    this.v1 = v1 || new Vector2();
    this.v2 = v2 || new Vector2();
}
QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
QuadraticBezierCurve.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
    return point;
};
QuadraticBezierCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
QuadraticBezierCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
QuadraticBezierCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function QuadraticBezierCurve3(v0, v1, v2) {
    Curve.call(this);
    this.type = 'QuadraticBezierCurve3';
    this.v0 = v0 || new Vector3();
    this.v1 = v1 || new Vector3();
    this.v2 = v2 || new Vector3();
}
QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
QuadraticBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector3();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
    return point;
};
QuadraticBezierCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
QuadraticBezierCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
QuadraticBezierCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function SplineCurve(points /* array of Vector2 */ ) {
    Curve.call(this);
    this.type = 'SplineCurve';
    this.points = points || [];
}
SplineCurve.prototype = Object.create(Curve.prototype);
SplineCurve.prototype.constructor = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;
SplineCurve.prototype.getPoint = function(t, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const points = this.points;
    const p = (points.length - 1) * t;
    const intPoint = Math.floor(p);
    const weight = p - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
    return point;
};
SplineCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.points = [];
    for(let i291 = 0, l = source.points.length; i291 < l; i291++){
        const point = source.points[i291];
        this.points.push(point.clone());
    }
    return this;
};
SplineCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.points = [];
    for(let i292 = 0, l = this.points.length; i292 < l; i292++){
        const point = this.points[i292];
        data.points.push(point.toArray());
    }
    return data;
};
SplineCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.points = [];
    for(let i293 = 0, l = json.points.length; i293 < l; i293++){
        const point = json.points[i293];
        this.points.push(new Vector2().fromArray(point));
    }
    return this;
};
var Curves = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ArcCurve: ArcCurve,
    CatmullRomCurve3: CatmullRomCurve3,
    CubicBezierCurve: CubicBezierCurve,
    CubicBezierCurve3: CubicBezierCurve3,
    EllipseCurve: EllipseCurve,
    LineCurve: LineCurve,
    LineCurve3: LineCurve3,
    QuadraticBezierCurve: QuadraticBezierCurve,
    QuadraticBezierCurve3: QuadraticBezierCurve3,
    SplineCurve: SplineCurve
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/ /**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/ function CurvePath() {
    Curve.call(this);
    this.type = 'CurvePath';
    this.curves = [];
    this.autoClose = false; // Automatically closes the path
}
CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
    constructor: CurvePath,
    add: function(curve) {
        this.curves.push(curve);
    },
    closePath: function() {
        // Add a line curve if start and end of lines are not connected
        const startPoint = this.curves[0].getPoint(0);
        const endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) this.curves.push(new LineCurve(endPoint, startPoint));
    },
    // To get accurate point with reference to
    // entire path distance at time t,
    // following has to be done:
    // 1. Length of each sub path have to be known
    // 2. Locate and identify type of curve
    // 3. Get t for the curve
    // 4. Return curve.getPointAt(t')
    getPoint: function(t) {
        const d = t * this.getLength();
        const curveLengths = this.getCurveLengths();
        let i294 = 0;
        // To think about boundaries points.
        while(i294 < curveLengths.length){
            if (curveLengths[i294] >= d) {
                const diff = curveLengths[i294] - d;
                const curve = this.curves[i294];
                const segmentLength = curve.getLength();
                const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                return curve.getPointAt(u);
            }
            i294++;
        }
        return null;
    // loop where sum != 0, sum > d , sum+1 <d
    },
    // We cannot use the default THREE.Curve getPoint() with getLength() because in
    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    // getPoint() depends on getLength
    getLength: function() {
        const lens = this.getCurveLengths();
        return lens[lens.length - 1];
    },
    // cacheLengths must be recalculated.
    updateArcLengths: function() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
    },
    // Compute lengths and cache them
    // We cannot overwrite getLengths() because UtoT mapping uses it.
    getCurveLengths: function() {
        // We use cache values if curves and cache array are same length
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        // Get length of sub-curve
        // Push sums into cached array
        const lengths = [];
        let sums = 0;
        for(let i295 = 0, l = this.curves.length; i295 < l; i295++){
            sums += this.curves[i295].getLength();
            lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
    },
    getSpacedPoints: function(divisions) {
        if (divisions === undefined) divisions = 40;
        const points = [];
        for(let i296 = 0; i296 <= divisions; i296++)points.push(this.getPoint(i296 / divisions));
        if (this.autoClose) points.push(points[0]);
        return points;
    },
    getPoints: function(divisions) {
        divisions = divisions || 12;
        const points = [];
        let last;
        for(let i297 = 0, curves = this.curves; i297 < curves.length; i297++){
            const curve = curves[i297];
            const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
            const pts = curve.getPoints(resolution);
            for(let j = 0; j < pts.length; j++){
                const point = pts[j];
                if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates
                points.push(point);
                last = point;
            }
        }
        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) points.push(points[0]);
        return points;
    },
    copy: function(source) {
        Curve.prototype.copy.call(this, source);
        this.curves = [];
        for(let i298 = 0, l = source.curves.length; i298 < l; i298++){
            const curve = source.curves[i298];
            this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
    },
    toJSON: function() {
        const data = Curve.prototype.toJSON.call(this);
        data.autoClose = this.autoClose;
        data.curves = [];
        for(let i299 = 0, l = this.curves.length; i299 < l; i299++){
            const curve = this.curves[i299];
            data.curves.push(curve.toJSON());
        }
        return data;
    },
    fromJSON: function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for(let i300 = 0, l = json.curves.length; i300 < l; i300++){
            const curve = json.curves[i300];
            this.curves.push(new Curves[curve.type]().fromJSON(curve));
        }
        return this;
    }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 **/ function Path(points) {
    CurvePath.call(this);
    this.type = 'Path';
    this.currentPoint = new Vector2();
    if (points) this.setFromPoints(points);
}
Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
    constructor: Path,
    setFromPoints: function(points) {
        this.moveTo(points[0].x, points[0].y);
        for(let i301 = 1, l = points.length; i301 < l; i301++)this.lineTo(points[i301].x, points[i301].y);
        return this;
    },
    moveTo: function(x, y) {
        this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
        return this;
    },
    lineTo: function(x, y) {
        const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
        this.curves.push(curve);
        this.currentPoint.set(x, y);
        return this;
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    },
    splineThru: function(pts /*Array of Vector*/ ) {
        const npts = [
            this.currentPoint.clone()
        ].concat(pts);
        const curve = new SplineCurve(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
        return this;
    },
    arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    },
    absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    },
    ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        return this;
    },
    absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
            // if a previous curve is present, attempt to join
            const firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) this.lineTo(firstPoint.x, firstPoint.y);
        }
        this.curves.push(curve);
        const lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
        return this;
    },
    copy: function(source) {
        CurvePath.prototype.copy.call(this, source);
        this.currentPoint.copy(source.currentPoint);
        return this;
    },
    toJSON: function() {
        const data = CurvePath.prototype.toJSON.call(this);
        data.currentPoint = this.currentPoint.toArray();
        return data;
    },
    fromJSON: function(json) {
        CurvePath.prototype.fromJSON.call(this, json);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
    }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/ // STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.
function Shape(points) {
    Path.call(this, points);
    this.uuid = MathUtils.generateUUID();
    this.type = 'Shape';
    this.holes = [];
}
Shape.prototype = Object.assign(Object.create(Path.prototype), {
    constructor: Shape,
    getPointsHoles: function(divisions) {
        const holesPts = [];
        for(let i302 = 0, l = this.holes.length; i302 < l; i302++)holesPts[i302] = this.holes[i302].getPoints(divisions);
        return holesPts;
    },
    // get points of shape and holes (keypoints based on segments parameter)
    extractPoints: function(divisions) {
        return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
        };
    },
    copy: function(source) {
        Path.prototype.copy.call(this, source);
        this.holes = [];
        for(let i303 = 0, l = source.holes.length; i303 < l; i303++){
            const hole = source.holes[i303];
            this.holes.push(hole.clone());
        }
        return this;
    },
    toJSON: function() {
        const data = Path.prototype.toJSON.call(this);
        data.uuid = this.uuid;
        data.holes = [];
        for(let i304 = 0, l = this.holes.length; i304 < l; i304++){
            const hole = this.holes[i304];
            data.holes.push(hole.toJSON());
        }
        return data;
    },
    fromJSON: function(json) {
        Path.prototype.fromJSON.call(this, json);
        this.uuid = json.uuid;
        this.holes = [];
        for(let i305 = 0, l = json.holes.length; i305 < l; i305++){
            const hole = json.holes[i305];
            this.holes.push(new Path().fromJSON(hole));
        }
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */ function Light(color, intensity) {
    Object3D.call(this);
    this.type = 'Light';
    this.color = new Color(color);
    this.intensity = intensity !== undefined ? intensity : 1;
    this.receiveShadow = undefined;
}
Light.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Light,
    isLight: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
    },
    toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== undefined) data.object.distance = this.distance;
        if (this.angle !== undefined) data.object.angle = this.angle;
        if (this.decay !== undefined) data.object.decay = this.decay;
        if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
        if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
        return data;
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */ function HemisphereLight(skyColor, groundColor, intensity) {
    Light.call(this, skyColor, intensity);
    this.type = 'HemisphereLight';
    this.castShadow = undefined;
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
}
HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: HemisphereLight,
    isHemisphereLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.groundColor.copy(source.groundColor);
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function LightShadow(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
        new Vector4(0, 0, 1, 1)
    ];
}
Object.assign(LightShadow.prototype, {
    _projScreenMatrix: new Matrix4(),
    _lightPositionWorld: new Vector3(),
    _lookTarget: new Vector3(),
    getViewportCount: function() {
        return this._viewportCount;
    },
    getFrustum: function() {
        return this._frustum;
    },
    updateMatrices: function(light) {
        const shadowCamera = this.camera, shadowMatrix = this.matrix, projScreenMatrix = this._projScreenMatrix, lookTarget = this._lookTarget, lightPositionWorld = this._lightPositionWorld;
        lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy(lightPositionWorld);
        lookTarget.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(lookTarget);
        shadowCamera.updateMatrixWorld();
        projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(projScreenMatrix);
        shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
    },
    getViewport: function(viewportIndex) {
        return this._viewports[viewportIndex];
    },
    getFrameExtents: function() {
        return this._frameExtents;
    },
    copy: function(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    toJSON: function() {
        const object = {};
        if (this.bias !== 0) object.bias = this.bias;
        if (this.normalBias !== 0) object.normalBias = this.normalBias;
        if (this.radius !== 1) object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function SpotLightShadow() {
    LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
}
SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: SpotLightShadow,
    isSpotLightShadow: true,
    updateMatrices: function(light) {
        const camera = this.camera;
        const fov2 = MathUtils.RAD2DEG * 2 * light.angle;
        const aspect2 = this.mapSize.width / this.mapSize.height;
        const far = light.distance || camera.far;
        if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
            camera.fov = fov2;
            camera.aspect = aspect2;
            camera.far = far;
            camera.updateProjectionMatrix();
        }
        LightShadow.prototype.updateMatrices.call(this, light);
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */ function SpotLight(color, intensity, distance, angle, penumbra, decay) {
    Light.call(this, color, intensity);
    this.type = 'SpotLight';
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    Object.defineProperty(this, 'power', {
        get: function() {
            // intensity = power per solid angle.
            // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            return this.intensity * Math.PI;
        },
        set: function(power) {
            // intensity = power per solid angle.
            // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            this.intensity = power / Math.PI;
        }
    });
    this.distance = distance !== undefined ? distance : 0;
    this.angle = angle !== undefined ? angle : Math.PI / 3;
    this.penumbra = penumbra !== undefined ? penumbra : 0;
    this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.
    this.shadow = new SpotLightShadow();
}
SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: SpotLight,
    isSpotLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
});
function PointLightShadow() {
    LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
        // These viewports map a cube-map onto a 2D texture with the
        // following orientation:
        //
        //  xzXZ
        //   y Y
        //
        // X - Positive x direction
        // x - Negative x direction
        // Y - Positive y direction
        // y - Negative y direction
        // Z - Positive z direction
        // z - Negative z direction
        // positive X
        new Vector4(2, 1, 1, 1),
        // negative X
        new Vector4(0, 1, 1, 1),
        // positive Z
        new Vector4(3, 1, 1, 1),
        // negative Z
        new Vector4(1, 1, 1, 1),
        // positive Y
        new Vector4(3, 0, 1, 1),
        // negative Y
        new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
        new Vector3(1, 0, 0),
        new Vector3(-1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
        new Vector3(0, 1, 0),
        new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1)
    ];
}
PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: PointLightShadow,
    isPointLightShadow: true,
    updateMatrices: function(light, viewportIndex) {
        if (viewportIndex === undefined) viewportIndex = 0;
        const camera = this.camera, shadowMatrix = this.matrix, lightPositionWorld = this._lightPositionWorld, lookTarget = this._lookTarget, projScreenMatrix = this._projScreenMatrix;
        lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        camera.position.copy(lightPositionWorld);
        lookTarget.copy(camera.position);
        lookTarget.add(this._cubeDirections[viewportIndex]);
        camera.up.copy(this._cubeUps[viewportIndex]);
        camera.lookAt(lookTarget);
        camera.updateMatrixWorld();
        shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
        projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(projScreenMatrix);
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function PointLight(color, intensity, distance, decay) {
    Light.call(this, color, intensity);
    this.type = 'PointLight';
    Object.defineProperty(this, 'power', {
        get: function() {
            // intensity = power per solid angle.
            // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            return this.intensity * 4 * Math.PI;
        },
        set: function(power) {
            // intensity = power per solid angle.
            // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            this.intensity = power / (4 * Math.PI);
        }
    });
    this.distance = distance !== undefined ? distance : 0;
    this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.
    this.shadow = new PointLightShadow();
}
PointLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: PointLight,
    isPointLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */ function OrthographicCamera(left, right, top, bottom, near, far) {
    Camera.call(this);
    this.type = 'OrthographicCamera';
    this.zoom = 1;
    this.view = null;
    this.left = left !== undefined ? left : -1;
    this.right = right !== undefined ? right : 1;
    this.top = top !== undefined ? top : 1;
    this.bottom = bottom !== undefined ? bottom : -1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.updateProjectionMatrix();
}
OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
    constructor: OrthographicCamera,
    isOrthographicCamera: true,
    copy: function(source, recursive) {
        Camera.prototype.copy.call(this, source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        return this;
    },
    setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
        const dx = (this.right - this.left) / (2 * this.zoom);
        const dy = (this.top - this.bottom) / (2 * this.zoom);
        const cx = (this.right + this.left) / 2;
        const cy = (this.top + this.bottom) / 2;
        let left = cx - dx;
        let right = cx + dx;
        let top = cy + dy;
        let bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left += scaleW * this.view.offsetX;
            right = left + scaleW * this.view.width;
            top -= scaleH * this.view.offsetY;
            bottom = top - scaleH * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null) data.object.view = Object.assign({}, this.view);
        return data;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function DirectionalLightShadow() {
    LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
}
DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: DirectionalLightShadow,
    isDirectionalLightShadow: true,
    updateMatrices: function(light) {
        LightShadow.prototype.updateMatrices.call(this, light);
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */ function DirectionalLight(color, intensity) {
    Light.call(this, color, intensity);
    this.type = 'DirectionalLight';
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
}
DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: DirectionalLight,
    isDirectionalLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function AmbientLight(color, intensity) {
    Light.call(this, color, intensity);
    this.type = 'AmbientLight';
    this.castShadow = undefined;
}
AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: AmbientLight,
    isAmbientLight: true
});
/**
 * @author abelnation / http://github.com/abelnation
 */ function RectAreaLight(color, intensity, width, height) {
    Light.call(this, color, intensity);
    this.type = 'RectAreaLight';
    this.width = width !== undefined ? width : 10;
    this.height = height !== undefined ? height : 10;
}
RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: RectAreaLight,
    isRectAreaLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.width = source.width;
        this.height = source.height;
        return this;
    },
    toJSON: function(meta) {
        const data = Light.prototype.toJSON.call(this, meta);
        data.object.width = this.width;
        data.object.height = this.height;
        return data;
    }
});
/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */ // 3-band SH defined by 9 coefficients
function SphericalHarmonics3() {
    this.coefficients = [];
    for(let i306 = 0; i306 < 9; i306++)this.coefficients.push(new Vector3());
}
Object.assign(SphericalHarmonics3.prototype, {
    isSphericalHarmonics3: true,
    set: function(coefficients) {
        for(let i307 = 0; i307 < 9; i307++)this.coefficients[i307].copy(coefficients[i307]);
        return this;
    },
    zero: function() {
        for(let i308 = 0; i308 < 9; i308++)this.coefficients[i308].set(0, 0, 0);
        return this;
    },
    // get the radiance in the direction of the normal
    // target is a Vector3
    getAt: function(normal, target) {
        // normal is assumed to be unit length
        const x = normal.x, y = normal.y, z = normal.z;
        const coeff = this.coefficients;
        // band 0
        target.copy(coeff[0]).multiplyScalar(0.282095);
        // band 1
        target.addScaledVector(coeff[1], 0.488603 * y);
        target.addScaledVector(coeff[2], 0.488603 * z);
        target.addScaledVector(coeff[3], 0.488603 * x);
        // band 2
        target.addScaledVector(coeff[4], 1.092548 * (x * y));
        target.addScaledVector(coeff[5], 1.092548 * (y * z));
        target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
        target.addScaledVector(coeff[7], 1.092548 * (x * z));
        target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
        return target;
    },
    // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
    // target is a Vector3
    // https://graphics.stanford.edu/papers/envmap/envmap.pdf
    getIrradianceAt: function(normal, target) {
        // normal is assumed to be unit length
        const x = normal.x, y = normal.y, z = normal.z;
        const coeff = this.coefficients;
        // band 0
        target.copy(coeff[0]).multiplyScalar(0.886227); // Ï€ * 0.282095
        // band 1
        target.addScaledVector(coeff[1], 1.023328 * y); // ( 2 * Ï€ / 3 ) * 0.488603
        target.addScaledVector(coeff[2], 1.023328 * z);
        target.addScaledVector(coeff[3], 1.023328 * x);
        // band 2
        target.addScaledVector(coeff[4], 0.858086 * x * y); // ( Ï€ / 4 ) * 1.092548
        target.addScaledVector(coeff[5], 0.858086 * y * z);
        target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( Ï€ / 4 ) * 0.315392 * 3
        target.addScaledVector(coeff[7], 0.858086 * x * z);
        target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( Ï€ / 4 ) * 0.546274
        return target;
    },
    add: function(sh) {
        for(let i309 = 0; i309 < 9; i309++)this.coefficients[i309].add(sh.coefficients[i309]);
        return this;
    },
    addScaledSH: function(sh, s) {
        for(let i310 = 0; i310 < 9; i310++)this.coefficients[i310].addScaledVector(sh.coefficients[i310], s);
        return this;
    },
    scale: function(s) {
        for(let i311 = 0; i311 < 9; i311++)this.coefficients[i311].multiplyScalar(s);
        return this;
    },
    lerp: function(sh, alpha) {
        for(let i312 = 0; i312 < 9; i312++)this.coefficients[i312].lerp(sh.coefficients[i312], alpha);
        return this;
    },
    equals: function(sh) {
        for(let i313 = 0; i313 < 9; i313++){
            if (!this.coefficients[i313].equals(sh.coefficients[i313])) return false;
        }
        return true;
    },
    copy: function(sh) {
        return this.set(sh.coefficients);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        const coefficients = this.coefficients;
        for(let i314 = 0; i314 < 9; i314++)coefficients[i314].fromArray(array, offset + i314 * 3);
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        const coefficients = this.coefficients;
        for(let i315 = 0; i315 < 9; i315++)coefficients[i315].toArray(array, offset + i315 * 3);
        return array;
    }
});
Object.assign(SphericalHarmonics3, {
    // evaluate the basis functions
    // shBasis is an Array[ 9 ]
    getBasisAt: function(normal, shBasis) {
        // normal is assumed to be unit length
        const x = normal.x, y = normal.y, z = normal.z;
        // band 0
        shBasis[0] = 0.282095;
        // band 1
        shBasis[1] = 0.488603 * y;
        shBasis[2] = 0.488603 * z;
        shBasis[3] = 0.488603 * x;
        // band 2
        shBasis[4] = 1.092548 * x * y;
        shBasis[5] = 1.092548 * y * z;
        shBasis[6] = 0.315392 * (3 * z * z - 1);
        shBasis[7] = 1.092548 * x * z;
        shBasis[8] = 0.546274 * (x * x - y * y);
    }
});
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * A LightProbe is a source of indirect-diffuse light
 */ function LightProbe(sh, intensity) {
    Light.call(this, undefined, intensity);
    this.type = 'LightProbe';
    this.sh = sh !== undefined ? sh : new SphericalHarmonics3();
}
LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: LightProbe,
    isLightProbe: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.sh.copy(source.sh);
        return this;
    },
    fromJSON: function(json) {
        this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
        this.sh.fromArray(json.sh);
        return this;
    },
    toJSON: function(meta) {
        const data = Light.prototype.toJSON.call(this, meta);
        data.object.sh = this.sh.toArray();
        return data;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function MaterialLoader(manager) {
    Loader.call(this, manager);
    this.textures = {};
}
MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: MaterialLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    },
    parse: function(json) {
        const textures = this.textures;
        function getTexture(name) {
            if (textures[name] === undefined) console.warn('THREE.MaterialLoader: Undefined texture', name);
            return textures[name];
        }
        const material = new Materials[json.type]();
        if (json.uuid !== undefined) material.uuid = json.uuid;
        if (json.name !== undefined) material.name = json.name;
        if (json.color !== undefined) material.color.setHex(json.color);
        if (json.roughness !== undefined) material.roughness = json.roughness;
        if (json.metalness !== undefined) material.metalness = json.metalness;
        if (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);
        if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
        if (json.specular !== undefined) material.specular.setHex(json.specular);
        if (json.shininess !== undefined) material.shininess = json.shininess;
        if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
        if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
        if (json.fog !== undefined) material.fog = json.fog;
        if (json.flatShading !== undefined) material.flatShading = json.flatShading;
        if (json.blending !== undefined) material.blending = json.blending;
        if (json.combine !== undefined) material.combine = json.combine;
        if (json.side !== undefined) material.side = json.side;
        if (json.opacity !== undefined) material.opacity = json.opacity;
        if (json.transparent !== undefined) material.transparent = json.transparent;
        if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
        if (json.depthTest !== undefined) material.depthTest = json.depthTest;
        if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
        if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
        if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
        if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
        if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
        if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
        if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
        if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
        if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
        if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
        if (json.wireframe !== undefined) material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
        if (json.rotation !== undefined) material.rotation = json.rotation;
        if (json.linewidth !== 1) material.linewidth = json.linewidth;
        if (json.dashSize !== undefined) material.dashSize = json.dashSize;
        if (json.gapSize !== undefined) material.gapSize = json.gapSize;
        if (json.scale !== undefined) material.scale = json.scale;
        if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
        if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
        if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
        if (json.skinning !== undefined) material.skinning = json.skinning;
        if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
        if (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;
        if (json.dithering !== undefined) material.dithering = json.dithering;
        if (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;
        if (json.visible !== undefined) material.visible = json.visible;
        if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
        if (json.userData !== undefined) material.userData = json.userData;
        if (json.vertexColors !== undefined) {
            if (typeof json.vertexColors === 'number') material.vertexColors = json.vertexColors > 0 ? true : false;
            else material.vertexColors = json.vertexColors;
        }
        // Shader Material
        if (json.uniforms !== undefined) for(const name4 in json.uniforms){
            const uniform = json.uniforms[name4];
            material.uniforms[name4] = {};
            switch(uniform.type){
                case 't':
                    material.uniforms[name4].value = getTexture(uniform.value);
                    break;
                case 'c':
                    material.uniforms[name4].value = new Color().setHex(uniform.value);
                    break;
                case 'v2':
                    material.uniforms[name4].value = new Vector2().fromArray(uniform.value);
                    break;
                case 'v3':
                    material.uniforms[name4].value = new Vector3().fromArray(uniform.value);
                    break;
                case 'v4':
                    material.uniforms[name4].value = new Vector4().fromArray(uniform.value);
                    break;
                case 'm3':
                    material.uniforms[name4].value = new Matrix3().fromArray(uniform.value);
                case 'm4':
                    material.uniforms[name4].value = new Matrix4().fromArray(uniform.value);
                    break;
                default:
                    material.uniforms[name4].value = uniform.value;
            }
        }
        if (json.defines !== undefined) material.defines = json.defines;
        if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
        if (json.extensions !== undefined) for(const key in json.extensions)material.extensions[key] = json.extensions[key];
        // Deprecated
        if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
        // for PointsMaterial
        if (json.size !== undefined) material.size = json.size;
        if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
        // maps
        if (json.map !== undefined) material.map = getTexture(json.map);
        if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
        if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
        if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
        if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
        if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
        if (json.normalScale !== undefined) {
            let normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) // Blender exporter used to export a scalar. See #7459
            normalScale = [
                normalScale,
                normalScale
            ];
            material.normalScale = new Vector2().fromArray(normalScale);
        }
        if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
        if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
        if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
        if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
        if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
        if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
        if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
        if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
        if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
        if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
        if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
        if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
        if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
        return material;
    },
    setTextures: function(value) {
        this.textures = value;
        return this;
    }
});
/**
 * @author Don McCurdy / https://www.donmccurdy.com
 */ const LoaderUtils = {
    decodeText: function(array) {
        if (typeof TextDecoder !== 'undefined') return new TextDecoder().decode(array);
        // Avoid the String.fromCharCode.apply(null, array) shortcut, which
        // throws a "maximum call stack size exceeded" error for large arrays.
        let s = '';
        for(let i316 = 0, il = array.length; i316 < il; i316++)// Implicitly assumes little-endian.
        s += String.fromCharCode(array[i316]);
        try {
            // merges multi-byte utf-8 characters.
            return decodeURIComponent(escape(s));
        } catch (e) {
            return s;
        }
    },
    extractUrlBase: function(url) {
        const index = url.lastIndexOf('/');
        if (index === -1) return './';
        return url.substr(0, index + 1);
    }
};
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */ function InstancedBufferGeometry() {
    BufferGeometry.call(this);
    this.type = 'InstancedBufferGeometry';
    this.instanceCount = Infinity;
}
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
    constructor: InstancedBufferGeometry,
    isInstancedBufferGeometry: true,
    copy: function(source) {
        BufferGeometry.prototype.copy.call(this, source);
        this.instanceCount = source.instanceCount;
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    toJSON: function() {
        const data = BufferGeometry.prototype.toJSON.call(this);
        data.instanceCount = this.instanceCount;
        data.isInstancedBufferGeometry = true;
        return data;
    }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */ function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
    if (typeof normalized === 'number') {
        meshPerAttribute = normalized;
        normalized = false;
        console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
    }
    BufferAttribute.call(this, array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
    constructor: InstancedBufferAttribute,
    isInstancedBufferAttribute: true,
    copy: function(source) {
        BufferAttribute.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    },
    toJSON: function() {
        const data = BufferAttribute.prototype.toJSON.call(this);
        data.meshPerAttribute = this.meshPerAttribute;
        data.isInstancedBufferAttribute = true;
        return data;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function BufferGeometryLoader(manager) {
    Loader.call(this, manager);
}
BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: BufferGeometryLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(JSON.parse(text)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    },
    parse: function(json1) {
        const interleavedBufferMap = {};
        const arrayBufferMap = {};
        function getInterleavedBuffer(json, uuid) {
            if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
            const interleavedBuffers = json.interleavedBuffers;
            const interleavedBuffer = interleavedBuffers[uuid];
            const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
            const array = new TYPED_ARRAYS[interleavedBuffer.type](buffer);
            const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
            ib.uuid = interleavedBuffer.uuid;
            interleavedBufferMap[uuid] = ib;
            return ib;
        }
        function getArrayBuffer(json, uuid) {
            if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
            const arrayBuffers = json.arrayBuffers;
            const arrayBuffer = arrayBuffers[uuid];
            const ab = new Uint32Array(arrayBuffer).buffer;
            arrayBufferMap[uuid] = ab;
            return ab;
        }
        const geometry = json1.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
        const index = json1.data.index;
        if (index !== undefined) {
            const typedArray = new TYPED_ARRAYS[index.type](index.array);
            geometry.setIndex(new BufferAttribute(typedArray, 1));
        }
        const attributes = json1.data.attributes;
        for(const key in attributes){
            const attribute = attributes[key];
            let bufferAttribute;
            if (attribute.isInterleavedBufferAttribute) {
                const interleavedBuffer = getInterleavedBuffer(json1.data, attribute.data);
                bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
            } else {
                const typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
                bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
            }
            if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
            geometry.setAttribute(key, bufferAttribute);
        }
        const morphAttributes = json1.data.morphAttributes;
        if (morphAttributes) for(const key2 in morphAttributes){
            const attributeArray = morphAttributes[key2];
            const array = [];
            for(let i317 = 0, il = attributeArray.length; i317 < il; i317++){
                const attribute = attributeArray[i317];
                let bufferAttribute;
                if (attribute.isInterleavedBufferAttribute) {
                    const interleavedBuffer = getInterleavedBuffer(json1.data, attribute.data);
                    bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                    const typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                    bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
                }
                if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
                array.push(bufferAttribute);
            }
            geometry.morphAttributes[key2] = array;
        }
        const morphTargetsRelative = json1.data.morphTargetsRelative;
        if (morphTargetsRelative) geometry.morphTargetsRelative = true;
        const groups = json1.data.groups || json1.data.drawcalls || json1.data.offsets;
        if (groups !== undefined) for(let i318 = 0, n = groups.length; i318 !== n; ++i318){
            const group = groups[i318];
            geometry.addGroup(group.start, group.count, group.materialIndex);
        }
        const boundingSphere = json1.data.boundingSphere;
        if (boundingSphere !== undefined) {
            const center = new Vector3();
            if (boundingSphere.center !== undefined) center.fromArray(boundingSphere.center);
            geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
        }
        if (json1.name) geometry.name = json1.name;
        if (json1.userData) geometry.userData = json1.userData;
        return geometry;
    }
});
const TYPED_ARRAYS = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    // Workaround for IE11 pre KB2929437. See #11440
    Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ function ObjectLoader(manager) {
    Loader.call(this, manager);
}
ObjectLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: ObjectLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path;
        const loader = new FileLoader(scope.manager);
        loader.setPath(this.path);
        loader.load(url, function(text) {
            let json = null;
            try {
                json = JSON.parse(text);
            } catch (error) {
                if (onError !== undefined) onError(error);
                console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
                return;
            }
            const metadata = json.metadata;
            if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                console.error('THREE.ObjectLoader: Can\'t load ' + url);
                return;
            }
            scope.parse(json, onLoad);
        }, onProgress, onError);
    },
    parse: function(json, onLoad) {
        const shapes = this.parseShape(json.shapes);
        const geometries = this.parseGeometries(json.geometries, shapes);
        const images = this.parseImages(json.images, function() {
            if (onLoad !== undefined) onLoad(object);
        });
        const textures = this.parseTextures(json.textures, images);
        const materials = this.parseMaterials(json.materials, textures);
        const object = this.parseObject(json.object, geometries, materials);
        if (json.animations) object.animations = this.parseAnimations(json.animations);
        if (json.images === undefined || json.images.length === 0) {
            if (onLoad !== undefined) onLoad(object);
        }
        return object;
    },
    parseShape: function(json) {
        const shapes = {};
        if (json !== undefined) for(let i319 = 0, l = json.length; i319 < l; i319++){
            const shape = new Shape().fromJSON(json[i319]);
            shapes[shape.uuid] = shape;
        }
        return shapes;
    },
    parseGeometries: function(json, shapes) {
        const geometries = {};
        let geometryShapes;
        if (json !== undefined) {
            const bufferGeometryLoader = new BufferGeometryLoader();
            for(let i320 = 0, l = json.length; i320 < l; i320++){
                let geometry;
                const data = json[i320];
                switch(data.type){
                    case 'PlaneGeometry':
                    case 'PlaneBufferGeometry':
                        geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                        break;
                    case 'BoxGeometry':
                    case 'BoxBufferGeometry':
                    case 'CubeGeometry':
                        geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                        break;
                    case 'CircleGeometry':
                    case 'CircleBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                        break;
                    case 'CylinderGeometry':
                    case 'CylinderBufferGeometry':
                        geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                        break;
                    case 'ConeGeometry':
                    case 'ConeBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                        break;
                    case 'SphereGeometry':
                    case 'SphereBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                        break;
                    case 'DodecahedronGeometry':
                    case 'DodecahedronBufferGeometry':
                    case 'IcosahedronGeometry':
                    case 'IcosahedronBufferGeometry':
                    case 'OctahedronGeometry':
                    case 'OctahedronBufferGeometry':
                    case 'TetrahedronGeometry':
                    case 'TetrahedronBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.detail);
                        break;
                    case 'RingGeometry':
                    case 'RingBufferGeometry':
                        geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                        break;
                    case 'TorusGeometry':
                    case 'TorusBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                        break;
                    case 'TorusKnotGeometry':
                    case 'TorusKnotBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                        break;
                    case 'TubeGeometry':
                    case 'TubeBufferGeometry':
                        // This only works for built-in curves (e.g. CatmullRomCurve3).
                        // User defined curves or instances of CurvePath will not be deserialized.
                        geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
                        break;
                    case 'LatheGeometry':
                    case 'LatheBufferGeometry':
                        geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                        break;
                    case 'PolyhedronGeometry':
                    case 'PolyhedronBufferGeometry':
                        geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
                        break;
                    case 'ShapeGeometry':
                    case 'ShapeBufferGeometry':
                        geometryShapes = [];
                        for(let j = 0, jl = data.shapes.length; j < jl; j++){
                            const shape = shapes[data.shapes[j]];
                            geometryShapes.push(shape);
                        }
                        geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
                        break;
                    case 'ExtrudeGeometry':
                    case 'ExtrudeBufferGeometry':
                        geometryShapes = [];
                        for(let j6 = 0, jl2 = data.shapes.length; j6 < jl2; j6++){
                            const shape = shapes[data.shapes[j6]];
                            geometryShapes.push(shape);
                        }
                        const extrudePath = data.options.extrudePath;
                        if (extrudePath !== undefined) data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
                        geometry = new Geometries[data.type](geometryShapes, data.options);
                        break;
                    case 'BufferGeometry':
                    case 'InstancedBufferGeometry':
                        geometry = bufferGeometryLoader.parse(data);
                        break;
                    case 'Geometry':
                        console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                        continue;
                }
                geometry.uuid = data.uuid;
                if (data.name !== undefined) geometry.name = data.name;
                if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
                geometries[data.uuid] = geometry;
            }
        }
        return geometries;
    },
    parseMaterials: function(json, textures) {
        const cache = {}; // MultiMaterial
        const materials = {};
        if (json !== undefined) {
            const loader = new MaterialLoader();
            loader.setTextures(textures);
            for(let i321 = 0, l = json.length; i321 < l; i321++){
                const data = json[i321];
                if (data.type === 'MultiMaterial') {
                    // Deprecated
                    const array = [];
                    for(let j = 0; j < data.materials.length; j++){
                        const material = data.materials[j];
                        if (cache[material.uuid] === undefined) cache[material.uuid] = loader.parse(material);
                        array.push(cache[material.uuid]);
                    }
                    materials[data.uuid] = array;
                } else {
                    if (cache[data.uuid] === undefined) cache[data.uuid] = loader.parse(data);
                    materials[data.uuid] = cache[data.uuid];
                }
            }
        }
        return materials;
    },
    parseAnimations: function(json) {
        const animations = [];
        for(let i322 = 0; i322 < json.length; i322++){
            const data = json[i322];
            const clip = AnimationClip.parse(data);
            if (data.uuid !== undefined) clip.uuid = data.uuid;
            animations.push(clip);
        }
        return animations;
    },
    parseImages: function(json, onLoad) {
        const scope = this;
        const images = {};
        let loader;
        function loadImage(url) {
            scope.manager.itemStart(url);
            return loader.load(url, function() {
                scope.manager.itemEnd(url);
            }, undefined, function() {
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            });
        }
        if (json !== undefined && json.length > 0) {
            const manager = new LoadingManager(onLoad);
            loader = new ImageLoader(manager);
            loader.setCrossOrigin(this.crossOrigin);
            for(let i323 = 0, il = json.length; i323 < il; i323++){
                const image = json[i323];
                const url = image.url;
                if (Array.isArray(url)) {
                    // load array of images e.g CubeTexture
                    images[image.uuid] = [];
                    for(let j = 0, jl = url.length; j < jl; j++){
                        const currentUrl = url[j];
                        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;
                        images[image.uuid].push(loadImage(path));
                    }
                } else {
                    // load single image
                    const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.resourcePath + image.url;
                    images[image.uuid] = loadImage(path);
                }
            }
        }
        return images;
    },
    parseTextures: function(json, images) {
        function parseConstant(value, type) {
            if (typeof value === 'number') return value;
            console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
            return type[value];
        }
        const textures = {};
        if (json !== undefined) for(let i324 = 0, l = json.length; i324 < l; i324++){
            const data = json[i324];
            if (data.image === undefined) console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
            if (images[data.image] === undefined) console.warn('THREE.ObjectLoader: Undefined image', data.image);
            let texture;
            if (Array.isArray(images[data.image])) texture = new CubeTexture(images[data.image]);
            else texture = new Texture(images[data.image]);
            texture.needsUpdate = true;
            texture.uuid = data.uuid;
            if (data.name !== undefined) texture.name = data.name;
            if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
            if (data.offset !== undefined) texture.offset.fromArray(data.offset);
            if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
            if (data.center !== undefined) texture.center.fromArray(data.center);
            if (data.rotation !== undefined) texture.rotation = data.rotation;
            if (data.wrap !== undefined) {
                texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
            }
            if (data.format !== undefined) texture.format = data.format;
            if (data.type !== undefined) texture.type = data.type;
            if (data.encoding !== undefined) texture.encoding = data.encoding;
            if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
            if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
            if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
            if (data.flipY !== undefined) texture.flipY = data.flipY;
            if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
            if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
            textures[data.uuid] = texture;
        }
        return textures;
    },
    parseObject: function(data, geometries, materials) {
        let object;
        function getGeometry(name) {
            if (geometries[name] === undefined) console.warn('THREE.ObjectLoader: Undefined geometry', name);
            return geometries[name];
        }
        function getMaterial(name) {
            if (name === undefined) return undefined;
            if (Array.isArray(name)) {
                const array = [];
                for(let i325 = 0, l = name.length; i325 < l; i325++){
                    const uuid = name[i325];
                    if (materials[uuid] === undefined) console.warn('THREE.ObjectLoader: Undefined material', uuid);
                    array.push(materials[uuid]);
                }
                return array;
            }
            if (materials[name] === undefined) console.warn('THREE.ObjectLoader: Undefined material', name);
            return materials[name];
        }
        let geometry, material;
        switch(data.type){
            case 'Scene':
                object = new Scene();
                if (data.background !== undefined) {
                    if (Number.isInteger(data.background)) object.background = new Color(data.background);
                }
                if (data.fog !== undefined) {
                    if (data.fog.type === 'Fog') object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                    else if (data.fog.type === 'FogExp2') object.fog = new FogExp2(data.fog.color, data.fog.density);
                }
                break;
            case 'PerspectiveCamera':
                object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                if (data.focus !== undefined) object.focus = data.focus;
                if (data.zoom !== undefined) object.zoom = data.zoom;
                if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                if (data.view !== undefined) object.view = Object.assign({}, data.view);
                break;
            case 'OrthographicCamera':
                object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                if (data.zoom !== undefined) object.zoom = data.zoom;
                if (data.view !== undefined) object.view = Object.assign({}, data.view);
                break;
            case 'AmbientLight':
                object = new AmbientLight(data.color, data.intensity);
                break;
            case 'DirectionalLight':
                object = new DirectionalLight(data.color, data.intensity);
                break;
            case 'PointLight':
                object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                break;
            case 'RectAreaLight':
                object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                break;
            case 'SpotLight':
                object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                break;
            case 'HemisphereLight':
                object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                break;
            case 'LightProbe':
                object = new LightProbe().fromJSON(data);
                break;
            case 'SkinnedMesh':
                console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');
            case 'Mesh':
                geometry = getGeometry(data.geometry);
                material = getMaterial(data.material);
                object = new Mesh(geometry, material);
                break;
            case 'InstancedMesh':
                geometry = getGeometry(data.geometry);
                material = getMaterial(data.material);
                const count = data.count;
                const instanceMatrix = data.instanceMatrix;
                object = new InstancedMesh(geometry, material, count);
                object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
                break;
            case 'LOD':
                object = new LOD();
                break;
            case 'Line':
                object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                break;
            case 'LineLoop':
                object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'LineSegments':
                object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'PointCloud':
            case 'Points':
                object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'Sprite':
                object = new Sprite(getMaterial(data.material));
                break;
            case 'Group':
                object = new Group();
                break;
            default:
                object = new Object3D();
        }
        object.uuid = data.uuid;
        if (data.name !== undefined) object.name = data.name;
        if (data.matrix !== undefined) {
            object.matrix.fromArray(data.matrix);
            if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
            if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
        } else {
            if (data.position !== undefined) object.position.fromArray(data.position);
            if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
            if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
            if (data.scale !== undefined) object.scale.fromArray(data.scale);
        }
        if (data.castShadow !== undefined) object.castShadow = data.castShadow;
        if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
        if (data.shadow) {
            if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
            if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
            if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
            if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
            if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
        }
        if (data.visible !== undefined) object.visible = data.visible;
        if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
        if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
        if (data.userData !== undefined) object.userData = data.userData;
        if (data.layers !== undefined) object.layers.mask = data.layers;
        if (data.children !== undefined) {
            const children = data.children;
            for(let i326 = 0; i326 < children.length; i326++)object.add(this.parseObject(children[i326], geometries, materials));
        }
        if (data.type === 'LOD') {
            if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
            const levels = data.levels;
            for(let l = 0; l < levels.length; l++){
                const level = levels[l];
                const child = object.getObjectByProperty('uuid', level.object);
                if (child !== undefined) object.addLevel(child, level.distance);
            }
        }
        return object;
    }
});
const TEXTURE_MAPPING = {
    UVMapping: UVMapping,
    CubeReflectionMapping: CubeReflectionMapping,
    CubeRefractionMapping: CubeRefractionMapping,
    EquirectangularReflectionMapping: EquirectangularReflectionMapping,
    EquirectangularRefractionMapping: EquirectangularRefractionMapping,
    CubeUVReflectionMapping: CubeUVReflectionMapping,
    CubeUVRefractionMapping: CubeUVRefractionMapping
};
const TEXTURE_WRAPPING = {
    RepeatWrapping: RepeatWrapping,
    ClampToEdgeWrapping: ClampToEdgeWrapping,
    MirroredRepeatWrapping: MirroredRepeatWrapping
};
const TEXTURE_FILTER = {
    NearestFilter: NearestFilter,
    NearestMipmapNearestFilter: NearestMipmapNearestFilter,
    NearestMipmapLinearFilter: NearestMipmapLinearFilter,
    LinearFilter: LinearFilter,
    LinearMipmapNearestFilter: LinearMipmapNearestFilter,
    LinearMipmapLinearFilter: LinearMipmapLinearFilter
};
/**
 * @author thespite / http://clicktorelease.com/
 */ function ImageBitmapLoader(manager) {
    if (typeof createImageBitmap === 'undefined') console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
    if (typeof fetch === 'undefined') console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
    Loader.call(this, manager);
    this.options = {
        premultiplyAlpha: 'none'
    };
}
ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: ImageBitmapLoader,
    isImageBitmapLoader: true,
    setOptions: function setOptions(options) {
        this.options = options;
        return this;
    },
    load: function(url, onLoad, onProgress, onError) {
        if (url === undefined) url = '';
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== undefined) {
            scope.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        fetch(url).then(function(res) {
            return res.blob();
        }).then(function(blob) {
            return createImageBitmap(blob, scope.options);
        }).then(function(imageBitmap) {
            Cache.add(url, imageBitmap);
            if (onLoad) onLoad(imageBitmap);
            scope.manager.itemEnd(url);
        }).catch(function(e) {
            if (onError) onError(e);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
        });
        scope.manager.itemStart(url);
    }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
 **/ function ShapePath() {
    this.type = 'ShapePath';
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
}
Object.assign(ShapePath.prototype, {
    moveTo: function(x, y) {
        this.currentPath = new Path();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x, y);
        return this;
    },
    lineTo: function(x, y) {
        this.currentPath.lineTo(x, y);
        return this;
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
    },
    splineThru: function(pts) {
        this.currentPath.splineThru(pts);
        return this;
    },
    toShapes: function(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
            const shapes = [];
            for(let i329 = 0, l = inSubpaths.length; i329 < l; i329++){
                const tmpPath = inSubpaths[i329];
                const tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
            }
            return shapes;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            // inPt on polygon contour => immediate success    or
            // toggling of inside/outside at every single! intersection point of an edge
            //  with the horizontal line through inPt, left of inPt
            //  not counting lowerY endpoints of edges and whole edges on that line
            let inside = false;
            for(let p = polyLen - 1, q = 0; q < polyLen; p = q++){
                let edgeLowPt = inPolygon[p];
                let edgeHighPt = inPolygon[q];
                let edgeDx = edgeHighPt.x - edgeLowPt.x;
                let edgeDy = edgeHighPt.y - edgeLowPt.y;
                if (Math.abs(edgeDy) > Number.EPSILON) {
                    // not parallel
                    if (edgeDy < 0) {
                        edgeLowPt = inPolygon[q];
                        edgeDx = -edgeDx;
                        edgeHighPt = inPolygon[p];
                        edgeDy = -edgeDy;
                    }
                    if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                    if (inPt.y === edgeLowPt.y) {
                        if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
                    // continue;				// no intersection or edgeLowPt => doesn't count !!!
                    } else {
                        const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                        if (perpEdge === 0) return true; // inPt is on contour ?
                        if (perpEdge < 0) continue;
                        inside = !inside; // true intersection left of inPt
                    }
                } else {
                    // parallel or collinear
                    if (inPt.y !== edgeLowPt.y) continue; // parallel
                    // edge lies on the same horizontal line as inPt
                    if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
                // continue;
                }
            }
            return inside;
        }
        const isClockWise = ShapeUtils.isClockWise;
        const subPaths = this.subPaths;
        if (subPaths.length === 0) return [];
        if (noHoles === true) return toShapesNoHoles(subPaths);
        let solid, tmpPath1, tmpShape1, shapes1 = [];
        if (subPaths.length === 1) {
            tmpPath1 = subPaths[0];
            tmpShape1 = new Shape();
            tmpShape1.curves = tmpPath1.curves;
            shapes1.push(tmpShape1);
            return shapes1;
        }
        let holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        // console.log("Holes first", holesFirst);
        const betterShapeHoles = [];
        const newShapes = [];
        let newShapeHoles = [];
        let mainIdx = 0;
        let tmpPoints;
        newShapes[mainIdx] = undefined;
        newShapeHoles[mainIdx] = [];
        for(let i328 = 0, l6 = subPaths.length; i328 < l6; i328++){
            tmpPath1 = subPaths[i328];
            tmpPoints = tmpPath1.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
                if (!holesFirst && newShapes[mainIdx]) mainIdx++;
                newShapes[mainIdx] = {
                    s: new Shape(),
                    p: tmpPoints
                };
                newShapes[mainIdx].s.curves = tmpPath1.curves;
                if (holesFirst) mainIdx++;
                newShapeHoles[mainIdx] = [];
            //console.log('cw', i);
            } else newShapeHoles[mainIdx].push({
                h: tmpPath1,
                p: tmpPoints[0]
            });
        }
        // only Holes? -> probably all Shapes with wrong orientation
        if (!newShapes[0]) return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
            let ambiguous = false;
            const toChange = [];
            for(let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++)betterShapeHoles[sIdx] = [];
            for(let sIdx1 = 0, sLen1 = newShapes.length; sIdx1 < sLen1; sIdx1++){
                const sho = newShapeHoles[sIdx1];
                for(let hIdx = 0; hIdx < sho.length; hIdx++){
                    const ho = sho[hIdx];
                    let hole_unassigned = true;
                    for(let s2Idx = 0; s2Idx < newShapes.length; s2Idx++)if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                        if (sIdx1 !== s2Idx) toChange.push({
                            froms: sIdx1,
                            tos: s2Idx,
                            hole: hIdx
                        });
                        if (hole_unassigned) {
                            hole_unassigned = false;
                            betterShapeHoles[s2Idx].push(ho);
                        } else ambiguous = true;
                    }
                    if (hole_unassigned) betterShapeHoles[sIdx1].push(ho);
                }
            }
            // console.log("ambiguous: ", ambiguous);
            if (toChange.length > 0) // console.log("to change: ", toChange);
            {
                if (!ambiguous) newShapeHoles = betterShapeHoles;
            }
        }
        let tmpHoles;
        for(let i327 = 0, il = newShapes.length; i327 < il; i327++){
            tmpShape1 = newShapes[i327].s;
            shapes1.push(tmpShape1);
            tmpHoles = newShapeHoles[i327];
            for(let j = 0, jl = tmpHoles.length; j < jl; j++)tmpShape1.holes.push(tmpHoles[j].h);
        }
        //console.log("shape", shapes);
        return shapes1;
    }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */ function Font(data) {
    this.type = 'Font';
    this.data = data;
}
Object.assign(Font.prototype, {
    isFont: true,
    generateShapes: function(text, size) {
        if (size === undefined) size = 100;
        const shapes = [];
        const paths = createPaths(text, size, this.data);
        for(let p = 0, pl = paths.length; p < pl; p++)Array.prototype.push.apply(shapes, paths[p].toShapes());
        return shapes;
    }
});
function createPaths(text, size, data) {
    const chars = Array.from ? Array.from(text) : String(text).split(''); // workaround for IE11, see #13988
    const scale = size / data.resolution;
    const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
    const paths = [];
    let offsetX = 0, offsetY = 0;
    for(let i330 = 0; i330 < chars.length; i330++){
        const char = chars[i330];
        if (char === '\n') {
            offsetX = 0;
            offsetY -= line_height;
        } else {
            const ret = createPath(char, scale, offsetX, offsetY, data);
            offsetX += ret.offsetX;
            paths.push(ret.path);
        }
    }
    return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
    const glyph = data.glyphs[char] || data.glyphs['?'];
    if (!glyph) {
        console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
        return;
    }
    const path = new ShapePath();
    let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
    if (glyph.o) {
        const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
        for(let i331 = 0, l = outline.length; i331 < l;){
            const action = outline[i331++];
            switch(action){
                case 'm':
                    x = outline[i331++] * scale + offsetX;
                    y = outline[i331++] * scale + offsetY;
                    path.moveTo(x, y);
                    break;
                case 'l':
                    x = outline[i331++] * scale + offsetX;
                    y = outline[i331++] * scale + offsetY;
                    path.lineTo(x, y);
                    break;
                case 'q':
                    cpx = outline[i331++] * scale + offsetX;
                    cpy = outline[i331++] * scale + offsetY;
                    cpx1 = outline[i331++] * scale + offsetX;
                    cpy1 = outline[i331++] * scale + offsetY;
                    path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                    break;
                case 'b':
                    cpx = outline[i331++] * scale + offsetX;
                    cpy = outline[i331++] * scale + offsetY;
                    cpx1 = outline[i331++] * scale + offsetX;
                    cpy1 = outline[i331++] * scale + offsetY;
                    cpx2 = outline[i331++] * scale + offsetX;
                    cpy2 = outline[i331++] * scale + offsetY;
                    path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                    break;
            }
        }
    }
    return {
        offsetX: glyph.ha * scale,
        path: path
    };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function FontLoader(manager) {
    Loader.call(this, manager);
}
FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: FontLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.load(url, function(text) {
            let json;
            try {
                json = JSON.parse(text);
            } catch (e) {
                console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                json = JSON.parse(text.substring(65, text.length - 2));
            }
            const font = scope.parse(json);
            if (onLoad) onLoad(font);
        }, onProgress, onError);
    },
    parse: function(json) {
        return new Font(json);
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ let _context;
const AudioContext = {
    getContext: function() {
        if (_context === undefined) _context = new (window.AudioContext || window.webkitAudioContext)();
        return _context;
    },
    setContext: function(value) {
        _context = value;
    }
};
/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */ function AudioLoader(manager) {
    Loader.call(this, manager);
}
AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: AudioLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader = new FileLoader(scope.manager);
        loader.setResponseType('arraybuffer');
        loader.setPath(scope.path);
        loader.load(url, function(buffer) {
            try {
                // Create a copy of the buffer. The `decodeAudioData` method
                // detaches the buffer when complete, preventing reuse.
                const bufferCopy = buffer.slice(0);
                const context = AudioContext.getContext();
                context.decodeAudioData(bufferCopy, function(audioBuffer) {
                    onLoad(audioBuffer);
                });
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    }
});
/**
 * @author WestLangley / http://github.com/WestLangley
 */ function HemisphereLightProbe(skyColor, groundColor, intensity) {
    LightProbe.call(this, undefined, intensity);
    const color1 = new Color().set(skyColor);
    const color2 = new Color().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b);
    // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
    const c0 = Math.sqrt(Math.PI);
    const c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
}
HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
    constructor: HemisphereLightProbe,
    isHemisphereLightProbe: true,
    copy: function(source) {
        LightProbe.prototype.copy.call(this, source);
        return this;
    },
    toJSON: function(meta) {
        const data = LightProbe.prototype.toJSON.call(this, meta);
        // data.sh = this.sh.toArray(); // todo
        return data;
    }
});
/**
 * @author WestLangley / http://github.com/WestLangley
 */ function AmbientLightProbe(color, intensity) {
    LightProbe.call(this, undefined, intensity);
    const color1 = new Color().set(color);
    // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}
AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
    constructor: AmbientLightProbe,
    isAmbientLightProbe: true,
    copy: function(source) {
        LightProbe.prototype.copy.call(this, source);
        return this;
    },
    toJSON: function(meta) {
        const data = LightProbe.prototype.toJSON.call(this, meta);
        // data.sh = this.sh.toArray(); // todo
        return data;
    }
});
const _eyeRight = new Matrix4();
const _eyeLeft = new Matrix4();
/**
 * @author mrdoob / http://mrdoob.com/
 */ function StereoCamera() {
    this.type = 'StereoCamera';
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null
    };
}
Object.assign(StereoCamera.prototype, {
    update: function(camera) {
        const cache = this._cache;
        const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
        if (needsUpdate) {
            cache.focus = camera.focus;
            cache.fov = camera.fov;
            cache.aspect = camera.aspect * this.aspect;
            cache.near = camera.near;
            cache.far = camera.far;
            cache.zoom = camera.zoom;
            cache.eyeSep = this.eyeSep;
            // Off-axis stereoscopic effect based on
            // http://paulbourke.net/stereographics/stereorender/
            const projectionMatrix = camera.projectionMatrix.clone();
            const eyeSepHalf = cache.eyeSep / 2;
            const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
            const ymax = cache.near * Math.tan(MathUtils.DEG2RAD * cache.fov * 0.5) / cache.zoom;
            let xmin, xmax;
            // translate xOffset
            _eyeLeft.elements[12] = -eyeSepHalf;
            _eyeRight.elements[12] = eyeSepHalf;
            // for left eye
            xmin = -ymax * cache.aspect + eyeSepOnProjection;
            xmax = ymax * cache.aspect + eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraL.projectionMatrix.copy(projectionMatrix);
            // for right eye
            xmin = -ymax * cache.aspect - eyeSepOnProjection;
            xmax = ymax * cache.aspect - eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraR.projectionMatrix.copy(projectionMatrix);
        }
        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */ function Clock(autoStart) {
    this.autoStart = autoStart !== undefined ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
}
Object.assign(Clock.prototype, {
    start: function() {
        this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
    },
    stop: function() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
    },
    getElapsedTime: function() {
        this.getDelta();
        return this.elapsedTime;
    },
    getDelta: function() {
        let diff = 0;
        if (this.autoStart && !this.running) {
            this.start();
            return 0;
        }
        if (this.running) {
            const newTime = (typeof performance === 'undefined' ? Date : performance).now();
            diff = (newTime - this.oldTime) / 1000;
            this.oldTime = newTime;
            this.elapsedTime += diff;
        }
        return diff;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ const _position$2 = new Vector3();
const _quaternion$3 = new Quaternion();
const _scale$1 = new Vector3();
const _orientation = new Vector3();
function AudioListener() {
    Object3D.call(this);
    this.type = 'AudioListener';
    this.context = AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
    // private
    this._clock = new Clock();
}
AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: AudioListener,
    getInput: function() {
        return this.gain;
    },
    removeFilter: function() {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
            this.gain.connect(this.context.destination);
            this.filter = null;
        }
        return this;
    },
    getFilter: function() {
        return this.filter;
    },
    setFilter: function(value) {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
        } else this.gain.disconnect(this.context.destination);
        this.filter = value;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
        return this;
    },
    getMasterVolume: function() {
        return this.gain.gain.value;
    },
    setMasterVolume: function(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    },
    updateMatrixWorld: function(force) {
        Object3D.prototype.updateMatrixWorld.call(this, force);
        const listener = this.context.listener;
        const up = this.up;
        this.timeDelta = this._clock.getDelta();
        this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);
        _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);
        if (listener.positionX) {
            // code path for Chrome (see #14393)
            const endTime = this.context.currentTime + this.timeDelta;
            listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
            listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
            listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
            listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
            listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
            listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
            listener.upX.linearRampToValueAtTime(up.x, endTime);
            listener.upY.linearRampToValueAtTime(up.y, endTime);
            listener.upZ.linearRampToValueAtTime(up.z, endTime);
        } else {
            listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
            listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
        }
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */ function Audio(listener) {
    Object3D.call(this);
    this.type = 'Audio';
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = undefined;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.sourceType = 'empty';
    this._startedAt = 0;
    this._progress = 0;
    this.filters = [];
}
Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Audio,
    getOutput: function() {
        return this.gain;
    },
    setNodeSource: function(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = 'audioNode';
        this.source = audioNode;
        this.connect();
        return this;
    },
    setMediaElementSource: function(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = 'mediaNode';
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
    },
    setMediaStreamSource: function(mediaStream) {
        this.hasPlaybackControl = false;
        this.sourceType = 'mediaStreamNode';
        this.source = this.context.createMediaStreamSource(mediaStream);
        this.connect();
        return this;
    },
    setBuffer: function(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = 'buffer';
        if (this.autoplay) this.play();
        return this;
    },
    play: function(delay) {
        if (delay === undefined) delay = 0;
        if (this.isPlaying === true) {
            console.warn('THREE.Audio: Audio is already playing.');
            return;
        }
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this._startedAt = this.context.currentTime + delay;
        const source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.loop = this.loop;
        source.loopStart = this.loopStart;
        source.loopEnd = this.loopEnd;
        source.onended = this.onEnded.bind(this);
        source.start(this._startedAt, this._progress + this.offset, this.duration);
        this.isPlaying = true;
        this.source = source;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
    },
    pause: function() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        if (this.isPlaying === true) {
            // update current progress
            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
            if (this.loop === true) // ensure _progress does not exceed duration with looped audios
            this._progress = this._progress % (this.duration || this.buffer.duration);
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
        }
        return this;
    },
    stop: function() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this._progress = 0;
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
        return this;
    },
    connect: function() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for(let i332 = 1, l = this.filters.length; i332 < l; i332++)this.filters[i332 - 1].connect(this.filters[i332]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return this;
    },
    disconnect: function() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for(let i333 = 1, l = this.filters.length; i333 < l; i333++)this.filters[i333 - 1].disconnect(this.filters[i333]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this;
    },
    getFilters: function() {
        return this.filters;
    },
    setFilters: function(value) {
        if (!value) value = [];
        if (this.isPlaying === true) {
            this.disconnect();
            this.filters = value;
            this.connect();
        } else this.filters = value;
        return this;
    },
    setDetune: function(value) {
        this.detune = value;
        if (this.source.detune === undefined) return; // only set detune when available
        if (this.isPlaying === true) this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        return this;
    },
    getDetune: function() {
        return this.detune;
    },
    getFilter: function() {
        return this.getFilters()[0];
    },
    setFilter: function(filter) {
        return this.setFilters(filter ? [
            filter
        ] : []);
    },
    setPlaybackRate: function(value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        return this;
    },
    getPlaybackRate: function() {
        return this.playbackRate;
    },
    onEnded: function() {
        this.isPlaying = false;
    },
    getLoop: function() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return false;
        }
        return this.loop;
    },
    setLoop: function(value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.loop = value;
        if (this.isPlaying === true) this.source.loop = this.loop;
        return this;
    },
    setLoopStart: function(value) {
        this.loopStart = value;
        return this;
    },
    setLoopEnd: function(value) {
        this.loopEnd = value;
        return this;
    },
    getVolume: function() {
        return this.gain.gain.value;
    },
    setVolume: function(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ const _position$3 = new Vector3();
const _quaternion$4 = new Quaternion();
const _scale$2 = new Vector3();
const _orientation$1 = new Vector3();
function PositionalAudio(listener) {
    Audio.call(this, listener);
    this.panner = this.context.createPanner();
    this.panner.panningModel = 'HRTF';
    this.panner.connect(this.gain);
}
PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
    constructor: PositionalAudio,
    getOutput: function() {
        return this.panner;
    },
    getRefDistance: function() {
        return this.panner.refDistance;
    },
    setRefDistance: function(value) {
        this.panner.refDistance = value;
        return this;
    },
    getRolloffFactor: function() {
        return this.panner.rolloffFactor;
    },
    setRolloffFactor: function(value) {
        this.panner.rolloffFactor = value;
        return this;
    },
    getDistanceModel: function() {
        return this.panner.distanceModel;
    },
    setDistanceModel: function(value) {
        this.panner.distanceModel = value;
        return this;
    },
    getMaxDistance: function() {
        return this.panner.maxDistance;
    },
    setMaxDistance: function(value) {
        this.panner.maxDistance = value;
        return this;
    },
    setDirectionalCone: function(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        this.panner.coneInnerAngle = coneInnerAngle;
        this.panner.coneOuterAngle = coneOuterAngle;
        this.panner.coneOuterGain = coneOuterGain;
        return this;
    },
    updateMatrixWorld: function(force) {
        Object3D.prototype.updateMatrixWorld.call(this, force);
        if (this.hasPlaybackControl === true && this.isPlaying === false) return;
        this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);
        _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);
        const panner = this.panner;
        if (panner.positionX) {
            // code path for Chrome and Firefox (see #14393)
            const endTime = this.context.currentTime + this.listener.timeDelta;
            panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
            panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
            panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
            panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
            panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
            panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
        } else {
            panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
            panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
        }
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function AudioAnalyser(audio, fftSize) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
}
Object.assign(AudioAnalyser.prototype, {
    getFrequencyData: function() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
    },
    getAverageFrequency: function() {
        let value = 0;
        const data = this.getFrequencyData();
        for(let i334 = 0; i334 < data.length; i334++)value += data[i334];
        return value / data.length;
    }
});
/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function PropertyMixer(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
    //
    // interpolators can use .buffer as their .result
    // the data then goes to 'incoming'
    //
    // 'accu0' and 'accu1' are used frame-interleaved for
    // the cumulative result and are compared to detect
    // changes
    //
    // 'orig' stores the original state of the property
    //
    // 'add' is used for additive cumulative results
    //
    // 'work' is optional and is only present for quaternion types. It is used
    // to store intermediate quaternion multiplication results
    switch(typeName){
        case 'quaternion':
            mixFunction = this._slerp;
            mixFunctionAdditive = this._slerpAdditive;
            setIdentity = this._setAdditiveIdentityQuaternion;
            this.buffer = new Float64Array(valueSize * 6);
            this._workIndex = 5;
            break;
        case 'string':
        case 'bool':
            mixFunction = this._select;
            // Use the regular mix function and for additive on these types,
            // additive is not relevant for non-numeric types
            mixFunctionAdditive = this._select;
            setIdentity = this._setAdditiveIdentityOther;
            this.buffer = new Array(valueSize * 5);
            break;
        default:
            mixFunction = this._lerp;
            mixFunctionAdditive = this._lerpAdditive;
            setIdentity = this._setAdditiveIdentityNumeric;
            this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
}
Object.assign(PropertyMixer.prototype, {
    // accumulate data in the 'incoming' region into 'accu<i>'
    accumulate: function(accuIndex, weight) {
        // note: happily accumulating nothing when weight = 0, the caller knows
        // the weight and shouldn't have made the call in the first place
        const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
        let currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
            // accuN := incoming * weight
            for(let i335 = 0; i335 !== stride; ++i335)buffer[offset + i335] = buffer[i335];
            currentWeight = weight;
        } else {
            // accuN := accuN + incoming * weight
            currentWeight += weight;
            const mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
    },
    // accumulate data in the 'incoming' region into 'add'
    accumulateAdditive: function(weight) {
        const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
        if (this.cumulativeWeightAdditive === 0) // add = identity
        this._setIdentity();
        // add := add + incoming * weight
        this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
        this.cumulativeWeightAdditive += weight;
    },
    // apply the state of 'accu<i>' to the binding when accus differ
    apply: function(accuIndex) {
        const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        if (weight < 1) {
            // accuN := accuN + original * ( 1 - cumulativeWeight )
            const originalValueOffset = stride * this._origIndex;
            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
        }
        if (weightAdditive > 0) // accuN := accuN + additive accuN
        this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
        for(let i336 = stride, e = stride + stride; i336 !== e; ++i336)if (buffer[i336] !== buffer[i336 + stride]) {
            // value has changed -> update scene graph
            binding.setValue(buffer, offset);
            break;
        }
    },
    // remember the state of the bound property and copy it to both accus
    saveOriginalState: function() {
        const binding = this.binding;
        const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
        binding.getValue(buffer, originalValueOffset);
        // accu[0..1] := orig -- initially detect changes against the original
        for(let i337 = stride, e = originalValueOffset; i337 !== e; ++i337)buffer[i337] = buffer[originalValueOffset + i337 % stride];
        // Add to identity for additive
        this._setIdentity();
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
    },
    // apply the state previously taken via 'saveOriginalState' to the binding
    restoreOriginalState: function() {
        const originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
    },
    _setAdditiveIdentityNumeric: function() {
        const startIndex = this._addIndex * this.valueSize;
        const endIndex = startIndex + this.valueSize;
        for(let i338 = startIndex; i338 < endIndex; i338++)this.buffer[i338] = 0;
    },
    _setAdditiveIdentityQuaternion: function() {
        this._setAdditiveIdentityNumeric();
        this.buffer[this._addIndex * 4 + 3] = 1;
    },
    _setAdditiveIdentityOther: function() {
        const startIndex = this._origIndex * this.valueSize;
        const targetIndex = this._addIndex * this.valueSize;
        for(let i339 = 0; i339 < this.valueSize; i339++)this.buffer[targetIndex + i339] = this.buffer[startIndex + i339];
    },
    // mix functions
    _select: function(buffer, dstOffset, srcOffset, t, stride) {
        if (t >= 0.5) for(let i340 = 0; i340 !== stride; ++i340)buffer[dstOffset + i340] = buffer[srcOffset + i340];
    },
    _slerp: function(buffer, dstOffset, srcOffset, t) {
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
    },
    _slerpAdditive: function(buffer, dstOffset, srcOffset, t, stride) {
        const workOffset = this._workIndex * stride;
        // Store result in intermediate buffer offset
        Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
        // Slerp to the intermediate result
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
    },
    _lerp: function(buffer, dstOffset, srcOffset, t, stride) {
        const s = 1 - t;
        for(let i341 = 0; i341 !== stride; ++i341){
            const j = dstOffset + i341;
            buffer[j] = buffer[j] * s + buffer[srcOffset + i341] * t;
        }
    },
    _lerpAdditive: function(buffer, dstOffset, srcOffset, t, stride) {
        for(let i342 = 0; i342 !== stride; ++i342){
            const j = dstOffset + i342;
            buffer[j] = buffer[j] + buffer[srcOffset + i342] * t;
        }
    }
});
/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ // Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');
// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';
// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);
// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);
// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);
// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
const _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');
const _supportedObjectNames = [
    'material',
    'materials',
    'bones'
];
function Composite(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
}
Object.assign(Composite.prototype, {
    getValue: function(array, offset) {
        this.bind(); // bind all binding
        const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        // and only call .getValue on the first
        if (binding !== undefined) binding.getValue(array, offset);
    },
    setValue: function(array, offset) {
        const bindings = this._bindings;
        for(let i343 = this._targetGroup.nCachedObjects_, n = bindings.length; i343 !== n; ++i343)bindings[i343].setValue(array, offset);
    },
    bind: function() {
        const bindings = this._bindings;
        for(let i344 = this._targetGroup.nCachedObjects_, n = bindings.length; i344 !== n; ++i344)bindings[i344].bind();
    },
    unbind: function() {
        const bindings = this._bindings;
        for(let i345 = this._targetGroup.nCachedObjects_, n = bindings.length; i345 !== n; ++i345)bindings[i345].unbind();
    }
});
function PropertyBinding(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
}
Object.assign(PropertyBinding, {
    Composite: Composite,
    create: function(root, path, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) return new PropertyBinding(root, path, parsedPath);
        else return new PropertyBinding.Composite(root, path, parsedPath);
    },
    /**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */ sanitizeNodeName: function(name) {
        return name.replace(/\s/g, '_').replace(_reservedRe, '');
    },
    parseTrackName: function(trackName) {
        const matches = _trackRe.exec(trackName);
        if (!matches) throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
        const results = {
            // directoryName: matches[ 1 ], // (tschw) currently unused
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
        };
        const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
        if (lastDot !== undefined && lastDot !== -1) {
            const objectName = results.nodeName.substring(lastDot + 1);
            // Object names must be checked against an allowlist. Otherwise, there
            // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
            // 'bar' could be the objectName, or part of a nodeName (which can
            // include '.' characters).
            if (_supportedObjectNames.indexOf(objectName) !== -1) {
                results.nodeName = results.nodeName.substring(0, lastDot);
                results.objectName = objectName;
            }
        }
        if (results.propertyName === null || results.propertyName.length === 0) throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
        return results;
    },
    findNode: function(root, nodeName) {
        if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) return root;
        // search into skeleton bones.
        if (root.skeleton) {
            const bone = root.skeleton.getBoneByName(nodeName);
            if (bone !== undefined) return bone;
        }
        // search into node subtree.
        if (root.children) {
            const searchNodeSubtree = function(children) {
                for(let i346 = 0; i346 < children.length; i346++){
                    const childNode = children[i346];
                    if (childNode.name === nodeName || childNode.uuid === nodeName) return childNode;
                    const result = searchNodeSubtree(childNode.children);
                    if (result) return result;
                }
                return null;
            };
            const subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) return subTreeNode;
        }
        return null;
    }
});
Object.assign(PropertyBinding.prototype, {
    // these are used to "bind" a nonexistent property
    _getValue_unavailable: function() {},
    _setValue_unavailable: function() {},
    BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    },
    Versioning: {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    },
    GetterByBindingType: [
        function getValue_direct(buffer, offset) {
            buffer[offset] = this.node[this.propertyName];
        },
        function getValue_array(buffer, offset) {
            const source = this.resolvedProperty;
            for(let i347 = 0, n = source.length; i347 !== n; ++i347)buffer[offset++] = source[i347];
        },
        function getValue_arrayElement(buffer, offset) {
            buffer[offset] = this.resolvedProperty[this.propertyIndex];
        },
        function getValue_toArray(buffer, offset) {
            this.resolvedProperty.toArray(buffer, offset);
        }
    ],
    SetterByBindingTypeAndVersioning: [
        [
            // Direct
            function setValue_direct(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
            },
            function setValue_direct_setNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.needsUpdate = true;
            },
            function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            // EntireArray
            function setValue_array(buffer, offset) {
                const dest = this.resolvedProperty;
                for(let i348 = 0, n = dest.length; i348 !== n; ++i348)dest[i348] = buffer[offset++];
            },
            function setValue_array_setNeedsUpdate(buffer, offset) {
                const dest = this.resolvedProperty;
                for(let i349 = 0, n = dest.length; i349 !== n; ++i349)dest[i349] = buffer[offset++];
                this.targetObject.needsUpdate = true;
            },
            function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
                const dest = this.resolvedProperty;
                for(let i350 = 0, n = dest.length; i350 !== n; ++i350)dest[i350] = buffer[offset++];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            // ArrayElement
            function setValue_arrayElement(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
            },
            function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.needsUpdate = true;
            },
            function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            // HasToFromArray
            function setValue_fromArray(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
            },
            function setValue_fromArray_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.needsUpdate = true;
            },
            function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ]
    ],
    getValue: function getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
    // Note: This class uses a State pattern on a per-method basis:
    // 'bind' sets 'this.getValue' / 'setValue' and shadows the
    // prototype version of these methods with one that represents
    // the bound state. When the property is not found, the methods
    // become no-ops.
    },
    setValue: function getValue_unbound(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
    },
    // create getter / setter pair for a property in the scene graph
    bind: function() {
        let targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
        }
        // set fail state so we can just 'return' on error
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        // ensure there is a value node
        if (!targetObject) {
            console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
            return;
        }
        if (objectName) {
            let objectIndex = parsedPath.objectIndex;
            // special cases were we need to reach deeper into the hierarchy to get the face materials....
            switch(objectName){
                case 'materials':
                    if (!targetObject.material) {
                        console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                        return;
                    }
                    if (!targetObject.material.materials) {
                        console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                        return;
                    }
                    targetObject = targetObject.material.materials;
                    break;
                case 'bones':
                    if (!targetObject.skeleton) {
                        console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                        return;
                    }
                    // potential future optimization: skip this if propertyIndex is already an integer
                    // and convert the integer string to a true integer.
                    targetObject = targetObject.skeleton.bones;
                    // support resolving morphTarget names into indices.
                    for(let i351 = 0; i351 < targetObject.length; i351++)if (targetObject[i351].name === objectIndex) {
                        objectIndex = i351;
                        break;
                    }
                    break;
                default:
                    if (targetObject[objectName] === undefined) {
                        console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                        return;
                    }
                    targetObject = targetObject[objectName];
            }
            if (objectIndex !== undefined) {
                if (targetObject[objectIndex] === undefined) {
                    console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                    return;
                }
                targetObject = targetObject[objectIndex];
            }
        }
        // resolve property
        const nodeProperty = targetObject[propertyName];
        if (nodeProperty === undefined) {
            const nodeName = parsedPath.nodeName;
            console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
            return;
        }
        // determine versioning scheme
        let versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== undefined) versioning = this.Versioning.NeedsUpdate;
        else if (targetObject.matrixWorldNeedsUpdate !== undefined) versioning = this.Versioning.MatrixWorldNeedsUpdate;
        // determine how the property gets bound
        let bindingType = this.BindingType.Direct;
        if (propertyIndex !== undefined) {
            // access a sub element of the property array (only primitives are supported right now)
            if (propertyName === "morphTargetInfluences") {
                // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
                // support resolving morphTarget names into indices.
                if (!targetObject.geometry) {
                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                    return;
                }
                if (targetObject.geometry.isBufferGeometry) {
                    if (!targetObject.geometry.morphAttributes) {
                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                        return;
                    }
                    if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                } else {
                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
                    return;
                }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
            // must use copy for Object3D.Euler/Quaternion
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
        } else this.propertyName = propertyName;
        // select getter / setter
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    },
    unbind: function() {
        this.node = null;
        // back to the prototype version of getValue / setValue
        // note: avoiding to mutate the shape of 'this' via 'delete'
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
    }
});
// DECLARE ALIAS AFTER assign prototype
Object.assign(PropertyBinding.prototype, {
    // initial state of these methods that calls 'bind'
    _getValue_unbound: PropertyBinding.prototype.getValue,
    _setValue_unbound: PropertyBinding.prototype.setValue
});
/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 *
 * @author tschw
 */ function AnimationObjectGroup() {
    this.uuid = MathUtils.generateUUID();
    // cached objects followed by the active ones
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0; // threshold
    // note: read by PropertyBinding.Composite
    const indices = {};
    this._indicesByUUID = indices; // for bookkeeping
    for(let i352 = 0, n = arguments.length; i352 !== n; ++i352)indices[arguments[i352].uuid] = i352;
    this._paths = []; // inside: string
    this._parsedPaths = []; // inside: { we don't care, here }
    this._bindings = []; // inside: Array< PropertyBinding >
    this._bindingsIndicesByPath = {}; // inside: indices in these arrays
    const scope = this;
    this.stats = {
        objects: {
            get total () {
                return scope._objects.length;
            },
            get inUse () {
                return this.total - scope.nCachedObjects_;
            }
        },
        get bindingsPerObject () {
            return scope._bindings.length;
        }
    };
}
Object.assign(AnimationObjectGroup.prototype, {
    isAnimationObjectGroup: true,
    add: function() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
        let knownObject = undefined, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
        for(let i353 = 0, n = arguments.length; i353 !== n; ++i353){
            const object = arguments[i353], uuid = object.uuid;
            let index = indicesByUUID[uuid];
            if (index === undefined) {
                // unknown object -> add it to the ACTIVE region
                index = nObjects++;
                indicesByUUID[uuid] = index;
                objects.push(object);
                // accounting is done, now do the same for all bindings
                for(let j = 0, m = nBindings; j !== m; ++j)bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
            } else if (index < nCachedObjects) {
                knownObject = objects[index];
                // move existing object to the ACTIVE region
                const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                indicesByUUID[lastCachedObject.uuid] = index;
                objects[index] = lastCachedObject;
                indicesByUUID[uuid] = firstActiveIndex;
                objects[firstActiveIndex] = object;
                // accounting is done, now do the same for all bindings
                for(let j = 0, m = nBindings; j !== m; ++j){
                    const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
                    let binding = bindingsForPath[index];
                    bindingsForPath[index] = lastCached;
                    if (binding === undefined) // since we do not bother to create new bindings
                    // for objects that are cached, the binding may
                    // or may not exist
                    binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                    bindingsForPath[firstActiveIndex] = binding;
                }
            } else if (objects[index] !== knownObject) console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
             // else the object is already where we want it to be
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    },
    remove: function() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_;
        for(let i354 = 0, n = arguments.length; i354 !== n; ++i354){
            const object = arguments[i354], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== undefined && index >= nCachedObjects) {
                // move existing object into the CACHED region
                const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                indicesByUUID[firstActiveObject.uuid] = index;
                objects[index] = firstActiveObject;
                indicesByUUID[uuid] = lastCachedIndex;
                objects[lastCachedIndex] = object;
                // accounting is done, now do the same for all bindings
                for(let j = 0, m = nBindings; j !== m; ++j){
                    const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                    bindingsForPath[index] = firstActive;
                    bindingsForPath[lastCachedIndex] = binding;
                }
            }
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    },
    // remove & forget
    uncache: function() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
        for(let i355 = 0, n = arguments.length; i355 !== n; ++i355){
            const object = arguments[i355], uuid = object.uuid, index = indicesByUUID[uuid];
            if (index !== undefined) {
                delete indicesByUUID[uuid];
                if (index < nCachedObjects) {
                    // object is cached, shrink the CACHED region
                    const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                    // last cached object takes this object's place
                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;
                    // last object goes to the activated slot and pop
                    indicesByUUID[lastObject.uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for(let j = 0, m = nBindings; j !== m; ++j){
                        const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                        bindingsForPath[index] = lastCached;
                        bindingsForPath[firstActiveIndex] = last;
                        bindingsForPath.pop();
                    }
                } else {
                    // object is active, just swap with the last and pop
                    const lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastObject.uuid] = index;
                    objects[index] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for(let j = 0, m = nBindings; j !== m; ++j){
                        const bindingsForPath = bindings[j];
                        bindingsForPath[index] = bindingsForPath[lastIndex];
                        bindingsForPath.pop();
                    }
                } // cached or active
            } // if object is known
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    },
    // Internal interface used by befriended PropertyBinding.Composite:
    subscribe_: function(path, parsedPath) {
        // returns an array of bindings for the given path that is changed
        // according to the contained objects in the group
        let indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
        if (index !== undefined) return bindings[index];
        const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index = bindings.length;
        indicesByPath[path] = index;
        paths.push(path);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for(let i356 = nCachedObjects, n = objects.length; i356 !== n; ++i356){
            const object = objects[i356];
            bindingsForPath[i356] = new PropertyBinding(object, path, parsedPath);
        }
        return bindingsForPath;
    },
    unsubscribe_: function(path) {
        // tells the group to forget about a property path and no longer
        // update the array previously obtained with 'subscribe_'
        const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
        if (index !== undefined) {
            const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index;
            bindings[index] = lastBindings;
            bindings.pop();
            parsedPaths[index] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index] = paths[lastBindingsIndex];
            paths.pop();
        }
    }
});
/**
 *
 * Action provided by AnimationMixer for scheduling clip playback on specific
 * objects.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 *
 */ function AnimationAction(mixer, clip, localRoot, blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot || null;
    this.blendMode = blendMode || clip.blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
    };
    for(let i357 = 0; i357 !== nTracks; ++i357){
        const interpolant = tracks[i357].createInterpolant(null);
        interpolants[i357] = interpolant;
        interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants; // bound by the mixer
    // inside: PropertyMixer (managed by the mixer)
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null; // for the memory manager
    this._byClipCacheIndex = null; // for the memory manager
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    // global mixer time when the action is to be started
    // it's set back to 'null' upon start of the action
    this._startTime = null;
    // scaled local time of the action
    // gets clamped or wrapped to 0..clip.duration according to loop
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity; // no. of repetitions when looping
    this.paused = false; // true -> zero effective time scale
    this.enabled = true; // false -> zero effective weight
    this.clampWhenFinished = false; // keep feeding the last frame?
    this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
    this.zeroSlopeAtEnd = true; // clips for start, loop and end
}
Object.assign(AnimationAction.prototype, {
    // State & Scheduling
    play: function() {
        this._mixer._activateAction(this);
        return this;
    },
    stop: function() {
        this._mixer._deactivateAction(this);
        return this.reset();
    },
    reset: function() {
        this.paused = false;
        this.enabled = true;
        this.time = 0; // restart clip
        this._loopCount = -1; // forget previous loops
        this._startTime = null; // forget scheduling
        return this.stopFading().stopWarping();
    },
    isRunning: function() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    },
    // return true when play has been called
    isScheduled: function() {
        return this._mixer._isActiveAction(this);
    },
    startAt: function(time) {
        this._startTime = time;
        return this;
    },
    setLoop: function(mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
    },
    // Weight
    // set the weight stopping any scheduled fading
    // although .enabled = false yields an effective weight of zero, this
    // method does *not* change .enabled, because it would be confusing
    setEffectiveWeight: function(weight) {
        this.weight = weight;
        // note: same logic as when updated at runtime
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
    },
    // return the weight considering fading and .enabled
    getEffectiveWeight: function() {
        return this._effectiveWeight;
    },
    fadeIn: function(duration) {
        return this._scheduleFading(duration, 0, 1);
    },
    fadeOut: function(duration) {
        return this._scheduleFading(duration, 1, 0);
    },
    crossFadeFrom: function(fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
            const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1, startEndRatio, duration);
            this.warp(endStartRatio, 1, duration);
        }
        return this;
    },
    crossFadeTo: function(fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
    },
    stopFading: function() {
        let weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
    },
    // Time Scale Control
    // set the time scale stopping any scheduled warping
    // although .paused = true yields an effective time scale of zero, this
    // method does *not* change .paused, because it would be confusing
    setEffectiveTimeScale: function(timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
    },
    // return the time scale considering warping and .paused
    getEffectiveTimeScale: function() {
        return this._effectiveTimeScale;
    },
    setDuration: function(duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
    },
    syncWith: function(action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
    },
    halt: function(duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
    },
    warp: function(startTimeScale, endTimeScale, duration) {
        const mixer = this._mixer, now = mixer.time, timeScale = this.timeScale;
        let interpolant = this._timeScaleInterpolant;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        times[1] = now + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
    },
    stopWarping: function() {
        let timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
    },
    // Object Accessors
    getMixer: function() {
        return this._mixer;
    },
    getClip: function() {
        return this._clip;
    },
    getRoot: function() {
        return this._localRoot || this._mixer._root;
    },
    // Interna
    _update: function(time, deltaTime, timeDirection, accuIndex) {
        // called by the mixer
        if (!this.enabled) {
            // call ._updateWeight() to update ._effectiveWeight
            this._updateWeight(time);
            return;
        }
        const startTime = this._startTime;
        if (startTime !== null) {
            // check for scheduled start of action
            const timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) return; // yet to come / don't decide when delta = 0
            // start
            this._startTime = null; // unschedule
            deltaTime = timeDirection * timeRunning;
        }
        // apply time scale and advance time
        deltaTime *= this._updateTimeScale(time);
        const clipTime = this._updateTime(deltaTime);
        // note: _updateTime may disable the action resulting in
        // an effective weight of 0
        const weight = this._updateWeight(time);
        if (weight > 0) {
            const interpolants = this._interpolants;
            const propertyMixers = this._propertyBindings;
            switch(this.blendMode){
                case AdditiveAnimationBlendMode:
                    for(let j = 0, m = interpolants.length; j !== m; ++j){
                        interpolants[j].evaluate(clipTime);
                        propertyMixers[j].accumulateAdditive(weight);
                    }
                    break;
                case NormalAnimationBlendMode:
                default:
                    for(let j7 = 0, m1 = interpolants.length; j7 !== m1; ++j7){
                        interpolants[j7].evaluate(clipTime);
                        propertyMixers[j7].accumulate(accuIndex, weight);
                    }
            }
        }
    },
    _updateWeight: function(time) {
        let weight = 0;
        if (this.enabled) {
            weight = this.weight;
            const interpolant = this._weightInterpolant;
            if (interpolant !== null) {
                const interpolantValue = interpolant.evaluate(time)[0];
                weight *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopFading();
                    if (interpolantValue === 0) // faded out, disable
                    this.enabled = false;
                }
            }
        }
        this._effectiveWeight = weight;
        return weight;
    },
    _updateTimeScale: function(time) {
        let timeScale = 0;
        if (!this.paused) {
            timeScale = this.timeScale;
            const interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
                const interpolantValue = interpolant.evaluate(time)[0];
                timeScale *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopWarping();
                    if (timeScale === 0) // motion has halted, pause
                    this.paused = true;
                    else // warp done - apply final time scale
                    this.timeScale = timeScale;
                }
            }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
    },
    _updateTime: function(deltaTime) {
        const duration = this._clip.duration;
        const loop = this.loop;
        let time = this.time + deltaTime;
        let loopCount = this._loopCount;
        const pingPong = loop === LoopPingPong;
        if (deltaTime === 0) {
            if (loopCount === -1) return time;
            return pingPong && (loopCount & 1) === 1 ? duration - time : time;
        }
        if (loop === LoopOnce) {
            if (loopCount === -1) {
                // just started
                this._loopCount = 0;
                this._setEndings(true, true, false);
            }
            handle_stop: {
                if (time >= duration) time = duration;
                else if (time < 0) time = 0;
                else {
                    this.time = time;
                    break handle_stop;
                }
                if (this.clampWhenFinished) this.paused = true;
                else this.enabled = false;
                this.time = time;
                this._mixer.dispatchEvent({
                    type: 'finished',
                    action: this,
                    direction: deltaTime < 0 ? -1 : 1
                });
            }
        } else {
            if (loopCount === -1) {
                // just started
                if (deltaTime >= 0) {
                    loopCount = 0;
                    this._setEndings(true, this.repetitions === 0, pingPong);
                } else // when looping in reverse direction, the initial
                // transition through zero counts as a repetition,
                // so leave loopCount at -1
                this._setEndings(this.repetitions === 0, true, pingPong);
            }
            if (time >= duration || time < 0) {
                // wrap around
                const loopDelta = Math.floor(time / duration); // signed
                time -= duration * loopDelta;
                loopCount += Math.abs(loopDelta);
                const pending = this.repetitions - loopCount;
                if (pending <= 0) {
                    // have to stop (switch state, clamp time, fire event)
                    if (this.clampWhenFinished) this.paused = true;
                    else this.enabled = false;
                    time = deltaTime > 0 ? duration : 0;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: 'finished',
                        action: this,
                        direction: deltaTime > 0 ? 1 : -1
                    });
                } else {
                    // keep running
                    if (pending === 1) {
                        // entering the last round
                        const atStart = deltaTime < 0;
                        this._setEndings(atStart, !atStart, pingPong);
                    } else this._setEndings(false, false, pingPong);
                    this._loopCount = loopCount;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: 'loop',
                        action: this,
                        loopDelta: loopDelta
                    });
                }
            } else this.time = time;
            if (pingPong && (loopCount & 1) === 1) // invert time for the "pong round"
            return duration - time;
        }
        return time;
    },
    _setEndings: function(atStart, atEnd, pingPong) {
        const settings = this._interpolantSettings;
        if (pingPong) {
            settings.endingStart = ZeroSlopeEnding;
            settings.endingEnd = ZeroSlopeEnding;
        } else {
            // assuming for LoopOnce atStart == atEnd == true
            if (atStart) settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
            else settings.endingStart = WrapAroundEnding;
            if (atEnd) settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
            else settings.endingEnd = WrapAroundEnding;
        }
    },
    _scheduleFading: function(duration, weightNow, weightThen) {
        const mixer = this._mixer, now = mixer.time;
        let interpolant = this._weightInterpolant;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._weightInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        values[0] = weightNow;
        times[1] = now + duration;
        values[1] = weightThen;
        return this;
    }
});
/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ function AnimationMixer(root) {
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
}
AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: AnimationMixer,
    _bindAction: function(action, prototypeAction) {
        const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
        let bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === undefined) {
            bindingsByName = {};
            bindingsByRoot[rootUuid] = bindingsByName;
        }
        for(let i358 = 0; i358 !== nTracks; ++i358){
            const track = tracks[i358], trackName = track.name;
            let binding = bindingsByName[trackName];
            if (binding !== undefined) bindings[i358] = binding;
            else {
                binding = bindings[i358];
                if (binding !== undefined) {
                    // existing binding, make sure the cache knows
                    if (binding._cacheIndex === null) {
                        ++binding.referenceCount;
                        this._addInactiveBinding(binding, rootUuid, trackName);
                    }
                    continue;
                }
                const path = prototypeAction && prototypeAction._propertyBindings[i358].binding.parsedPath;
                binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
                bindings[i358] = binding;
            }
            interpolants[i358].resultBuffer = binding.buffer;
        }
    },
    _activateAction: function(action) {
        if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
                // this action has been forgotten by the cache, but the user
                // appears to be still using it -> rebind
                const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                this._addInactiveAction(action, clipUuid, rootUuid);
            }
            const bindings = action._propertyBindings;
            // increment reference counts / sort out state
            for(let i359 = 0, n = bindings.length; i359 !== n; ++i359){
                const binding = bindings[i359];
                if ((binding.useCount++) === 0) {
                    this._lendBinding(binding);
                    binding.saveOriginalState();
                }
            }
            this._lendAction(action);
        }
    },
    _deactivateAction: function(action) {
        if (this._isActiveAction(action)) {
            const bindings = action._propertyBindings;
            // decrement reference counts / sort out state
            for(let i360 = 0, n = bindings.length; i360 !== n; ++i360){
                const binding = bindings[i360];
                if (--binding.useCount === 0) {
                    binding.restoreOriginalState();
                    this._takeBackBinding(binding);
                }
            }
            this._takeBackAction(action);
        }
    },
    // Memory manager
    _initMemoryManager: function() {
        this._actions = []; // 'nActiveActions' followed by inactive ones
        this._nActiveActions = 0;
        this._actionsByClip = {};
        // inside:
        // {
        // 	knownActions: Array< AnimationAction > - used as prototypes
        // 	actionByRoot: AnimationAction - lookup
        // }
        this._bindings = []; // 'nActiveBindings' followed by inactive ones
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
        this._controlInterpolants = []; // same game as above
        this._nActiveControlInterpolants = 0;
        const scope = this;
        this.stats = {
            actions: {
                get total () {
                    return scope._actions.length;
                },
                get inUse () {
                    return scope._nActiveActions;
                }
            },
            bindings: {
                get total () {
                    return scope._bindings.length;
                },
                get inUse () {
                    return scope._nActiveBindings;
                }
            },
            controlInterpolants: {
                get total () {
                    return scope._controlInterpolants.length;
                },
                get inUse () {
                    return scope._nActiveControlInterpolants;
                }
            }
        };
    },
    // Memory management for AnimationAction objects
    _isActiveAction: function(action) {
        const index = action._cacheIndex;
        return index !== null && index < this._nActiveActions;
    },
    _addInactiveAction: function(action, clipUuid, rootUuid) {
        const actions = this._actions, actionsByClip = this._actionsByClip;
        let actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === undefined) {
            actionsForClip = {
                knownActions: [
                    action
                ],
                actionByRoot: {}
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
        } else {
            const knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
    },
    _removeInactiveAction: function(action) {
        const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) delete actionsByClip[clipUuid];
        this._removeInactiveBindingsForAction(action);
    },
    _removeInactiveBindingsForAction: function(action) {
        const bindings = action._propertyBindings;
        for(let i361 = 0, n = bindings.length; i361 !== n; ++i361){
            const binding = bindings[i361];
            if (--binding.referenceCount === 0) this._removeInactiveBinding(binding);
        }
    },
    _lendAction: function(action) {
        // [ active actions |  inactive actions  ]
        // [  active actions >| inactive actions ]
        //                 s        a
        //                  <-swap->
        //                 a        s
        const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
    },
    _takeBackAction: function(action) {
        // [  active actions  | inactive actions ]
        // [ active actions |< inactive actions  ]
        //        a        s
        //         <-swap->
        //        s        a
        const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
    },
    // Memory management for PropertyMixer objects
    _addInactiveBinding: function(binding, rootUuid, trackName) {
        const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
        let bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName === undefined) {
            bindingByName = {};
            bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
    },
    _removeInactiveBinding: function(binding) {
        const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        if (Object.keys(bindingByName).length === 0) delete bindingsByRoot[rootUuid];
    },
    _lendBinding: function(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
    },
    _takeBackBinding: function(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
    },
    // Memory management of Interpolants for weight and time scale
    _lendControlInterpolant: function() {
        const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
        let interpolant = interpolants[lastActiveIndex];
        if (interpolant === undefined) {
            interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants[lastActiveIndex] = interpolant;
        }
        return interpolant;
    },
    _takeBackControlInterpolant: function(interpolant) {
        const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants[prevIndex] = lastActiveInterpolant;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    // return an action for a clip optionally using a custom root target
    // object (this method allocates a lot of dynamic memory in case a
    // previously unknown clip/root combination is specified)
    clipAction: function(clip, optionalRoot, blendMode) {
        const root = optionalRoot || this._root, rootUuid = root.uuid;
        let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
        const clipUuid = clipObject !== null ? clipObject.uuid : clip;
        let actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
        if (blendMode === undefined) {
            if (clipObject !== null) blendMode = clipObject.blendMode;
            else blendMode = NormalAnimationBlendMode;
        }
        if (actionsForClip !== undefined) {
            const existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== undefined && existingAction.blendMode === blendMode) return existingAction;
            // we know the clip, so we don't have to parse all
            // the bindings again but can just copy
            prototypeAction = actionsForClip.knownActions[0];
            // also, take the clip from the prototype action
            if (clipObject === null) clipObject = prototypeAction._clip;
        }
        // clip must be known when specified via string
        if (clipObject === null) return null;
        // allocate all resources required to run it
        const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
        this._bindAction(newAction, prototypeAction);
        // and make the action known to the memory manager
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
    },
    // get an existing action
    existingAction: function(clip, optionalRoot) {
        const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== undefined) return actionsForClip.actionByRoot[rootUuid] || null;
        return null;
    },
    // deactivates all previously scheduled actions
    stopAllAction: function() {
        const actions = this._actions, nActions = this._nActiveActions;
        for(let i362 = nActions - 1; i362 >= 0; --i362)actions[i362].stop();
        return this;
    },
    // advance the time and update apply the animation
    update: function(deltaTime) {
        deltaTime *= this.timeScale;
        const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
        // run active actions
        for(let i364 = 0; i364 !== nActions; ++i364){
            const action = actions[i364];
            action._update(time, deltaTime, timeDirection, accuIndex);
        }
        // update scene graph
        const bindings = this._bindings, nBindings = this._nActiveBindings;
        for(let i363 = 0; i363 !== nBindings; ++i363)bindings[i363].apply(accuIndex);
        return this;
    },
    // Allows you to seek to a specific time in an animation.
    setTime: function(timeInSeconds) {
        this.time = 0; // Zero out time attribute for AnimationMixer object;
        for(let i365 = 0; i365 < this._actions.length; i365++)this._actions[i365].time = 0; // Zero out time attribute for all associated AnimationAction objects.
        return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
    },
    // return this mixer's root target object
    getRoot: function() {
        return this._root;
    },
    // free all resources specific to a particular clip
    uncacheClip: function(clip) {
        const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== undefined) {
            // note: just calling _removeInactiveAction would mess up the
            // iteration state and also require updating the state we can
            // just throw away
            const actionsToRemove = actionsForClip.knownActions;
            for(let i366 = 0, n = actionsToRemove.length; i366 !== n; ++i366){
                const action = actionsToRemove[i366];
                this._deactivateAction(action);
                const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                action._cacheIndex = null;
                action._byClipCacheIndex = null;
                lastInactiveAction._cacheIndex = cacheIndex;
                actions[cacheIndex] = lastInactiveAction;
                actions.pop();
                this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
        }
    },
    // free all resources specific to a particular root target object
    uncacheRoot: function(root) {
        const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for(const clipUuid in actionsByClip){
            const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== undefined) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
        const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== undefined) for(const trackName in bindingByName){
            const binding = bindingByName[trackName];
            binding.restoreOriginalState();
            this._removeInactiveBinding(binding);
        }
    },
    // remove a targeted clip from the cache
    uncacheAction: function(clip, optionalRoot) {
        const action = this.existingAction(clip, optionalRoot);
        if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
        }
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */ function Uniform(value) {
    if (typeof value === 'string') {
        console.warn('THREE.Uniform: Type parameter is no longer needed.');
        value = arguments[1];
    }
    this.value = value;
}
Uniform.prototype.clone = function() {
    return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
};
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */ function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
    InterleavedBuffer.call(this, array, stride);
    this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
    constructor: InstancedInterleavedBuffer,
    isInstancedInterleavedBuffer: true,
    copy: function(source) {
        InterleavedBuffer.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    },
    clone: function(data) {
        const ib = InterleavedBuffer.prototype.clone.call(this, data);
        ib.meshPerAttribute = this.meshPerAttribute;
        return ib;
    },
    toJSON: function(data) {
        const json = InterleavedBuffer.prototype.toJSON.call(this, data);
        json.isInstancedInterleavedBuffer = true;
        json.meshPerAttribute = this.meshPerAttribute;
        return json;
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */ function Raycaster(origin, direction, near, far) {
    this.ray = new Ray(origin, direction);
    // direction is assumed to be normalized (for accurate distance calculations)
    this.near = near || 0;
    this.far = far || Infinity;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
        Mesh: {},
        Line: {
            threshold: 1
        },
        LOD: {},
        Points: {
            threshold: 1
        },
        Sprite: {}
    };
    Object.defineProperties(this.params, {
        PointCloud: {
            get: function() {
                console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
                return this.Points;
            }
        }
    });
}
function ascSort(a, b) {
    return a.distance - b.distance;
}
function intersectObject(object, raycaster, intersects8, recursive) {
    if (object.layers.test(raycaster.layers)) object.raycast(raycaster, intersects8);
    if (recursive === true) {
        const children = object.children;
        for(let i367 = 0, l = children.length; i367 < l; i367++)intersectObject(children[i367], raycaster, intersects8, true);
    }
}
Object.assign(Raycaster.prototype, {
    set: function(origin, direction) {
        // direction is assumed to be normalized (for accurate distance calculations)
        this.ray.set(origin, direction);
    },
    setFromCamera: function(coords, camera) {
        if (camera && camera.isPerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            this.camera = camera;
        } else if (camera && camera.isOrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            this.camera = camera;
        } else console.error('THREE.Raycaster: Unsupported camera type.');
    },
    intersectObject: function(object, recursive, optionalTarget) {
        const intersects9 = optionalTarget || [];
        intersectObject(object, this, intersects9, recursive);
        intersects9.sort(ascSort);
        return intersects9;
    },
    intersectObjects: function(objects, recursive, optionalTarget) {
        const intersects10 = optionalTarget || [];
        if (Array.isArray(objects) === false) {
            console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
            return intersects10;
        }
        for(let i368 = 0, l = objects.length; i368 < l; i368++)intersectObject(objects[i368], this, intersects10, recursive);
        intersects10.sort(ascSort);
        return intersects10;
    }
});
/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */ function Spherical(radius, phi, theta) {
    this.radius = radius !== undefined ? radius : 1;
    this.phi = phi !== undefined ? phi : 0; // polar angle
    this.theta = theta !== undefined ? theta : 0; // azimuthal angle
    return this;
}
Object.assign(Spherical.prototype, {
    set: function(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
    },
    // restrict phi to be betwee EPS and PI-EPS
    makeSafe: function() {
        const EPS = 0.000001;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
    },
    setFromVector3: function(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
    },
    setFromCartesianCoords: function(x, y, z) {
        this.radius = Math.sqrt(x * x + y * y + z * z);
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        } else {
            this.theta = Math.atan2(x, z);
            this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));
        }
        return this;
    }
});
/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 *
 */ function Cylindrical(radius, theta, y) {
    this.radius = radius !== undefined ? radius : 1; // distance from the origin to a point in the x-z plane
    this.theta = theta !== undefined ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
    this.y = y !== undefined ? y : 0; // height above the x-z plane
    return this;
}
Object.assign(Cylindrical.prototype, {
    set: function(radius, theta, y) {
        this.radius = radius;
        this.theta = theta;
        this.y = y;
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(other) {
        this.radius = other.radius;
        this.theta = other.theta;
        this.y = other.y;
        return this;
    },
    setFromVector3: function(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
    },
    setFromCartesianCoords: function(x, y, z) {
        this.radius = Math.sqrt(x * x + z * z);
        this.theta = Math.atan2(x, z);
        this.y = y;
        return this;
    }
});
/**
 * @author bhouston / http://clara.io
 */ const _vector$7 = new Vector2();
function Box2(min, max) {
    this.min = min !== undefined ? min : new Vector2(Infinity, Infinity);
    this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
}
Object.assign(Box2.prototype, {
    set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    },
    setFromPoints: function(points) {
        this.makeEmpty();
        for(let i369 = 0, il = points.length; i369 < il; i369++)this.expandByPoint(points[i369]);
        return this;
    },
    setFromCenterAndSize: function(center, size) {
        const halfSize = _vector$7.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    },
    makeEmpty: function() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
    },
    isEmpty: function() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    getCenter: function(target) {
        if (target === undefined) {
            console.warn('THREE.Box2: .getCenter() target is now required');
            target = new Vector2();
        }
        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(target) {
        if (target === undefined) {
            console.warn('THREE.Box2: .getSize() target is now required');
            target = new Vector2();
        }
        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    },
    expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    },
    expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    },
    expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    },
    containsPoint: function(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    },
    containsBox: function(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    },
    getParameter: function(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        if (target === undefined) {
            console.warn('THREE.Box2: .getParameter() target is now required');
            target = new Vector2();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    },
    intersectsBox: function(box) {
        // using 4 splitting planes to rule out intersections
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    },
    clampPoint: function(point, target) {
        if (target === undefined) {
            console.warn('THREE.Box2: .clampPoint() target is now required');
            target = new Vector2();
        }
        return target.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function(point) {
        const clampedPoint = _vector$7.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    },
    intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
    },
    union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    },
    translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    },
    equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
});
/**
 * @author bhouston / http://clara.io
 */ const _startP = new Vector3();
const _startEnd = new Vector3();
function Line3(start, end) {
    this.start = start !== undefined ? start : new Vector3();
    this.end = end !== undefined ? end : new Vector3();
}
Object.assign(Line3.prototype, {
    set: function(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
    },
    getCenter: function(target) {
        if (target === undefined) {
            console.warn('THREE.Line3: .getCenter() target is now required');
            target = new Vector3();
        }
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    },
    delta: function(target) {
        if (target === undefined) {
            console.warn('THREE.Line3: .delta() target is now required');
            target = new Vector3();
        }
        return target.subVectors(this.end, this.start);
    },
    distanceSq: function() {
        return this.start.distanceToSquared(this.end);
    },
    distance: function() {
        return this.start.distanceTo(this.end);
    },
    at: function(t, target) {
        if (target === undefined) {
            console.warn('THREE.Line3: .at() target is now required');
            target = new Vector3();
        }
        return this.delta(target).multiplyScalar(t).add(this.start);
    },
    closestPointToPointParameter: function(point, clampToLine) {
        _startP.subVectors(point, this.start);
        _startEnd.subVectors(this.end, this.start);
        const startEnd2 = _startEnd.dot(_startEnd);
        const startEnd_startP = _startEnd.dot(_startP);
        let t = startEnd_startP / startEnd2;
        if (clampToLine) t = MathUtils.clamp(t, 0, 1);
        return t;
    },
    closestPointToPoint: function(point, clampToLine, target) {
        const t = this.closestPointToPointParameter(point, clampToLine);
        if (target === undefined) {
            console.warn('THREE.Line3: .closestPointToPoint() target is now required');
            target = new Vector3();
        }
        return this.delta(target).multiplyScalar(t).add(this.start);
    },
    applyMatrix4: function(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
    },
    equals: function(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
    }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */ function ImmediateRenderObject(material) {
    Object3D.call(this);
    this.material = material;
    this.render = function() {};
    this.hasPositions = false;
    this.hasNormals = false;
    this.hasColors = false;
    this.hasUvs = false;
    this.positionArray = null;
    this.normalArray = null;
    this.colorArray = null;
    this.uvArray = null;
    this.count = 0;
}
ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */ const _vector$8 = new Vector3();
function SpotLightHelper(light, color) {
    Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    const geometry = new BufferGeometry();
    const positions = [
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        1,
        0,
        0,
        0,
        0,
        -1,
        1
    ];
    for(let i370 = 0, j = 1, l = 32; i370 < l; i370++, j++){
        const p1 = i370 / l * Math.PI * 2;
        const p2 = j / l * Math.PI * 2;
        positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
    }
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    const material = new LineBasicMaterial({
        fog: false,
        toneMapped: false
    });
    this.cone = new LineSegments(geometry, material);
    this.add(this.cone);
    this.update();
}
SpotLightHelper.prototype = Object.create(Object3D.prototype);
SpotLightHelper.prototype.constructor = SpotLightHelper;
SpotLightHelper.prototype.dispose = function() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
};
SpotLightHelper.prototype.update = function() {
    this.light.updateMatrixWorld();
    const coneLength = this.light.distance ? this.light.distance : 1000;
    const coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    _vector$8.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(_vector$8);
    if (this.color !== undefined) this.cone.material.color.set(this.color);
    else this.cone.material.color.copy(this.light.color);
};
/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 * @author Mugen87 / https://github.com/Mugen87
 */ const _vector$9 = new Vector3();
const _boneMatrix = new Matrix4();
const _matrixWorldInv = new Matrix4();
function getBoneList(object) {
    const boneList = [];
    if (object && object.isBone) boneList.push(object);
    for(let i371 = 0; i371 < object.children.length; i371++)boneList.push.apply(boneList, getBoneList(object.children[i371]));
    return boneList;
}
function SkeletonHelper(object) {
    const bones = getBoneList(object);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);
    for(let i372 = 0; i372 < bones.length; i372++){
        const bone = bones[i372];
        if (bone.parent && bone.parent.isBone) {
            vertices.push(0, 0, 0);
            vertices.push(0, 0, 0);
            colors.push(color1.r, color1.g, color1.b);
            colors.push(color2.r, color2.g, color2.b);
        }
    }
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
        vertexColors: true,
        depthTest: false,
        depthWrite: false,
        toneMapped: false,
        transparent: true
    });
    LineSegments.call(this, geometry, material);
    this.type = 'SkeletonHelper';
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
}
SkeletonHelper.prototype = Object.create(LineSegments.prototype);
SkeletonHelper.prototype.constructor = SkeletonHelper;
SkeletonHelper.prototype.isSkeletonHelper = true;
SkeletonHelper.prototype.updateMatrixWorld = function(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position = geometry.getAttribute('position');
    _matrixWorldInv.getInverse(this.root.matrixWorld);
    for(let i373 = 0, j = 0; i373 < bones.length; i373++){
        const bone = bones[i373];
        if (bone.parent && bone.parent.isBone) {
            _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
            _vector$9.setFromMatrixPosition(_boneMatrix);
            position.setXYZ(j, _vector$9.x, _vector$9.y, _vector$9.z);
            _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
            _vector$9.setFromMatrixPosition(_boneMatrix);
            position.setXYZ(j + 1, _vector$9.x, _vector$9.y, _vector$9.z);
            j += 2;
        }
    }
    geometry.getAttribute('position').needsUpdate = true;
    Object3D.prototype.updateMatrixWorld.call(this, force);
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */ function PointLightHelper(light, sphereSize, color) {
    this.light = light;
    this.light.updateMatrixWorld();
    this.color = color;
    const geometry = new SphereBufferGeometry(sphereSize, 4, 2);
    const material = new MeshBasicMaterial({
        wireframe: true,
        fog: false,
        toneMapped: false
    });
    Mesh.call(this, geometry, material);
    this.type = 'PointLightHelper';
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
/*
	const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/ }
PointLightHelper.prototype = Object.create(Mesh.prototype);
PointLightHelper.prototype.constructor = PointLightHelper;
PointLightHelper.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose();
};
PointLightHelper.prototype.update = function() {
    if (this.color !== undefined) this.material.color.set(this.color);
    else this.material.color.copy(this.light.color);
/*
	const d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/ };
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ const _vector$a = new Vector3();
const _color1 = new Color();
const _color2 = new Color();
function HemisphereLightHelper(light, size, color) {
    Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    const geometry = new OctahedronBufferGeometry(size);
    geometry.rotateY(Math.PI * 0.5);
    this.material = new MeshBasicMaterial({
        wireframe: true,
        fog: false,
        toneMapped: false
    });
    if (this.color === undefined) this.material.vertexColors = true;
    const position = geometry.getAttribute('position');
    const colors = new Float32Array(position.count * 3);
    geometry.setAttribute('color', new BufferAttribute(colors, 3));
    this.add(new Mesh(geometry, this.material));
    this.update();
}
HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
HemisphereLightHelper.prototype.dispose = function() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
};
HemisphereLightHelper.prototype.update = function() {
    const mesh = this.children[0];
    if (this.color !== undefined) this.material.color.set(this.color);
    else {
        const colors = mesh.geometry.getAttribute('color');
        _color1.copy(this.light.color);
        _color2.copy(this.light.groundColor);
        for(let i374 = 0, l = colors.count; i374 < l; i374++){
            const color = i374 < l / 2 ? _color1 : _color2;
            colors.setXYZ(i374, color.r, color.g, color.b);
        }
        colors.needsUpdate = true;
    }
    mesh.lookAt(_vector$a.setFromMatrixPosition(this.light.matrixWorld).negate());
};
/**
 * @author mrdoob / http://mrdoob.com/
 */ function GridHelper(size, divisions, color1, color2) {
    size = size || 10;
    divisions = divisions || 10;
    color1 = new Color(color1 !== undefined ? color1 : 4473924);
    color2 = new Color(color2 !== undefined ? color2 : 8947848);
    const center = divisions / 2;
    const step = size / divisions;
    const halfSize = size / 2;
    const vertices = [], colors = [];
    for(let i375 = 0, j = 0, k = -halfSize; i375 <= divisions; i375++, k += step){
        vertices.push(-halfSize, 0, k, halfSize, 0, k);
        vertices.push(k, 0, -halfSize, k, 0, halfSize);
        const color = i375 === center ? color1 : color2;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
        vertexColors: true,
        toneMapped: false
    });
    LineSegments.call(this, geometry, material);
    this.type = 'GridHelper';
}
GridHelper.prototype = Object.assign(Object.create(LineSegments.prototype), {
    constructor: GridHelper,
    copy: function(source) {
        LineSegments.prototype.copy.call(this, source);
        this.geometry.copy(source.geometry);
        this.material.copy(source.material);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 * @author Hectate / http://www.github.com/Hectate
 */ function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
    radius = radius || 10;
    radials = radials || 16;
    circles = circles || 8;
    divisions = divisions || 64;
    color1 = new Color(color1 !== undefined ? color1 : 4473924);
    color2 = new Color(color2 !== undefined ? color2 : 8947848);
    const vertices = [];
    const colors = [];
    // create the radials
    for(let i377 = 0; i377 <= radials; i377++){
        const v = i377 / radials * (Math.PI * 2);
        const x = Math.sin(v) * radius;
        const z = Math.cos(v) * radius;
        vertices.push(0, 0, 0);
        vertices.push(x, 0, z);
        const color = i377 & 1 ? color1 : color2;
        colors.push(color.r, color.g, color.b);
        colors.push(color.r, color.g, color.b);
    }
    // create the circles
    for(let i376 = 0; i376 <= circles; i376++){
        const color = i376 & 1 ? color1 : color2;
        const r = radius - radius / circles * i376;
        for(let j = 0; j < divisions; j++){
            // first vertex
            let v = j / divisions * (Math.PI * 2);
            let x = Math.sin(v) * r;
            let z = Math.cos(v) * r;
            vertices.push(x, 0, z);
            colors.push(color.r, color.g, color.b);
            // second vertex
            v = (j + 1) / divisions * (Math.PI * 2);
            x = Math.sin(v) * r;
            z = Math.cos(v) * r;
            vertices.push(x, 0, z);
            colors.push(color.r, color.g, color.b);
        }
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
        vertexColors: true,
        toneMapped: false
    });
    LineSegments.call(this, geometry, material);
    this.type = 'PolarGridHelper';
}
PolarGridHelper.prototype = Object.create(LineSegments.prototype);
PolarGridHelper.prototype.constructor = PolarGridHelper;
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */ const _v1$5 = new Vector3();
const _v2$3 = new Vector3();
const _v3$1 = new Vector3();
function DirectionalLightHelper(light, size, color) {
    Object3D.call(this);
    this.light = light;
    this.light.updateMatrixWorld();
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    if (size === undefined) size = 1;
    let geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute([
        -size,
        size,
        0,
        size,
        size,
        0,
        size,
        -size,
        0,
        -size,
        -size,
        0,
        -size,
        size,
        0
    ], 3));
    const material = new LineBasicMaterial({
        fog: false,
        toneMapped: false
    });
    this.lightPlane = new Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute([
        0,
        0,
        0,
        0,
        0,
        1
    ], 3));
    this.targetLine = new Line(geometry, material);
    this.add(this.targetLine);
    this.update();
}
DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
DirectionalLightHelper.prototype.dispose = function() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
};
DirectionalLightHelper.prototype.update = function() {
    _v1$5.setFromMatrixPosition(this.light.matrixWorld);
    _v2$3.setFromMatrixPosition(this.light.target.matrixWorld);
    _v3$1.subVectors(_v2$3, _v1$5);
    this.lightPlane.lookAt(_v2$3);
    if (this.color !== undefined) {
        this.lightPlane.material.color.set(this.color);
        this.targetLine.material.color.set(this.color);
    } else {
        this.lightPlane.material.color.copy(this.light.color);
        this.targetLine.material.color.copy(this.light.color);
    }
    this.targetLine.lookAt(_v2$3);
    this.targetLine.scale.z = _v3$1.length();
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author Mugen87 / https://github.com/Mugen87
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */ const _vector$b = new Vector3();
const _camera = new Camera();
function CameraHelper(camera) {
    const geometry = new BufferGeometry();
    const material = new LineBasicMaterial({
        color: 16777215,
        vertexColors: true,
        toneMapped: false
    });
    const vertices = [];
    const colors = [];
    const pointMap = {};
    // colors
    const colorFrustum = new Color(16755200);
    const colorCone = new Color(16711680);
    const colorUp = new Color(43775);
    const colorTarget = new Color(16777215);
    const colorCross = new Color(3355443);
    // near
    addLine('n1', 'n2', colorFrustum);
    addLine('n2', 'n4', colorFrustum);
    addLine('n4', 'n3', colorFrustum);
    addLine('n3', 'n1', colorFrustum);
    // far
    addLine('f1', 'f2', colorFrustum);
    addLine('f2', 'f4', colorFrustum);
    addLine('f4', 'f3', colorFrustum);
    addLine('f3', 'f1', colorFrustum);
    // sides
    addLine('n1', 'f1', colorFrustum);
    addLine('n2', 'f2', colorFrustum);
    addLine('n3', 'f3', colorFrustum);
    addLine('n4', 'f4', colorFrustum);
    // cone
    addLine('p', 'n1', colorCone);
    addLine('p', 'n2', colorCone);
    addLine('p', 'n3', colorCone);
    addLine('p', 'n4', colorCone);
    // up
    addLine('u1', 'u2', colorUp);
    addLine('u2', 'u3', colorUp);
    addLine('u3', 'u1', colorUp);
    // target
    addLine('c', 't', colorTarget);
    addLine('p', 'c', colorCross);
    // cross
    addLine('cn1', 'cn2', colorCross);
    addLine('cn3', 'cn4', colorCross);
    addLine('cf1', 'cf2', colorCross);
    addLine('cf3', 'cf4', colorCross);
    function addLine(a, b, color) {
        addPoint(a, color);
        addPoint(b, color);
    }
    function addPoint(id, color) {
        vertices.push(0, 0, 0);
        colors.push(color.r, color.g, color.b);
        if (pointMap[id] === undefined) pointMap[id] = [];
        pointMap[id].push(vertices.length / 3 - 1);
    }
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    LineSegments.call(this, geometry, material);
    this.type = 'CameraHelper';
    this.camera = camera;
    if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
}
CameraHelper.prototype = Object.create(LineSegments.prototype);
CameraHelper.prototype.constructor = CameraHelper;
CameraHelper.prototype.update = function() {
    const geometry = this.geometry;
    const pointMap = this.pointMap;
    const w = 1, h = 1;
    // we need just camera projection matrix inverse
    // world matrix must be identity
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    // center / target
    setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
    setPoint('t', pointMap, geometry, _camera, 0, 0, 1);
    // near
    setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
    setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
    setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
    setPoint('n4', pointMap, geometry, _camera, w, h, -1);
    // far
    setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
    setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
    setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
    setPoint('f4', pointMap, geometry, _camera, w, h, 1);
    // up
    setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
    setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
    setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1);
    // cross
    setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
    setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
    setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
    setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
    setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
    setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
    setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
    setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
    geometry.getAttribute('position').needsUpdate = true;
};
function setPoint(point, pointMap, geometry, camera, x, y, z) {
    _vector$b.set(x, y, z).unproject(camera);
    const points = pointMap[point];
    if (points !== undefined) {
        const position = geometry.getAttribute('position');
        for(let i378 = 0, l = points.length; i378 < l; i378++)position.setXYZ(points[i378], _vector$b.x, _vector$b.y, _vector$b.z);
    }
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 */ const _box$3 = new Box3();
function BoxHelper(object, color) {
    this.object = object;
    if (color === undefined) color = 16776960;
    const indices = new Uint16Array([
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        0,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        4,
        0,
        4,
        1,
        5,
        2,
        6,
        3,
        7
    ]);
    const positions = new Float32Array(24);
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute('position', new BufferAttribute(positions, 3));
    LineSegments.call(this, geometry, new LineBasicMaterial({
        color: color,
        toneMapped: false
    }));
    this.type = 'BoxHelper';
    this.matrixAutoUpdate = false;
    this.update();
}
BoxHelper.prototype = Object.create(LineSegments.prototype);
BoxHelper.prototype.constructor = BoxHelper;
BoxHelper.prototype.update = function(object) {
    if (object !== undefined) console.warn('THREE.BoxHelper: .update() has no longer arguments.');
    if (this.object !== undefined) _box$3.setFromObject(this.object);
    if (_box$3.isEmpty()) return;
    const min = _box$3.min;
    const max = _box$3.max;
    /*
	  5____4
	1/___0/|
	| 6__|_7
	2/___3/

	0: max.x, max.y, max.z
	1: min.x, max.y, max.z
	2: min.x, min.y, max.z
	3: max.x, min.y, max.z
	4: max.x, max.y, min.z
	5: min.x, max.y, min.z
	6: min.x, min.y, min.z
	7: max.x, min.y, min.z
	*/ const position = this.geometry.attributes.position;
    const array = position.array;
    array[0] = max.x;
    array[1] = max.y;
    array[2] = max.z;
    array[3] = min.x;
    array[4] = max.y;
    array[5] = max.z;
    array[6] = min.x;
    array[7] = min.y;
    array[8] = max.z;
    array[9] = max.x;
    array[10] = min.y;
    array[11] = max.z;
    array[12] = max.x;
    array[13] = max.y;
    array[14] = min.z;
    array[15] = min.x;
    array[16] = max.y;
    array[17] = min.z;
    array[18] = min.x;
    array[19] = min.y;
    array[20] = min.z;
    array[21] = max.x;
    array[22] = min.y;
    array[23] = min.z;
    position.needsUpdate = true;
    this.geometry.computeBoundingSphere();
};
BoxHelper.prototype.setFromObject = function(object) {
    this.object = object;
    this.update();
    return this;
};
BoxHelper.prototype.copy = function(source) {
    LineSegments.prototype.copy.call(this, source);
    this.object = source.object;
    return this;
};
BoxHelper.prototype.clone = function() {
    return new this.constructor().copy(this);
};
/**
 * @author WestLangley / http://github.com/WestLangley
 */ function Box3Helper(box, color) {
    this.type = 'Box3Helper';
    this.box = box;
    color = color || 16776960;
    const indices = new Uint16Array([
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        0,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        4,
        0,
        4,
        1,
        5,
        2,
        6,
        3,
        7
    ]);
    const positions = [
        1,
        1,
        1,
        -1,
        1,
        1,
        -1,
        -1,
        1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1
    ];
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    LineSegments.call(this, geometry, new LineBasicMaterial({
        color: color,
        toneMapped: false
    }));
    this.type = 'Box3Helper';
    this.geometry.computeBoundingSphere();
}
Box3Helper.prototype = Object.create(LineSegments.prototype);
Box3Helper.prototype.constructor = Box3Helper;
Box3Helper.prototype.updateMatrixWorld = function(force) {
    const box = this.box;
    if (box.isEmpty()) return;
    box.getCenter(this.position);
    box.getSize(this.scale);
    this.scale.multiplyScalar(0.5);
    Object3D.prototype.updateMatrixWorld.call(this, force);
};
/**
 * @author WestLangley / http://github.com/WestLangley
 */ function PlaneHelper(plane, size, hex) {
    this.plane = plane;
    this.size = size === undefined ? 1 : size;
    const color = hex !== undefined ? hex : 16776960;
    const positions = [
        1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        1,
        -1,
        1,
        1,
        -1,
        -1,
        1,
        1,
        -1,
        1,
        1,
        1,
        1,
        0,
        0,
        1,
        0,
        0,
        0
    ];
    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    Line.call(this, geometry, new LineBasicMaterial({
        color: color,
        toneMapped: false
    }));
    this.type = 'PlaneHelper';
    //
    const positions2 = [
        1,
        1,
        1,
        -1,
        1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        1,
        -1,
        1
    ];
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();
    this.add(new Mesh(geometry2, new MeshBasicMaterial({
        color: color,
        opacity: 0.2,
        transparent: true,
        depthWrite: false,
        toneMapped: false
    })));
}
PlaneHelper.prototype = Object.create(Line.prototype);
PlaneHelper.prototype.constructor = PlaneHelper;
PlaneHelper.prototype.updateMatrixWorld = function(force) {
    let scale = -this.plane.constant;
    if (Math.abs(scale) < 0.00000001) scale = 0.00000001; // sign does not matter
    this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
    this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here
    this.lookAt(this.plane.normal);
    Object3D.prototype.updateMatrixWorld.call(this, force);
};
/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */ const _axis = new Vector3();
let _lineGeometry, _coneGeometry;
function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
    // dir is assumed to be normalized
    Object3D.call(this);
    this.type = 'ArrowHelper';
    if (dir === undefined) dir = new Vector3(0, 0, 1);
    if (origin === undefined) origin = new Vector3(0, 0, 0);
    if (length === undefined) length = 1;
    if (color === undefined) color = 16776960;
    if (headLength === undefined) headLength = 0.2 * length;
    if (headWidth === undefined) headWidth = 0.2 * headLength;
    if (_lineGeometry === undefined) {
        _lineGeometry = new BufferGeometry();
        _lineGeometry.setAttribute('position', new Float32BufferAttribute([
            0,
            0,
            0,
            0,
            1,
            0
        ], 3));
        _coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
        _coneGeometry.translate(0, -0.5, 0);
    }
    this.position.copy(origin);
    this.line = new Line(_lineGeometry, new LineBasicMaterial({
        color: color,
        toneMapped: false
    }));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
        color: color,
        toneMapped: false
    }));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length, headLength, headWidth);
}
ArrowHelper.prototype = Object.create(Object3D.prototype);
ArrowHelper.prototype.constructor = ArrowHelper;
ArrowHelper.prototype.setDirection = function(dir) {
    // dir is assumed to be normalized
    if (dir.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (dir.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
        _axis.set(dir.z, 0, -dir.x).normalize();
        const radians = Math.acos(dir.y);
        this.quaternion.setFromAxisAngle(_axis, radians);
    }
};
ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
    if (headLength === undefined) headLength = 0.2 * length;
    if (headWidth === undefined) headWidth = 0.2 * headLength;
    this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
};
ArrowHelper.prototype.setColor = function(color) {
    this.line.material.color.set(color);
    this.cone.material.color.set(color);
};
ArrowHelper.prototype.copy = function(source) {
    Object3D.prototype.copy.call(this, source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
};
ArrowHelper.prototype.clone = function() {
    return new this.constructor().copy(this);
};
/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */ function AxesHelper(size) {
    size = size || 1;
    const vertices = [
        0,
        0,
        0,
        size,
        0,
        0,
        0,
        0,
        0,
        0,
        size,
        0,
        0,
        0,
        0,
        0,
        0,
        size
    ];
    const colors = [
        1,
        0,
        0,
        1,
        0.6,
        0,
        0,
        1,
        0,
        0.6,
        1,
        0,
        0,
        0,
        1,
        0,
        0.6,
        1
    ];
    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({
        vertexColors: true,
        toneMapped: false
    });
    LineSegments.call(this, geometry, material);
    this.type = 'AxesHelper';
}
AxesHelper.prototype = Object.create(LineSegments.prototype);
AxesHelper.prototype.constructor = AxesHelper;
/**
 * @author Emmett Lalish / elalish
 *
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 */ const LOD_MIN = 4;
const LOD_MAX = 8;
const SIZE_MAX = Math.pow(2, LOD_MAX);
// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [
    0.125,
    0.215,
    0.35,
    0.446,
    0.526,
    0.582
];
const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;
const ENCODINGS = {
    [LinearEncoding]: 0,
    [sRGBEncoding]: 1,
    [RGBEEncoding]: 2,
    [RGBM7Encoding]: 3,
    [RGBM16Encoding]: 4,
    [RGBDEncoding]: 5,
    [GammaEncoding]: 6
};
const _flatCamera = new OrthographicCamera();
const { _lodPlanes , _sizeLods , _sigmas  } = _createPlanes();
let _oldTarget = null;
// Golden Ratio
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
    new Vector3(1, 1, 1),
    new Vector3(-1, 1, 1),
    new Vector3(1, 1, -1),
    new Vector3(-1, 1, -1),
    new Vector3(0, PHI, INV_PHI),
    new Vector3(0, PHI, -INV_PHI),
    new Vector3(INV_PHI, 0, PHI),
    new Vector3(-INV_PHI, 0, PHI),
    new Vector3(PHI, INV_PHI, 0),
    new Vector3(-PHI, INV_PHI, 0)
];
function PMREMGenerator(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._blurMaterial = _getBlurShader(MAX_SAMPLES);
    this._equirectShader = null;
    this._cubemapShader = null;
    this._compileMaterial(this._blurMaterial);
}
PMREMGenerator.prototype = {
    constructor: PMREMGenerator,
    /**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */ fromScene: function(scene, sigma = 0, near = 0.1, far = 100) {
        _oldTarget = this._renderer.getRenderTarget();
        const cubeUVRenderTarget = this._allocateTargets();
        this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
        if (sigma > 0) this._blur(cubeUVRenderTarget, 0, 0, sigma);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    },
    /**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */ fromEquirectangular: function(equirectangular) {
        return this._fromTexture(equirectangular);
    },
    /**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */ fromCubemap: function(cubemap) {
        return this._fromTexture(cubemap);
    },
    /**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */ compileCubemapShader: function() {
        if (this._cubemapShader === null) {
            this._cubemapShader = _getCubemapShader();
            this._compileMaterial(this._cubemapShader);
        }
    },
    /**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */ compileEquirectangularShader: function() {
        if (this._equirectShader === null) {
            this._equirectShader = _getEquirectShader();
            this._compileMaterial(this._equirectShader);
        }
    },
    /**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */ dispose: function() {
        this._blurMaterial.dispose();
        if (this._cubemapShader !== null) this._cubemapShader.dispose();
        if (this._equirectShader !== null) this._equirectShader.dispose();
        for(let i379 = 0; i379 < _lodPlanes.length; i379++)_lodPlanes[i379].dispose();
    },
    // private interface
    _cleanup: function(outputTarget) {
        this._pingPongRenderTarget.dispose();
        this._renderer.setRenderTarget(_oldTarget);
        outputTarget.scissorTest = false;
        _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
    },
    _fromTexture: function(texture) {
        _oldTarget = this._renderer.getRenderTarget();
        const cubeUVRenderTarget = this._allocateTargets(texture);
        this._textureToCubeUV(texture, cubeUVRenderTarget);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    },
    _allocateTargets: function(texture) {
        const params = {
            magFilter: NearestFilter,
            minFilter: NearestFilter,
            generateMipmaps: false,
            type: UnsignedByteType,
            format: RGBEFormat,
            encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
            depthBuffer: false,
            stencilBuffer: false
        };
        const cubeUVRenderTarget = _createRenderTarget(params);
        cubeUVRenderTarget.depthBuffer = texture ? false : true;
        this._pingPongRenderTarget = _createRenderTarget(params);
        return cubeUVRenderTarget;
    },
    _compileMaterial: function(material) {
        const tmpMesh = new Mesh(_lodPlanes[0], material);
        this._renderer.compile(tmpMesh, _flatCamera);
    },
    _sceneToCubeUV: function(scene, near, far, cubeUVRenderTarget) {
        const fov3 = 90;
        const aspect3 = 1;
        const cubeCamera = new PerspectiveCamera(fov3, aspect3, near, far);
        const upSign = [
            1,
            -1,
            1,
            1,
            1,
            1
        ];
        const forwardSign = [
            1,
            1,
            1,
            -1,
            -1,
            -1
        ];
        const renderer = this._renderer;
        const outputEncoding = renderer.outputEncoding;
        const toneMapping = renderer.toneMapping;
        const clearColor = renderer.getClearColor();
        const clearAlpha = renderer.getClearAlpha();
        renderer.toneMapping = NoToneMapping;
        renderer.outputEncoding = LinearEncoding;
        let background = scene.background;
        if (background && background.isColor) {
            background.convertSRGBToLinear();
            // Convert linear to RGBE
            const maxComponent = Math.max(background.r, background.g, background.b);
            const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128), 127);
            background = background.multiplyScalar(Math.pow(2, -fExp));
            const alpha = (fExp + 128) / 255;
            renderer.setClearColor(background, alpha);
            scene.background = null;
        }
        for(let i380 = 0; i380 < 6; i380++){
            const col = i380 % 3;
            if (col == 0) {
                cubeCamera.up.set(0, upSign[i380], 0);
                cubeCamera.lookAt(forwardSign[i380], 0, 0);
            } else if (col == 1) {
                cubeCamera.up.set(0, 0, upSign[i380]);
                cubeCamera.lookAt(0, forwardSign[i380], 0);
            } else {
                cubeCamera.up.set(0, upSign[i380], 0);
                cubeCamera.lookAt(0, 0, forwardSign[i380]);
            }
            _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i380 > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
            renderer.setRenderTarget(cubeUVRenderTarget);
            renderer.render(scene, cubeCamera);
        }
        renderer.toneMapping = toneMapping;
        renderer.outputEncoding = outputEncoding;
        renderer.setClearColor(clearColor, clearAlpha);
    },
    _textureToCubeUV: function(texture, cubeUVRenderTarget) {
        const renderer = this._renderer;
        if (texture.isCubeTexture) {
            if (this._cubemapShader == null) this._cubemapShader = _getCubemapShader();
        } else if (this._equirectShader == null) this._equirectShader = _getEquirectShader();
        const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
        const mesh = new Mesh(_lodPlanes[0], material);
        const uniforms = material.uniforms;
        uniforms['envMap'].value = texture;
        if (!texture.isCubeTexture) uniforms['texelSize'].value.set(1 / texture.image.width, 1 / texture.image.height);
        uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];
        uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];
        _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
        renderer.setRenderTarget(cubeUVRenderTarget);
        renderer.render(mesh, _flatCamera);
    },
    _applyPMREM: function(cubeUVRenderTarget) {
        const renderer = this._renderer;
        const autoClear = renderer.autoClear;
        renderer.autoClear = false;
        for(let i381 = 1; i381 < TOTAL_LODS; i381++){
            const sigma = Math.sqrt(_sigmas[i381] * _sigmas[i381] - _sigmas[i381 - 1] * _sigmas[i381 - 1]);
            const poleAxis = _axisDirections[(i381 - 1) % _axisDirections.length];
            this._blur(cubeUVRenderTarget, i381 - 1, i381, sigma, poleAxis);
        }
        renderer.autoClear = autoClear;
    },
    /**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */ _blur: function(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
        const pingPongRenderTarget = this._pingPongRenderTarget;
        this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
        this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
    },
    _halfBlur: function(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
        const renderer = this._renderer;
        const blurMaterial = this._blurMaterial;
        if (direction !== 'latitudinal' && direction !== 'longitudinal') console.error('blur direction must be either latitudinal or longitudinal!');
        // Number of standard deviations at which to cut off the discrete approximation.
        const STANDARD_DEVIATIONS = 3;
        const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
        const blurUniforms = blurMaterial.uniforms;
        const pixels = _sizeLods[lodIn] - 1;
        const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
        const sigmaPixels = sigmaRadians / radiansPerPixel;
        const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
        if (samples > MAX_SAMPLES) console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
        const weights = [];
        let sum = 0;
        for(let i383 = 0; i383 < MAX_SAMPLES; ++i383){
            const x = i383 / sigmaPixels;
            const weight = Math.exp(-x * x / 2);
            weights.push(weight);
            if (i383 == 0) sum += weight;
            else if (i383 < samples) sum += 2 * weight;
        }
        for(let i382 = 0; i382 < weights.length; i382++)weights[i382] = weights[i382] / sum;
        blurUniforms['envMap'].value = targetIn.texture;
        blurUniforms['samples'].value = samples;
        blurUniforms['weights'].value = weights;
        blurUniforms['latitudinal'].value = direction === 'latitudinal';
        if (poleAxis) blurUniforms['poleAxis'].value = poleAxis;
        blurUniforms['dTheta'].value = radiansPerPixel;
        blurUniforms['mipInt'].value = LOD_MAX - lodIn;
        blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
        blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
        const outputSize = _sizeLods[lodOut];
        const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
        const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
        _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
        renderer.setRenderTarget(targetOut);
        renderer.render(blurMesh, _flatCamera);
    }
};
function _isLDR(texture) {
    if (texture === undefined || texture.type !== UnsignedByteType) return false;
    return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
}
function _createPlanes() {
    const _lodPlanes1 = [];
    const _sizeLods1 = [];
    const _sigmas1 = [];
    let lod = LOD_MAX;
    for(let i384 = 0; i384 < TOTAL_LODS; i384++){
        const sizeLod = Math.pow(2, lod);
        _sizeLods1.push(sizeLod);
        let sigma = 1 / sizeLod;
        if (i384 > LOD_MAX - LOD_MIN) sigma = EXTRA_LOD_SIGMA[i384 - LOD_MAX + LOD_MIN - 1];
        else if (i384 == 0) sigma = 0;
        _sigmas1.push(sigma);
        const texelSize = 1 / (sizeLod - 1);
        const min = -texelSize / 2;
        const max = 1 + texelSize / 2;
        const uv1 = [
            min,
            min,
            max,
            min,
            max,
            max,
            min,
            min,
            max,
            max,
            min,
            max
        ];
        const cubeFaces = 6;
        const vertices = 6;
        const positionSize = 3;
        const uvSize = 2;
        const faceIndexSize = 1;
        const position = new Float32Array(positionSize * vertices * cubeFaces);
        const uv = new Float32Array(uvSize * vertices * cubeFaces);
        const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
        for(let face = 0; face < cubeFaces; face++){
            const x = face % 3 * 2 / 3 - 1;
            const y = face > 2 ? 0 : -1;
            const coordinates = [
                x,
                y,
                0,
                x + 2 / 3,
                y,
                0,
                x + 2 / 3,
                y + 1,
                0,
                x,
                y,
                0,
                x + 2 / 3,
                y + 1,
                0,
                x,
                y + 1,
                0
            ];
            position.set(coordinates, positionSize * vertices * face);
            uv.set(uv1, uvSize * vertices * face);
            const fill = [
                face,
                face,
                face,
                face,
                face,
                face
            ];
            faceIndex.set(fill, faceIndexSize * vertices * face);
        }
        const planes = new BufferGeometry();
        planes.setAttribute('position', new BufferAttribute(position, positionSize));
        planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
        planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
        _lodPlanes1.push(planes);
        if (lod > LOD_MIN) lod--;
    }
    return {
        _lodPlanes: _lodPlanes1,
        _sizeLods: _sizeLods1,
        _sigmas: _sigmas1
    };
}
function _createRenderTarget(params) {
    const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
    cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
    cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
    cubeUVRenderTarget.scissorTest = true;
    return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
    target.viewport.set(x, y, width, height);
    target.scissor.set(x, y, width, height);
}
function _getBlurShader(maxSamples) {
    const weights = new Float32Array(maxSamples);
    const poleAxis = new Vector3(0, 1, 0);
    const shaderMaterial = new RawShaderMaterial({
        name: 'SphericalGaussianBlur',
        defines: {
            'n': maxSamples
        },
        uniforms: {
            'envMap': {
                value: null
            },
            'samples': {
                value: 1
            },
            'weights': {
                value: weights
            },
            'latitudinal': {
                value: false
            },
            'dTheta': {
                value: 0
            },
            'mipInt': {
                value: 0
            },
            'poleAxis': {
                value: poleAxis
            },
            'inputEncoding': {
                value: ENCODINGS[LinearEncoding]
            },
            'outputEncoding': {
                value: ENCODINGS[LinearEncoding]
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform int samples;
uniform float weights[n];
uniform bool latitudinal;
uniform float dTheta;
uniform float mipInt;
uniform vec3 poleAxis;

${_getEncodings()}

#define ENVMAP_TYPE_CUBE_UV
#include <cube_uv_reflection_fragment>

vec3 getSample(float theta, vec3 axis) {
	float cosTheta = cos(theta);
	// Rodrigues' axis-angle rotation
	vec3 sampleDirection = vOutputDirection * cosTheta
		+ cross(axis, vOutputDirection) * sin(theta)
		+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);
	return bilinearCubeUV(envMap, sampleDirection, mipInt);
}

void main() {
	vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);
	if (all(equal(axis, vec3(0.0))))
		axis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);
	axis = normalize(axis);
	gl_FragColor = vec4(0.0);
	gl_FragColor.rgb += weights[0] * getSample(0.0, axis);
	for (int i = 1; i < n; i++) {
		if (i >= samples)
			break;
		float theta = dTheta * float(i);
		gl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);
		gl_FragColor.rgb += weights[i] * getSample(theta, axis);
	}
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function _getEquirectShader() {
    const texelSize = new Vector2(1, 1);
    const shaderMaterial = new RawShaderMaterial({
        name: 'EquirectangularToCubeUV',
        uniforms: {
            'envMap': {
                value: null
            },
            'texelSize': {
                value: texelSize
            },
            'inputEncoding': {
                value: ENCODINGS[LinearEncoding]
            },
            'outputEncoding': {
                value: ENCODINGS[LinearEncoding]
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform vec2 texelSize;

${_getEncodings()}

#include <common>

void main() {
	gl_FragColor = vec4(0.0);
	vec3 outputDirection = normalize(vOutputDirection);
	vec2 uv = equirectUv( outputDirection );
	vec2 f = fract(uv / texelSize - 0.5);
	uv -= f * texelSize;
	vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x += texelSize.x;
	vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.y += texelSize.y;
	vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x -= texelSize.x;
	vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	vec3 tm = mix(tl, tr, f.x);
	vec3 bm = mix(bl, br, f.x);
	gl_FragColor.rgb = mix(tm, bm, f.y);
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function _getCubemapShader() {
    const shaderMaterial = new RawShaderMaterial({
        name: 'CubemapToCubeUV',
        uniforms: {
            'envMap': {
                value: null
            },
            'inputEncoding': {
                value: ENCODINGS[LinearEncoding]
            },
            'outputEncoding': {
                value: ENCODINGS[LinearEncoding]
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform samplerCube envMap;

${_getEncodings()}

void main() {
	gl_FragColor = vec4(0.0);
	gl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function _getCommonVertexShader() {
    return `
precision mediump float;
precision mediump int;
attribute vec3 position;
attribute vec2 uv;
attribute float faceIndex;
varying vec3 vOutputDirection;

// RH coordinate system; PMREM face-indexing convention
vec3 getDirection(vec2 uv, float face) {
	uv = 2.0 * uv - 1.0;
	vec3 direction = vec3(uv, 1.0);
	if (face == 0.0) {
		direction = direction.zyx; // ( 1, v, u ) pos x
	} else if (face == 1.0) {
		direction = direction.xzy;
		direction.xz *= -1.0; // ( -u, 1, -v ) pos y
	} else if (face == 2.0) {
		direction.x *= -1.0; // ( -u, v, 1 ) pos z
	} else if (face == 3.0) {
		direction = direction.zyx;
		direction.xz *= -1.0; // ( -1, v, -u ) neg x
	} else if (face == 4.0) {
		direction = direction.xzy;
		direction.xy *= -1.0; // ( -u, -1, v ) neg y
	} else if (face == 5.0) {
		direction.z *= -1.0; // ( u, v, -1 ) neg z
	}
	return direction;
}

void main() {
	vOutputDirection = getDirection(uv, faceIndex);
	gl_Position = vec4( position, 1.0 );
}
	`;
}
function _getEncodings() {
    return `
uniform int inputEncoding;
uniform int outputEncoding;

#include <encodings_pars_fragment>

vec4 inputTexelToLinear(vec4 value){
	if(inputEncoding == 0){
		return value;
	}else if(inputEncoding == 1){
		return sRGBToLinear(value);
	}else if(inputEncoding == 2){
		return RGBEToLinear(value);
	}else if(inputEncoding == 3){
		return RGBMToLinear(value, 7.0);
	}else if(inputEncoding == 4){
		return RGBMToLinear(value, 16.0);
	}else if(inputEncoding == 5){
		return RGBDToLinear(value, 256.0);
	}else{
		return GammaToLinear(value, 2.2);
	}
}

vec4 linearToOutputTexel(vec4 value){
	if(outputEncoding == 0){
		return value;
	}else if(outputEncoding == 1){
		return LinearTosRGB(value);
	}else if(outputEncoding == 2){
		return LinearToRGBE(value);
	}else if(outputEncoding == 3){
		return LinearToRGBM(value, 7.0);
	}else if(outputEncoding == 4){
		return LinearToRGBM(value, 16.0);
	}else if(outputEncoding == 5){
		return LinearToRGBD(value, 256.0);
	}else{
		return LinearToGamma(value, 2.2);
	}
}

vec4 envMapTexelToLinear(vec4 color) {
	return inputTexelToLinear(color);
}
	`;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */ function Face4(a, b, c, d, normal, color, materialIndex) {
    console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
    return new Face3(a, b, c, normal, color, materialIndex);
}
const LineStrip = 0;
const LinePieces = 1;
const NoColors = 0;
const FaceColors = 1;
const VertexColors = 2;
function MeshFaceMaterial(materials) {
    console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
    return materials;
}
function MultiMaterial(materials) {
    if (materials === undefined) materials = [];
    console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
    materials.isMultiMaterial = true;
    materials.materials = materials;
    materials.clone = function() {
        return materials.slice();
    };
    return materials;
}
function PointCloud(geometry, material) {
    console.warn('THREE.PointCloud has been renamed to THREE.Points.');
    return new Points(geometry, material);
}
function Particle(material) {
    console.warn('THREE.Particle has been renamed to THREE.Sprite.');
    return new Sprite(material);
}
function ParticleSystem(geometry, material) {
    console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
    return new Points(geometry, material);
}
function PointCloudMaterial(parameters) {
    console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
    return new PointsMaterial(parameters);
}
function ParticleBasicMaterial(parameters) {
    console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
    return new PointsMaterial(parameters);
}
function ParticleSystemMaterial(parameters) {
    console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
    return new PointsMaterial(parameters);
}
function Vertex(x, y, z) {
    console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
    return new Vector3(x, y, z);
}
//
function DynamicBufferAttribute(array, itemSize) {
    console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
    return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
}
function Int8Attribute(array, itemSize) {
    console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
    return new Int8BufferAttribute(array, itemSize);
}
function Uint8Attribute(array, itemSize) {
    console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
    return new Uint8BufferAttribute(array, itemSize);
}
function Uint8ClampedAttribute(array, itemSize) {
    console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
    return new Uint8ClampedBufferAttribute(array, itemSize);
}
function Int16Attribute(array, itemSize) {
    console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
    return new Int16BufferAttribute(array, itemSize);
}
function Uint16Attribute(array, itemSize) {
    console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
    return new Uint16BufferAttribute(array, itemSize);
}
function Int32Attribute(array, itemSize) {
    console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
    return new Int32BufferAttribute(array, itemSize);
}
function Uint32Attribute(array, itemSize) {
    console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
    return new Uint32BufferAttribute(array, itemSize);
}
function Float32Attribute(array, itemSize) {
    console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
    return new Float32BufferAttribute(array, itemSize);
}
function Float64Attribute(array, itemSize) {
    console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
    return new Float64BufferAttribute(array, itemSize);
}
//
Curve.create = function(construct, getPoint) {
    console.log('THREE.Curve.create() has been deprecated');
    construct.prototype = Object.create(Curve.prototype);
    construct.prototype.constructor = construct;
    construct.prototype.getPoint = getPoint;
    return construct;
};
//
Object.assign(CurvePath.prototype, {
    createPointsGeometry: function(divisions) {
        console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
        // generate geometry from path points (for Line or Points objects)
        const pts = this.getPoints(divisions);
        return this.createGeometry(pts);
    },
    createSpacedPointsGeometry: function(divisions) {
        console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
        // generate geometry from equidistant sampling along the path
        const pts = this.getSpacedPoints(divisions);
        return this.createGeometry(pts);
    },
    createGeometry: function(points) {
        console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
        const geometry = new Geometry();
        for(let i385 = 0, l = points.length; i385 < l; i385++){
            const point = points[i385];
            geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
        }
        return geometry;
    }
});
//
Object.assign(Path.prototype, {
    fromPoints: function(points) {
        console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
        return this.setFromPoints(points);
    }
});
//
function ClosedSplineCurve3(points) {
    console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
    CatmullRomCurve3.call(this, points);
    this.type = 'catmullrom';
    this.closed = true;
}
ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
//
function SplineCurve3(points) {
    console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
    CatmullRomCurve3.call(this, points);
    this.type = 'catmullrom';
}
SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
//
function Spline(points) {
    console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');
    CatmullRomCurve3.call(this, points);
    this.type = 'catmullrom';
}
Spline.prototype = Object.create(CatmullRomCurve3.prototype);
Object.assign(Spline.prototype, {
    initFromArray: function() {
        console.error('THREE.Spline: .initFromArray() has been removed.');
    },
    getControlPointsArray: function() {
        console.error('THREE.Spline: .getControlPointsArray() has been removed.');
    },
    reparametrizeByArcLength: function() {
        console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
    }
});
//
function AxisHelper(size) {
    console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
    return new AxesHelper(size);
}
function BoundingBoxHelper(object, color) {
    console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
    return new BoxHelper(object, color);
}
function EdgesHelper(object, hex) {
    console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
    return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
        color: hex !== undefined ? hex : 16777215
    }));
}
GridHelper.prototype.setColors = function() {
    console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
};
SkeletonHelper.prototype.update = function() {
    console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
};
function WireframeHelper(object, hex) {
    console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
    return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
        color: hex !== undefined ? hex : 16777215
    }));
}
//
Object.assign(Loader.prototype, {
    extractUrlBase: function(url) {
        console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
        return LoaderUtils.extractUrlBase(url);
    }
});
Loader.Handlers = {
    add: function() {
        console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
    },
    get: function() {
        console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
    }
};
function XHRLoader(manager) {
    console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
    return new FileLoader(manager);
}
function BinaryTextureLoader(manager) {
    console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
    return new DataTextureLoader(manager);
}
Object.assign(ObjectLoader.prototype, {
    setTexturePath: function(value) {
        console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
        return this.setResourcePath(value);
    }
});
//
Object.assign(Box2.prototype, {
    center: function(optionalTarget) {
        console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
        return this.getCenter(optionalTarget);
    },
    empty: function() {
        console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
        return this.isEmpty();
    },
    isIntersectionBox: function(box) {
        console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
        return this.intersectsBox(box);
    },
    size: function(optionalTarget) {
        console.warn('THREE.Box2: .size() has been renamed to .getSize().');
        return this.getSize(optionalTarget);
    }
});
Object.assign(Box3.prototype, {
    center: function(optionalTarget) {
        console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
        return this.getCenter(optionalTarget);
    },
    empty: function() {
        console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
        return this.isEmpty();
    },
    isIntersectionBox: function(box) {
        console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
        return this.intersectsBox(box);
    },
    isIntersectionSphere: function(sphere) {
        console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
        return this.intersectsSphere(sphere);
    },
    size: function(optionalTarget) {
        console.warn('THREE.Box3: .size() has been renamed to .getSize().');
        return this.getSize(optionalTarget);
    }
});
Object.assign(Sphere.prototype, {
    empty: function() {
        console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
        return this.isEmpty();
    }
});
Frustum.prototype.setFromMatrix = function(m) {
    console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
    return this.setFromProjectionMatrix(m);
};
Line3.prototype.center = function(optionalTarget) {
    console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
};
Object.assign(MathUtils, {
    random16: function() {
        console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
        return Math.random();
    },
    nearestPowerOfTwo: function(value) {
        console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
        return MathUtils.floorPowerOfTwo(value);
    },
    nextPowerOfTwo: function(value) {
        console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
        return MathUtils.ceilPowerOfTwo(value);
    }
});
Object.assign(Matrix3.prototype, {
    flattenToArrayOffset: function(array, offset) {
        console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
    },
    multiplyVector3: function(vector) {
        console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
        return vector.applyMatrix3(this);
    },
    multiplyVector3Array: function() {
        console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
    },
    applyToBufferAttribute: function(attribute) {
        console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
        return attribute.applyMatrix3(this);
    },
    applyToVector3Array: function() {
        console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
    }
});
Object.assign(Matrix4.prototype, {
    extractPosition: function(m) {
        console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
        return this.copyPosition(m);
    },
    flattenToArrayOffset: function(array, offset) {
        console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
        return this.toArray(array, offset);
    },
    getPosition: function() {
        console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
        return new Vector3().setFromMatrixColumn(this, 3);
    },
    setRotationFromQuaternion: function(q) {
        console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
        return this.makeRotationFromQuaternion(q);
    },
    multiplyToArray: function() {
        console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
    },
    multiplyVector3: function(vector) {
        console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
    },
    multiplyVector4: function(vector) {
        console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
    },
    multiplyVector3Array: function() {
        console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
    },
    rotateAxis: function(v) {
        console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
        v.transformDirection(this);
    },
    crossVector: function(vector) {
        console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
    },
    translate: function() {
        console.error('THREE.Matrix4: .translate() has been removed.');
    },
    rotateX: function() {
        console.error('THREE.Matrix4: .rotateX() has been removed.');
    },
    rotateY: function() {
        console.error('THREE.Matrix4: .rotateY() has been removed.');
    },
    rotateZ: function() {
        console.error('THREE.Matrix4: .rotateZ() has been removed.');
    },
    rotateByAxis: function() {
        console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
    },
    applyToBufferAttribute: function(attribute) {
        console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
        return attribute.applyMatrix4(this);
    },
    applyToVector3Array: function() {
        console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
    },
    makeFrustum: function(left, right, bottom, top, near, far) {
        console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
        return this.makePerspective(left, right, top, bottom, near, far);
    }
});
Plane.prototype.isIntersectionLine = function(line) {
    console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
    return this.intersectsLine(line);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
    console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
    return vector.applyQuaternion(this);
};
Object.assign(Ray.prototype, {
    isIntersectionBox: function(box) {
        console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
        return this.intersectsBox(box);
    },
    isIntersectionPlane: function(plane) {
        console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
        return this.intersectsPlane(plane);
    },
    isIntersectionSphere: function(sphere) {
        console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
        return this.intersectsSphere(sphere);
    }
});
Object.assign(Triangle.prototype, {
    area: function() {
        console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
        return this.getArea();
    },
    barycoordFromPoint: function(point, target) {
        console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
        return this.getBarycoord(point, target);
    },
    midpoint: function(target) {
        console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
        return this.getMidpoint(target);
    },
    normal: function(target) {
        console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
        return this.getNormal(target);
    },
    plane: function(target) {
        console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
        return this.getPlane(target);
    }
});
Object.assign(Triangle, {
    barycoordFromPoint: function(point, a, b, c, target) {
        console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
        return Triangle.getBarycoord(point, a, b, c, target);
    },
    normal: function(a, b, c, target) {
        console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
        return Triangle.getNormal(a, b, c, target);
    }
});
Object.assign(Shape.prototype, {
    extractAllPoints: function(divisions) {
        console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
        return this.extractPoints(divisions);
    },
    extrude: function(options) {
        console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
        return new ExtrudeGeometry(this, options);
    },
    makeGeometry: function(options) {
        console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
        return new ShapeGeometry(this, options);
    }
});
Object.assign(Vector2.prototype, {
    fromAttribute: function(attribute, index, offset) {
        console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
        return this.fromBufferAttribute(attribute, index, offset);
    },
    distanceToManhattan: function(v) {
        console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
        return this.manhattanDistanceTo(v);
    },
    lengthManhattan: function() {
        console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
        return this.manhattanLength();
    }
});
Object.assign(Vector3.prototype, {
    setEulerFromRotationMatrix: function() {
        console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
    },
    setEulerFromQuaternion: function() {
        console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
    },
    getPositionFromMatrix: function(m) {
        console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
        return this.setFromMatrixPosition(m);
    },
    getScaleFromMatrix: function(m) {
        console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
        return this.setFromMatrixScale(m);
    },
    getColumnFromMatrix: function(index, matrix) {
        console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
        return this.setFromMatrixColumn(matrix, index);
    },
    applyProjection: function(m) {
        console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
        return this.applyMatrix4(m);
    },
    fromAttribute: function(attribute, index, offset) {
        console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
        return this.fromBufferAttribute(attribute, index, offset);
    },
    distanceToManhattan: function(v) {
        console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
        return this.manhattanDistanceTo(v);
    },
    lengthManhattan: function() {
        console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
        return this.manhattanLength();
    }
});
Object.assign(Vector4.prototype, {
    fromAttribute: function(attribute, index, offset) {
        console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
        return this.fromBufferAttribute(attribute, index, offset);
    },
    lengthManhattan: function() {
        console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
        return this.manhattanLength();
    }
});
//
Object.assign(Geometry.prototype, {
    computeTangents: function() {
        console.error('THREE.Geometry: .computeTangents() has been removed.');
    },
    computeLineDistances: function() {
        console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');
    },
    applyMatrix: function(matrix) {
        console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');
        return this.applyMatrix4(matrix);
    }
});
Object.assign(Object3D.prototype, {
    getChildByName: function(name) {
        console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
        return this.getObjectByName(name);
    },
    renderDepth: function() {
        console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
    },
    translate: function(distance, axis) {
        console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
        return this.translateOnAxis(axis, distance);
    },
    getWorldRotation: function() {
        console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
    },
    applyMatrix: function(matrix) {
        console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
        return this.applyMatrix4(matrix);
    }
});
Object.defineProperties(Object3D.prototype, {
    eulerOrder: {
        get: function() {
            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
            return this.rotation.order;
        },
        set: function(value) {
            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
            this.rotation.order = value;
        }
    },
    useQuaternion: {
        get: function() {
            console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
        },
        set: function() {
            console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
        }
    }
});
Object.assign(Mesh.prototype, {
    setDrawMode: function() {
        console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
    }
});
Object.defineProperties(Mesh.prototype, {
    drawMode: {
        get: function() {
            console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
            return TrianglesDrawMode;
        },
        set: function() {
            console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
        }
    }
});
Object.defineProperties(LOD.prototype, {
    objects: {
        get: function() {
            console.warn('THREE.LOD: .objects has been renamed to .levels.');
            return this.levels;
        }
    }
});
Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {
    get: function() {
        console.warn('THREE.Skeleton: useVertexTexture has been removed.');
    },
    set: function() {
        console.warn('THREE.Skeleton: useVertexTexture has been removed.');
    }
});
SkinnedMesh.prototype.initBones = function() {
    console.error('THREE.SkinnedMesh: initBones() has been removed.');
};
Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {
    get: function() {
        console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
        return this.arcLengthDivisions;
    },
    set: function(value) {
        console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
        this.arcLengthDivisions = value;
    }
});
//
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
    if (filmGauge !== undefined) this.filmGauge = filmGauge;
    this.setFocalLength(focalLength);
};
//
Object.defineProperties(Light.prototype, {
    onlyShadow: {
        set: function() {
            console.warn('THREE.Light: .onlyShadow has been removed.');
        }
    },
    shadowCameraFov: {
        set: function(value) {
            console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
            this.shadow.camera.fov = value;
        }
    },
    shadowCameraLeft: {
        set: function(value) {
            console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
            this.shadow.camera.left = value;
        }
    },
    shadowCameraRight: {
        set: function(value) {
            console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
            this.shadow.camera.right = value;
        }
    },
    shadowCameraTop: {
        set: function(value) {
            console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
            this.shadow.camera.top = value;
        }
    },
    shadowCameraBottom: {
        set: function(value) {
            console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
            this.shadow.camera.bottom = value;
        }
    },
    shadowCameraNear: {
        set: function(value) {
            console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
            this.shadow.camera.near = value;
        }
    },
    shadowCameraFar: {
        set: function(value) {
            console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
            this.shadow.camera.far = value;
        }
    },
    shadowCameraVisible: {
        set: function() {
            console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
        }
    },
    shadowBias: {
        set: function(value) {
            console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
            this.shadow.bias = value;
        }
    },
    shadowDarkness: {
        set: function() {
            console.warn('THREE.Light: .shadowDarkness has been removed.');
        }
    },
    shadowMapWidth: {
        set: function(value) {
            console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
            this.shadow.mapSize.width = value;
        }
    },
    shadowMapHeight: {
        set: function(value) {
            console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
            this.shadow.mapSize.height = value;
        }
    }
});
//
Object.defineProperties(BufferAttribute.prototype, {
    length: {
        get: function() {
            console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
            return this.array.length;
        }
    },
    dynamic: {
        get: function() {
            console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
            return this.usage === DynamicDrawUsage;
        },
        set: function() {
            console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
            this.setUsage(DynamicDrawUsage);
        }
    }
});
Object.assign(BufferAttribute.prototype, {
    setDynamic: function(value) {
        console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
        this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
    },
    copyIndicesArray: function() {
        console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
    },
    setArray: function() {
        console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
    }
});
Object.assign(BufferGeometry.prototype, {
    addIndex: function(index) {
        console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
        this.setIndex(index);
    },
    addAttribute: function(name, attribute) {
        console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');
        if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
            console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
            return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
        }
        if (name === 'index') {
            console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
            this.setIndex(attribute);
            return this;
        }
        return this.setAttribute(name, attribute);
    },
    addDrawCall: function(start, count, indexOffset) {
        if (indexOffset !== undefined) console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
        console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
        this.addGroup(start, count);
    },
    clearDrawCalls: function() {
        console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
        this.clearGroups();
    },
    computeTangents: function() {
        console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
    },
    computeOffsets: function() {
        console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
    },
    removeAttribute: function(name) {
        console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
        return this.deleteAttribute(name);
    },
    applyMatrix: function(matrix) {
        console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
        return this.applyMatrix4(matrix);
    }
});
Object.defineProperties(BufferGeometry.prototype, {
    drawcalls: {
        get: function() {
            console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
            return this.groups;
        }
    },
    offsets: {
        get: function() {
            console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
            return this.groups;
        }
    }
});
Object.defineProperties(InstancedBufferGeometry.prototype, {
    maxInstancedCount: {
        get: function() {
            console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
            return this.instanceCount;
        },
        set: function(value) {
            console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
            this.instanceCount = value;
        }
    }
});
Object.defineProperties(Raycaster.prototype, {
    linePrecision: {
        get: function() {
            console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
            return this.params.Line.threshold;
        },
        set: function(value) {
            console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
            this.params.Line.threshold = value;
        }
    }
});
Object.defineProperties(InterleavedBuffer.prototype, {
    dynamic: {
        get: function() {
            console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
            return this.usage === DynamicDrawUsage;
        },
        set: function(value) {
            console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
            this.setUsage(value);
        }
    }
});
Object.assign(InterleavedBuffer.prototype, {
    setDynamic: function(value) {
        console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
        this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
    },
    setArray: function() {
        console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
    }
});
//
Object.assign(ExtrudeBufferGeometry.prototype, {
    getArrays: function() {
        console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');
    },
    addShapeList: function() {
        console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');
    },
    addShape: function() {
        console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');
    }
});
//
Object.defineProperties(Uniform.prototype, {
    dynamic: {
        set: function() {
            console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
        }
    },
    onUpdate: {
        value: function() {
            console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
            return this;
        }
    }
});
//
Object.defineProperties(Material.prototype, {
    wrapAround: {
        get: function() {
            console.warn('THREE.Material: .wrapAround has been removed.');
        },
        set: function() {
            console.warn('THREE.Material: .wrapAround has been removed.');
        }
    },
    overdraw: {
        get: function() {
            console.warn('THREE.Material: .overdraw has been removed.');
        },
        set: function() {
            console.warn('THREE.Material: .overdraw has been removed.');
        }
    },
    wrapRGB: {
        get: function() {
            console.warn('THREE.Material: .wrapRGB has been removed.');
            return new Color();
        }
    },
    shading: {
        get: function() {
            console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
        },
        set: function(value) {
            console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
            this.flatShading = value === FlatShading;
        }
    },
    stencilMask: {
        get: function() {
            console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
            return this.stencilFuncMask;
        },
        set: function(value) {
            console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
            this.stencilFuncMask = value;
        }
    }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
    metal: {
        get: function() {
            console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
            return false;
        },
        set: function() {
            console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
        }
    }
});
Object.defineProperties(ShaderMaterial.prototype, {
    derivatives: {
        get: function() {
            console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
            return this.extensions.derivatives;
        },
        set: function(value) {
            console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
            this.extensions.derivatives = value;
        }
    }
});
//
Object.assign(WebGLRenderer.prototype, {
    clearTarget: function(renderTarget, color, depth, stencil) {
        console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
    },
    animate: function(callback) {
        console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
        this.setAnimationLoop(callback);
    },
    getCurrentRenderTarget: function() {
        console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
        return this.getRenderTarget();
    },
    getMaxAnisotropy: function() {
        console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
        return this.capabilities.getMaxAnisotropy();
    },
    getPrecision: function() {
        console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
        return this.capabilities.precision;
    },
    resetGLState: function() {
        console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
        return this.state.reset();
    },
    supportsFloatTextures: function() {
        console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
        return this.extensions.get('OES_texture_float');
    },
    supportsHalfFloatTextures: function() {
        console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
        return this.extensions.get('OES_texture_half_float');
    },
    supportsStandardDerivatives: function() {
        console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
        return this.extensions.get('OES_standard_derivatives');
    },
    supportsCompressedTextureS3TC: function() {
        console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
        return this.extensions.get('WEBGL_compressed_texture_s3tc');
    },
    supportsCompressedTexturePVRTC: function() {
        console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
        return this.extensions.get('WEBGL_compressed_texture_pvrtc');
    },
    supportsBlendMinMax: function() {
        console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
        return this.extensions.get('EXT_blend_minmax');
    },
    supportsVertexTextures: function() {
        console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
        return this.capabilities.vertexTextures;
    },
    supportsInstancedArrays: function() {
        console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
        return this.extensions.get('ANGLE_instanced_arrays');
    },
    enableScissorTest: function(boolean) {
        console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
        this.setScissorTest(boolean);
    },
    initMaterial: function() {
        console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
    },
    addPrePlugin: function() {
        console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
    },
    addPostPlugin: function() {
        console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
    },
    updateShadowMap: function() {
        console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
    },
    setFaceCulling: function() {
        console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
    },
    allocTextureUnit: function() {
        console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
    },
    setTexture: function() {
        console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
    },
    setTexture2D: function() {
        console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
    },
    setTextureCube: function() {
        console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
    },
    getActiveMipMapLevel: function() {
        console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
        return this.getActiveMipmapLevel();
    }
});
Object.defineProperties(WebGLRenderer.prototype, {
    shadowMapEnabled: {
        get: function() {
            return this.shadowMap.enabled;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
            this.shadowMap.enabled = value;
        }
    },
    shadowMapType: {
        get: function() {
            return this.shadowMap.type;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
            this.shadowMap.type = value;
        }
    },
    shadowMapCullFace: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
        }
    },
    context: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
            return this.getContext();
        }
    },
    vr: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
            return this.xr;
        }
    },
    gammaInput: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
            return false;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
        }
    },
    gammaOutput: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
            return false;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
            this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
        }
    },
    toneMappingWhitePoint: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
            return 1;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
        }
    }
});
Object.defineProperties(WebGLShadowMap.prototype, {
    cullFace: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
        }
    },
    renderReverseSided: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
        }
    },
    renderSingleSided: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
        }
    }
});
function WebGLRenderTargetCube(width, height, options) {
    console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
    return new WebGLCubeRenderTarget(width, options);
}
//
Object.defineProperties(WebGLRenderTarget.prototype, {
    wrapS: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
            return this.texture.wrapS;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
            this.texture.wrapS = value;
        }
    },
    wrapT: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
            return this.texture.wrapT;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
            this.texture.wrapT = value;
        }
    },
    magFilter: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
            return this.texture.magFilter;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
            this.texture.magFilter = value;
        }
    },
    minFilter: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
            return this.texture.minFilter;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
            this.texture.minFilter = value;
        }
    },
    anisotropy: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
            return this.texture.anisotropy;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
            this.texture.anisotropy = value;
        }
    },
    offset: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
            return this.texture.offset;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
            this.texture.offset = value;
        }
    },
    repeat: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
            return this.texture.repeat;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
            this.texture.repeat = value;
        }
    },
    format: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
            return this.texture.format;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
            this.texture.format = value;
        }
    },
    type: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
            return this.texture.type;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
            this.texture.type = value;
        }
    },
    generateMipmaps: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
            return this.texture.generateMipmaps;
        },
        set: function(value) {
            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
            this.texture.generateMipmaps = value;
        }
    }
});
//
Object.defineProperties(Audio.prototype, {
    load: {
        value: function(file) {
            console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
            const scope = this;
            const audioLoader = new AudioLoader();
            audioLoader.load(file, function(buffer) {
                scope.setBuffer(buffer);
            });
            return this;
        }
    },
    startTime: {
        set: function() {
            console.warn('THREE.Audio: .startTime is now .play( delay ).');
        }
    }
});
AudioAnalyser.prototype.getData = function() {
    console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
    return this.getFrequencyData();
};
//
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
    console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
    return this.update(renderer, scene);
};
//
const GeometryUtils = {
    merge: function(geometry1, geometry2, materialIndexOffset) {
        console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
        let matrix;
        if (geometry2.isMesh) {
            geometry2.matrixAutoUpdate && geometry2.updateMatrix();
            matrix = geometry2.matrix;
            geometry2 = geometry2.geometry;
        }
        geometry1.merge(geometry2, matrix, materialIndexOffset);
    },
    center: function(geometry) {
        console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
        return geometry.center();
    }
};
ImageUtils.crossOrigin = undefined;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
    console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
    const loader = new TextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    const texture = loader.load(url, onLoad, undefined, onError);
    if (mapping) texture.mapping = mapping;
    return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
    console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
    const loader = new CubeTextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    const texture = loader.load(urls, onLoad, undefined, onError);
    if (mapping) texture.mapping = mapping;
    return texture;
};
ImageUtils.loadCompressedTexture = function() {
    console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
};
ImageUtils.loadCompressedTextureCube = function() {
    console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
};
//
function CanvasRenderer() {
    console.error('THREE.CanvasRenderer has been removed');
}
//
function JSONLoader() {
    console.error('THREE.JSONLoader has been removed.');
}
//
const SceneUtils = {
    createMultiMaterialObject: function() {
        console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
    },
    detach: function() {
        console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
    },
    attach: function() {
        console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
    }
};
//
function LensFlare() {
    console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
}
if (typeof __THREE_DEVTOOLS__ !== 'undefined') /* eslint-disable no-undef */ __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
    detail: {
        revision: REVISION
    }
}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"fwRQw":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"TyEjs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _three = require("three");
var _debug = require("./Debug");
var _debugDefault = parcelHelpers.interopDefault(_debug);
var _dollyCamera = require("./DollyCamera");
var _dollyCameraDefault = parcelHelpers.interopDefault(_dollyCamera);
var _gameTime = require("./GameTime");
var _gameTimeDefault = parcelHelpers.interopDefault(_gameTime);
var _mapContentService = require("./MapContentService");
var _mapContentServiceDefault = parcelHelpers.interopDefault(_mapContentService);
var _physicsBody = require("./Physics/PhysicsBody");
var _physicsBodyDefault = parcelHelpers.interopDefault(_physicsBody);
var _physicsScene = require("./Physics/PhysicsScene");
var _physicsSceneDefault = parcelHelpers.interopDefault(_physicsScene);
var _terrainPhysicsBody = require("./Physics/TerrainPhysicsBody");
var _terrainPhysicsBodyDefault = parcelHelpers.interopDefault(_terrainPhysicsBody);
var _playerController = require("./PlayerController");
var _playerControllerDefault = parcelHelpers.interopDefault(_playerController);
var _playerState = require("./PlayerState");
var _stats = require("./Stats");
var _statsDefault = parcelHelpers.interopDefault(_stats);
var _terrain = require("./Terrain");
var _terrainDefault = parcelHelpers.interopDefault(_terrain);
exports.default = Game;
async function Game(container) {
    return new Promise((resolve)=>{
        let gameHasFocus = false;
        let scene = new _three.Scene();
        let renderer = new _three.WebGLRenderer({
            antialias: true
        });
        renderer.outputEncoding = _three.GammaEncoding;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = _three.PCFSoftShadowMap; // renderer.setClearColor(0xabdbeb);
        renderer.setClearColor(11923199);
        renderer.setSize(window.innerWidth / 4, window.innerHeight / 4, false);
        container.appendChild(renderer.domElement); // Stats
        let stats = _statsDefault.default();
        stats.setMode(0);
        stats.domElement.classList.add("stats-js");
        document.body.appendChild(stats.domElement); // Debug
        window.debug = new _debugDefault.default(scene);
        _axiosDefault.default.get("/api/map/head").then((response)=>response.data
        ).then(async (mapHeader)=>{
            console.log("got /api/map/head");
            let terrain = new _terrainDefault.default(renderer, scene, {
                mapSize: mapHeader.mapSize,
                viewDistance: mapHeader.viewSize,
                subdivisionSize: 16,
                maxHeight: mapHeader.maxHeight,
                ocean: {
                    height: 240,
                    color: "#11378A"
                }
            });
            await terrain.loadAsync("/images/terrain02.png");
            let terrainPhysicsBody = new _terrainPhysicsBodyDefault.default({
                mapSize: terrain.mapSize,
                viewSize: terrain.viewSize,
                subdivisions: terrain.subdivisions,
                quadrantSize: 2048
            });
            let physicsScene = new _physicsSceneDefault.default();
            physicsScene.add(terrainPhysicsBody);
            _physicsBodyDefault.default.onUpdate = (gameTime, physicsBody)=>{
                let entity = physicsBody.userData.entity;
                if (entity) {
                    entity.position.copy(physicsBody.position);
                    entity.quaternion.copy(physicsBody.orientation);
                    entity.scale.copy(physicsBody.scale);
                }
            };
            let player = new _dollyCameraDefault.default(renderer.domElement);
            let camera = player;
            player.physicsBody.setPosition(new _three.Vector3(9459, 265, -14668)); // player.physicsBody.setOrientation(
            //   new Quaternion(-0.01702, 0.97655, 0.08104, 0.19872).normalize()
            //   // new Quaternion(-0.01702601088131484, 0.976550282802887, 0.08104067952009769, 0.19872611397094142)
            // );
            scene.add(player);
            physicsScene.add(player.physicsBody); // let playerController = initPlayerControls(player);
            let lighting = initLighting(player, terrain);
            scene.add(lighting.ambientLight);
            scene.add(lighting.sun);
            scene.fog = createFog(); // let miniMap = new MiniMap({
            //   container: document.getElementById("minimap"),
            //   mapImagePath: "./images/minimap02.png",
            //   mapSize: terrain.mapSize,
            //   pointerScale: terrain.mapSize / 82,
            //   zoomFactor: 3,
            // });
            let quadrants = await terrainPhysicsBody.readAsync(player.physicsBody.position);
            let mapContentService = new _mapContentServiceDefault.default(scene, physicsScene);
            await mapContentService.initModelLibraryAsync();
            await mapContentService.readAsync(quadrants);
            console.log("initialise GameTime");
            let gameTime = new _gameTimeDefault.default();
            gameTime.every(5000, ()=>updateMapCollisionGeometryAndObjects(terrainPhysicsBody, mapContentService, player)
            );
            let gameContainer = container;
            container.addEventListener("click", ()=>{
                // if (!gameHasFocus) {
                //   gameContainer.requestPointerLock();
                // }
                gameHasFocus = !gameHasFocus;
                if (gameHasFocus) {
                    let coverText = document.getElementsByClassName("cover-text")[0];
                    if (coverText) coverText.remove();
                    gameTime.start();
                    audio.play();
                } else {
                    gameTime.stop();
                    audio.pause();
                }
            });
            let audio = new Audio("/assets/audio/The-Berg-Intro.mp3"); // document.addEventListener("pointerlockchange", () => {
            //   gameHasFocus = !gameHasFocus;
            //   // playerController.enabled = !playerController.enabled;
            //   if (gameHasFocus) {
            //     let coverText = document.getElementsByClassName("cover-text")[0] as HTMLElement;
            //     if (coverText) {
            //       coverText.remove();
            //     }
            //     gameTime.start();
            //     audio.play();
            //   } else {
            //     gameTime.stop();
            //     audio.pause();
            //   }
            // });
            // console.log("initialise map editor");
            // let editor = new MapEditor(
            //   player,
            //   playerController,
            //   scene,
            //   mapContentService,
            //   terrainPhysicsBody,
            //   physicsScene
            // );
            console.log("resolve Game");
            resolve({
                player,
                scene,
                renderer,
                terrain,
                camera,
                mapContentService,
                terrainPhysicsBody,
                physicsScene
            });
            physicsScene.update(gameTime);
            terrain.update(player, gameTime);
            let playerDirection = new _three.Vector3();
            player.getWorldDirection(playerDirection); // miniMap.render(player.position, playerDirection);
            // gameHasFocus = true;
            // gameTime.start();
            // audio.play();
            console.log("begin renderLoop");
            _debug.debug().showDebugMeshes = false;
            const renderLoop = ()=>{
                stats.begin();
                gameTime.update();
                if (gameHasFocus) {
                    physicsScene.update(gameTime);
                    terrain.update(player, gameTime);
                }
                lighting.sun.update(); // debug().update();
                requestAnimationFrame(renderLoop);
                renderer.setRenderTarget(null);
                renderer.render(scene, camera);
                if (gameHasFocus) player.getWorldDirection(playerDirection); // miniMap.render(player.position, playerDirection);
                stats.end();
            };
            renderLoop();
        });
    });
}
async function updateMapCollisionGeometryAndObjects(terrainPhysicsBody, mapContentService, camera) {
    let quadrants = await terrainPhysicsBody.readAsync(camera.position);
    mapContentService.readAsync(quadrants);
}
function initLighting(camera, terrain) {
    console.log("Initialise lighting");
    let ambientLight = new _three.AmbientLight(14348031, 0.6); // let sun = new DirectionalLight(0xdaeeff, 0.6);
    let sun = new _three.DirectionalLight(11923199, 0.6);
    sun.castShadow = true;
    sun.shadow.mapSize.width = terrain.viewSize;
    sun.shadow.mapSize.height = terrain.viewSize;
    sun.shadow.radius = 8;
    let shadowCameraBounds = 500;
    sun.shadow.camera.near = 0.1;
    sun.shadow.camera.far = camera.far;
    sun.shadow.camera.right = shadowCameraBounds;
    sun.shadow.camera.left = -shadowCameraBounds;
    sun.shadow.camera.top = shadowCameraBounds;
    sun.shadow.camera.bottom = -shadowCameraBounds;
    sun.target = camera;
    return {
        ambientLight,
        sun
    };
}
function createFog() {
    console.log("Create fog"); // return new FogExp2(0xabdbeb, 0.003);
    return new _three.FogExp2(11923199, 0.003);
}
function initPlayerControls(player) {
    console.log("Creating PlayerController");
    return new _playerControllerDefault.default({
        useMouseLook: true,
        keyMap: {
            turnleft: "37",
            turnright: "39",
            lookup: "38",
            lookdown: "40",
            forward: "87",
            backward: "83",
            strafeleft: "65",
            straferight: "68",
            run: "16"
        },
        actions: {
            turnleft: ()=>{
                player.addYaw(_three.MathUtils.degToRad(1));
            },
            turnright: ()=>{
                player.addYaw(_three.MathUtils.degToRad(-1));
            },
            forward: (pc, keyup)=>{
                player.move().forward();
            },
            backward: ()=>{
                player.move().backward();
            },
            lookup: ()=>{
                player.addPitch(_three.MathUtils.degToRad(1));
            },
            lookdown: ()=>{
                player.addPitch(_three.MathUtils.degToRad(-1));
            },
            strafeleft: ()=>{
                player.move().left();
            },
            straferight: ()=>{
                player.move().right();
            },
            mousemove: (pc, ev)=>{
                player.addPitch(_three.MathUtils.degToRad(-ev.movementY / 2));
                player.addYaw(_three.MathUtils.degToRad(-ev.movementX / 2));
            },
            run: (pc, keyup)=>{
                if (player.playerState.is(_playerState.PLAYER_STATES.FREEROAM)) return;
                if (keyup) player.playerState.set(_playerState.PLAYER_STATES.WALKING);
                else player.playerState.set(_playerState.PLAYER_STATES.RUNNING);
            }
        },
        enabled: false
    });
}

},{"axios":"jo6P5","three":"ktPTu","./Debug":"kTlrO","./GameTime":"eVIHh","./MapContentService":"4UWIx","./Physics/PhysicsBody":"6tk2H","./Physics/PhysicsScene":"ky7np","./Physics/TerrainPhysicsBody":"9REyN","./PlayerController":"7ZISl","./PlayerState":"kLQbG","./Stats":"1aeCQ","./Terrain":"hWq8A","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw","./DollyCamera":"5ddeH"}],"jo6P5":[function(require,module,exports) {
module.exports = require('./lib/axios');

},{"./lib/axios":"63MyY"}],"63MyY":[function(require,module,exports) {
'use strict';
var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */ function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance = bind(Axios.prototype.request, context);
    // Copy axios.prototype to instance
    utils.extend(instance, Axios.prototype, context);
    // Copy context to instance
    utils.extend(instance, context);
    return instance;
}
// Create the default instance to be exported
var axios = createInstance(defaults);
// Expose Axios class to allow class inheritance
axios.Axios = Axios;
// Factory for creating new instances
axios.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios.defaults, instanceConfig));
};
// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');
// Expose all/spread
axios.all = function all(promises) {
    return Promise.all(promises);
};
axios.spread = require('./helpers/spread');
module.exports = axios;
// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"./utils":"5By4s","./helpers/bind":"haRQb","./core/Axios":"cpqD8","./core/mergeConfig":"b85oP","./defaults":"lTJJ4","./cancel/Cancel":"kjMy2","./cancel/CancelToken":"45wzn","./cancel/isCancel":"a0VmF","./helpers/spread":"dyQ8N"}],"5By4s":[function(require,module,exports) {
'use strict';
var bind = require('./helpers/bind');
/*global toString:true*/ // utils is a library of generic helper functions non-specific to axios
var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */ function isArray(val) {
    return toString.call(val) === '[object Array]';
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */ function isUndefined(val) {
    return typeof val === 'undefined';
}
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */ function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */ function isArrayBuffer(val) {
    return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */ function isFormData(val) {
    return typeof FormData !== 'undefined' && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */ function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) result = ArrayBuffer.isView(val);
    else result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */ function isString(val) {
    return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */ function isNumber(val) {
    return typeof val === 'number';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */ function isObject(val) {
    return val !== null && typeof val === 'object';
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */ function isDate(val) {
    return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */ function isFile(val) {
    return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */ function isBlob(val) {
    return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */ function isFunction(val) {
    return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */ function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */ function isURLSearchParams(val) {
    return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */ function trim(str) {
    return str.replace(/^\s*/, '').replace(/\s*$/, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */ function isStandardBrowserEnv() {
    if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) return false;
    return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */ function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') return;
    // Force an array if not already something iterable
    if (typeof obj !== 'object') /*eslint no-param-reassign:0*/ obj = [
        obj
    ];
    if (isArray(obj)) // Iterate over array values
    for(var i = 0, l = obj.length; i < l; i++)fn.call(null, obj[i], i, obj);
    else {
        // Iterate over object keys
        for(var key in obj)if (Object.prototype.hasOwnProperty.call(obj, key)) fn.call(null, obj[key], key, obj);
    }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */ function merge() {
    var result = {};
    function assignValue(val, key) {
        if (typeof result[key] === 'object' && typeof val === 'object') result[key] = merge(result[key], val);
        else result[key] = val;
    }
    for(var i = 0, l = arguments.length; i < l; i++)forEach(arguments[i], assignValue);
    return result;
}
/**
 * Function equal to merge with the difference being that no reference
 * to original objects is kept.
 *
 * @see merge
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */ function deepMerge() {
    var result = {};
    function assignValue(val, key) {
        if (typeof result[key] === 'object' && typeof val === 'object') result[key] = deepMerge(result[key], val);
        else if (typeof val === 'object') result[key] = deepMerge({}, val);
        else result[key] = val;
    }
    for(var i = 0, l = arguments.length; i < l; i++)forEach(arguments[i], assignValue);
    return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */ function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') a[key] = bind(val, thisArg);
        else a[key] = val;
    });
    return a;
}
module.exports = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString,
    isNumber: isNumber,
    isObject: isObject,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach,
    merge: merge,
    deepMerge: deepMerge,
    extend: extend,
    trim: trim
};

},{"./helpers/bind":"haRQb"}],"haRQb":[function(require,module,exports) {
'use strict';
module.exports = function bind(fn, thisArg) {
    return function wrap() {
        var args = new Array(arguments.length);
        for(var i = 0; i < args.length; i++)args[i] = arguments[i];
        return fn.apply(thisArg, args);
    };
};

},{}],"cpqD8":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */ function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
    };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */ Axios.prototype.request = function request(config) {
    /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
    } else config = config || {};
    config = mergeConfig(this.defaults, config);
    // Set config.method
    if (config.method) config.method = config.method.toLowerCase();
    else if (this.defaults.method) config.method = this.defaults.method.toLowerCase();
    else config.method = 'get';
    // Hook up interceptors middleware
    var chain = [
        dispatchRequest,
        undefined
    ];
    var promise = Promise.resolve(config);
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
    });
    while(chain.length)promise = promise.then(chain.shift(), chain.shift());
    return promise;
};
Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};
// Provide aliases for supported request methods
utils.forEach([
    'delete',
    'get',
    'head',
    'options'
], function forEachMethodNoData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) {
        return this.request(utils.merge(config || {}, {
            method: method,
            url: url
        }));
    };
});
utils.forEach([
    'post',
    'put',
    'patch'
], function forEachMethodWithData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, data, config) {
        return this.request(utils.merge(config || {}, {
            method: method,
            url: url,
            data: data
        }));
    };
});
module.exports = Axios;

},{"./../utils":"5By4s","../helpers/buildURL":"3bwC2","./InterceptorManager":"1VRIM","./dispatchRequest":"6sjJ6","./mergeConfig":"b85oP"}],"3bwC2":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
function encode(val) {
    return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */ module.exports = function buildURL(url, params, paramsSerializer) {
    /*eslint no-param-reassign:0*/ if (!params) return url;
    var serializedParams;
    if (paramsSerializer) serializedParams = paramsSerializer(params);
    else if (utils.isURLSearchParams(params)) serializedParams = params.toString();
    else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === 'undefined') return;
            if (utils.isArray(val)) key = key + '[]';
            else val = [
                val
            ];
            utils.forEach(val, function parseValue(v) {
                if (utils.isDate(v)) v = v.toISOString();
                else if (utils.isObject(v)) v = JSON.stringify(v);
                parts.push(encode(key) + '=' + encode(v));
            });
        });
        serializedParams = parts.join('&');
    }
    if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) url = url.slice(0, hashmarkIndex);
        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }
    return url;
};

},{"./../utils":"5By4s"}],"1VRIM":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
function InterceptorManager() {
    this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */ InterceptorManager.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected
    });
    return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */ InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) this.handlers[id] = null;
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */ InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) fn(h);
    });
};
module.exports = InterceptorManager;

},{"./../utils":"5By4s"}],"6sjJ6":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');
/**
 * Throws a `Cancel` if cancellation has been requested.
 */ function throwIfCancellationRequested(config) {
    if (config.cancelToken) config.cancelToken.throwIfRequested();
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */ module.exports = function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    // Ensure headers exist
    config.headers = config.headers || {};
    // Transform request data
    config.data = transformData(config.data, config.headers, config.transformRequest);
    // Flatten headers
    config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils.forEach([
        'delete',
        'get',
        'head',
        'post',
        'put',
        'patch',
        'common'
    ], function cleanHeaderConfig(method) {
        delete config.headers[method];
    });
    var adapter = config.adapter || defaults.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        // Transform response data
        response.data = transformData(response.data, response.headers, config.transformResponse);
        return response;
    }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
            throwIfCancellationRequested(config);
            // Transform response data
            if (reason && reason.response) reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
        }
        return Promise.reject(reason);
    });
};

},{"./../utils":"5By4s","./transformData":"eRqJY","../cancel/isCancel":"a0VmF","../defaults":"lTJJ4"}],"eRqJY":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */ module.exports = function transformData(data, headers, fns) {
    /*eslint no-param-reassign:0*/ utils.forEach(fns, function transform(fn) {
        data = fn(data, headers);
    });
    return data;
};

},{"./../utils":"5By4s"}],"a0VmF":[function(require,module,exports) {
'use strict';
module.exports = function isCancel(value) {
    return !!(value && value.__CANCEL__);
};

},{}],"lTJJ4":[function(require,module,exports) {
'use strict';
var process = require("process");
var utils = require('./utils');
var normalizeHeaderName = require('./helpers/normalizeHeaderName');
var DEFAULT_CONTENT_TYPE = {
    'Content-Type': 'application/x-www-form-urlencoded'
};
function setContentTypeIfUnset(headers, value) {
    if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) headers['Content-Type'] = value;
}
function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== 'undefined') // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
    else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') // For node use HTTP adapter
    adapter = require('./adapters/http');
    return adapter;
}
var defaults = {
    adapter: getDefaultAdapter(),
    transformRequest: [
        function transformRequest(data, headers) {
            normalizeHeaderName(headers, 'Accept');
            normalizeHeaderName(headers, 'Content-Type');
            if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) return data;
            if (utils.isArrayBufferView(data)) return data.buffer;
            if (utils.isURLSearchParams(data)) {
                setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
                return data.toString();
            }
            if (utils.isObject(data)) {
                setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
                return JSON.stringify(data);
            }
            return data;
        }
    ],
    transformResponse: [
        function transformResponse(data) {
            /*eslint no-param-reassign:0*/ if (typeof data === 'string') try {
                data = JSON.parse(data);
            } catch (e) {}
            return data;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    maxContentLength: -1,
    validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
    }
};
defaults.headers = {
    common: {
        'Accept': 'application/json, text/plain, */*'
    }
};
utils.forEach([
    'delete',
    'get',
    'head'
], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
});
utils.forEach([
    'post',
    'put',
    'patch'
], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;

},{"process":"d5jf4","./utils":"5By4s","./helpers/normalizeHeaderName":"adBZo","./adapters/xhr":"ldm57","./adapters/http":"ldm57"}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e1) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};

},{}],"adBZo":[function(require,module,exports) {
'use strict';
var utils = require('../utils');
module.exports = function normalizeHeaderName(headers, normalizedName) {
    utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value;
            delete headers[name];
        }
    });
};

},{"../utils":"5By4s"}],"ldm57":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
var settle = require('./../core/settle');
var buildURL = require('./../helpers/buildURL');
var buildFullPath = require('../core/buildFullPath');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var createError = require('../core/createError');
module.exports = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        if (utils.isFormData(requestData)) delete requestHeaders['Content-Type']; // Let the browser set it
        var request = new XMLHttpRequest();
        // HTTP basic authentication
        if (config.auth) {
            var username = config.auth.username || '';
            var password = config.auth.password || '';
            requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        // Set the request timeout in MS
        request.timeout = config.timeout;
        // Listen for ready state
        request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) return;
            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) return;
            // Prepare the response
            var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
            var response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config: config,
                request: request
            };
            settle(resolve, reject, response);
            // Clean up request
            request = null;
        };
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
            if (!request) return;
            reject(createError('Request aborted', config, 'ECONNABORTED', request));
            // Clean up request
            request = null;
        };
        // Handle low level network errors
        request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(createError('Network Error', config, null, request));
            // Clean up request
            request = null;
        };
        // Handle timeout
        request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
            if (config.timeoutErrorMessage) timeoutErrorMessage = config.timeoutErrorMessage;
            reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request));
            // Clean up request
            request = null;
        };
        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
            var cookies = require('./../helpers/cookies');
            // Add xsrf header
            var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;
            if (xsrfValue) requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
        // Add headers to the request
        if ('setRequestHeader' in request) utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') // Remove Content-Type if data is undefined
            delete requestHeaders[key];
            else // Otherwise add header to the request
            request.setRequestHeader(key, val);
        });
        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) request.withCredentials = !!config.withCredentials;
        // Add responseType to request if needed
        if (config.responseType) try {
            request.responseType = config.responseType;
        } catch (e) {
            // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
            // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
            if (config.responseType !== 'json') throw e;
        }
        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') request.addEventListener('progress', config.onDownloadProgress);
        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) request.upload.addEventListener('progress', config.onUploadProgress);
        if (config.cancelToken) // Handle cancellation
        config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) return;
            request.abort();
            reject(cancel);
            // Clean up request
            request = null;
        });
        if (requestData === undefined) requestData = null;
        // Send the request
        request.send(requestData);
    });
};

},{"./../utils":"5By4s","./../core/settle":"dD9aC","./../helpers/buildURL":"3bwC2","../core/buildFullPath":"1I5TW","./../helpers/parseHeaders":"kqDd5","./../helpers/isURLSameOrigin":"lxXtv","../core/createError":"5nVS9","./../helpers/cookies":"4WJjt"}],"dD9aC":[function(require,module,exports) {
'use strict';
var createError = require('./createError');
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */ module.exports = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!validateStatus || validateStatus(response.status)) resolve(response);
    else reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
};

},{"./createError":"5nVS9"}],"5nVS9":[function(require,module,exports) {
'use strict';
var enhanceError = require('./enhanceError');
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */ module.exports = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":"itUQr"}],"itUQr":[function(require,module,exports) {
'use strict';
/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */ module.exports = function enhanceError(error, config, code, request, response) {
    error.config = config;
    if (code) error.code = code;
    error.request = request;
    error.response = response;
    error.isAxiosError = true;
    error.toJSON = function() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: this.config,
            code: this.code
        };
    };
    return error;
};

},{}],"1I5TW":[function(require,module,exports) {
'use strict';
var isAbsoluteURL = require('../helpers/isAbsoluteURL');
var combineURLs = require('../helpers/combineURLs');
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */ module.exports = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) return combineURLs(baseURL, requestedURL);
    return requestedURL;
};

},{"../helpers/isAbsoluteURL":"jD6NM","../helpers/combineURLs":"brOWK"}],"jD6NM":[function(require,module,exports) {
'use strict';
/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */ module.exports = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

},{}],"brOWK":[function(require,module,exports) {
'use strict';
/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */ module.exports = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

},{}],"kqDd5":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
    'age',
    'authorization',
    'content-length',
    'content-type',
    'etag',
    'expires',
    'from',
    'host',
    'if-modified-since',
    'if-unmodified-since',
    'last-modified',
    'location',
    'max-forwards',
    'proxy-authorization',
    'referer',
    'retry-after',
    'user-agent'
];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */ module.exports = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) return parsed;
    utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) return;
            if (key === 'set-cookie') parsed[key] = (parsed[key] ? parsed[key] : []).concat([
                val
            ]);
            else parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
    });
    return parsed;
};

},{"./../utils":"5By4s"}],"lxXtv":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;
    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */ function resolveURL(url) {
        var href = url;
        if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute('href', href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
    }
    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */ return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
        return true;
    };
}();

},{"./../utils":"5By4s"}],"4WJjt":[function(require,module,exports) {
'use strict';
var utils = require('./../utils');
module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
    return {
        write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + '=' + encodeURIComponent(value));
            if (utils.isNumber(expires)) cookie.push('expires=' + new Date(expires).toGMTString());
            if (utils.isString(path)) cookie.push('path=' + path);
            if (utils.isString(domain)) cookie.push('domain=' + domain);
            if (secure === true) cookie.push('secure');
            document.cookie = cookie.join('; ');
        },
        read: function read(name) {
            var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
            return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
            this.write(name, '', Date.now() - 86400000);
        }
    };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
    return {
        write: function write() {},
        read: function read() {
            return null;
        },
        remove: function remove() {}
    };
}();

},{"./../utils":"5By4s"}],"b85oP":[function(require,module,exports) {
'use strict';
var utils = require('../utils');
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */ module.exports = function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};
    var valueFromConfig2Keys = [
        'url',
        'method',
        'params',
        'data'
    ];
    var mergeDeepPropertiesKeys = [
        'headers',
        'auth',
        'proxy'
    ];
    var defaultToConfig2Keys = [
        'baseURL',
        'url',
        'transformRequest',
        'transformResponse',
        'paramsSerializer',
        'timeout',
        'withCredentials',
        'adapter',
        'responseType',
        'xsrfCookieName',
        'xsrfHeaderName',
        'onUploadProgress',
        'onDownloadProgress',
        'maxContentLength',
        'validateStatus',
        'maxRedirects',
        'httpAgent',
        'httpsAgent',
        'cancelToken',
        'socketPath'
    ];
    utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') config[prop] = config2[prop];
    });
    utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
        if (utils.isObject(config2[prop])) config[prop] = utils.deepMerge(config1[prop], config2[prop]);
        else if (typeof config2[prop] !== 'undefined') config[prop] = config2[prop];
        else if (utils.isObject(config1[prop])) config[prop] = utils.deepMerge(config1[prop]);
        else if (typeof config1[prop] !== 'undefined') config[prop] = config1[prop];
    });
    utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') config[prop] = config2[prop];
        else if (typeof config1[prop] !== 'undefined') config[prop] = config1[prop];
    });
    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys);
    var otherKeys = Object.keys(config2).filter(function filterAxiosKeys(key) {
        return axiosKeys.indexOf(key) === -1;
    });
    utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') config[prop] = config2[prop];
        else if (typeof config1[prop] !== 'undefined') config[prop] = config1[prop];
    });
    return config;
};

},{"../utils":"5By4s"}],"kjMy2":[function(require,module,exports) {
'use strict';
/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */ function Cancel(message) {
    this.message = message;
}
Cancel.prototype.toString = function toString() {
    return 'Cancel' + (this.message ? ': ' + this.message : '');
};
Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;

},{}],"45wzn":[function(require,module,exports) {
'use strict';
var Cancel = require('./Cancel');
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */ function CancelToken(executor) {
    if (typeof executor !== 'function') throw new TypeError('executor must be a function.');
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
    });
    var token = this;
    executor(function cancel(message) {
        if (token.reason) // Cancellation has already been requested
        return;
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
    });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */ CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) throw this.reason;
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */ CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
        cancel = c;
    });
    return {
        token: token,
        cancel: cancel
    };
};
module.exports = CancelToken;

},{"./Cancel":"kjMy2"}],"dyQ8N":[function(require,module,exports) {
'use strict';
/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */ module.exports = function spread(callback) {
    return function wrap(arr) {
        return callback.apply(null, arr);
    };
};

},{}],"kTlrO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "debug", ()=>debug
);
var _three = require("three");
var _boxCollider = require("./Physics/Colliders/BoxCollider");
var _boxColliderDefault = parcelHelpers.interopDefault(_boxCollider);
var _sphereCollider = require("./Physics/Colliders/SphereCollider");
var _sphereColliderDefault = parcelHelpers.interopDefault(_sphereCollider);
class Debug {
    // #region Properties (4)
    // #endregion Properties (4)
    // #region Constructors (1)
    constructor(scene){
        this.watchers = Array();
        this.scene = scene;
        this.debugMeshes = [];
        this.showDebugMeshes = true;
    }
    // #region Public Accessors (2)
    get showDebugMeshes() {
        return this._showDebugMeshes;
    }
    set showDebugMeshes(val) {
        if (val && !this._showDebugMeshes) this.debugMeshes.forEach((x)=>{
            this.scene.add(x);
        });
        else if (!val && this._showDebugMeshes) this.debugMeshes.forEach((x)=>{
            this.scene.remove(x);
        });
        this._showDebugMeshes = val;
    }
    // #region Public Methods (4)
    addDebugWayPoint(waypoint) {
        let sphereMesh = new _three.Mesh(new _three.SphereGeometry(waypoint.radius, 8, 8), new _three.MeshBasicMaterial({
            color: 16109621,
            transparent: true,
            opacity: 0.5
        }));
        sphereMesh.name = "debug_waypoint";
        sphereMesh.userData = {
            parent: waypoint
        };
        sphereMesh.position.set(waypoint.position.x, waypoint.position.y, waypoint.position.z);
        this.debugMeshes.push(sphereMesh);
        this.scene.add(sphereMesh);
    }
    addDebugPhysicsMesh(physicsBody) {
        // Debug mesh for broadphase bounds
        let boundsSize = new _three.Vector3();
        let boundsCenter = new _three.Vector3();
        physicsBody.worldBounds.getSize(boundsSize);
        physicsBody.worldBounds.getCenter(boundsCenter);
        let boundsMesh = new _three.Mesh(new _three.BoxGeometry(1, 1, 1), new _three.MeshBasicMaterial({
            wireframe: true,
            color: 16741632
        }));
        let p1 = boundsCenter;
        boundsMesh.position.set(p1.x, p1.y, p1.z);
        boundsMesh.scale.set(boundsSize.x, boundsSize.y, boundsSize.z);
        boundsMesh.userData = {
            physicsBody
        };
        boundsMesh.name = "debug_bounds";
        this.debugMeshes.push(boundsMesh);
        this.scene.add(boundsMesh); // Debug meshes for colliders...
        let colliderMeshes = physicsBody.colliders.map((x)=>{
            let mesh;
            if (x instanceof _sphereColliderDefault.default) {
                let collider = x;
                mesh = new _three.Mesh(new _three.SphereGeometry(collider.radius, 8, 8), new _three.MeshStandardMaterial({
                    wireframe: false,
                    flatShading: true,
                    color: 16109621,
                    transparent: true,
                    opacity: 0.5
                }));
            } else if (x instanceof _boxColliderDefault.default) {
                let collider = x;
                mesh = new _three.Mesh(new _three.BoxGeometry(collider.size.x, collider.size.y, collider.size.z), new _three.MeshStandardMaterial({
                    wireframe: false,
                    flatShading: true,
                    color: 16109621,
                    transparent: true,
                    opacity: 0.5
                }));
            }
            if (mesh) {
                let p = x.position;
                mesh.position.set(p.x, p.y, p.z); // mesh.setRotationFromQuaternion(x.orientation);
                mesh.userData = {
                    collider: x,
                    physicsBody
                };
                mesh.name = "debug_collider";
                return mesh;
            }
        });
        if (colliderMeshes.length > 0) {
            let g = new _three.Group();
            g.name = "debug_body";
            g.userData = {
                physicsBody: physicsBody
            };
            p1 = physicsBody.position;
            let s = physicsBody.scale;
            g.position.set(p1.x, p1.y, p1.z);
            g.setRotationFromQuaternion(physicsBody.orientation);
            g.scale.set(s.x, s.y, s.z);
            g.add(...colliderMeshes);
            this.scene.add(g);
            this.debugMeshes.push(g);
        }
    }
    addWatch(name, obj) {
        let idx = this.watchers.findIndex((x)=>x.name === name
        );
        if (idx < 0) this.watchers.push({
            name: name,
            val: obj
        });
        else this.watchers[idx].val = obj;
    }
    removeWatch(name) {
        let idx = this.watchers.findIndex((x)=>x.name === name
        );
        if (idx >= 0) this.watchers = this.watchers.slice(0, idx).concat(this.watchers.slice(idx + 1));
    }
    update() {
        let content = "";
        for(let i = 0; i < this.watchers.length; i++){
            let watch = this.watchers[i];
            let v = JSON.stringify(watch.val);
            content += `<p>${watch.name}: ${v}</p>`;
        }
        for(let i1 = 0; i1 < this.debugMeshes.length; i1++){
            let mesh = this.debugMeshes[i1];
            let physicsBody = mesh.userData.physicsBody;
            let t = new _three.Vector3();
            let r = new _three.Quaternion();
            let s = new _three.Vector3();
            switch(mesh.name){
                case "debug_bounds":
                    physicsBody.worldBounds.getCenter(t);
                    physicsBody.worldBounds.getSize(s);
                    break;
                case "debug_body":
                    physicsBody.matrixWorld.decompose(t, r, s);
                    mesh.setRotationFromQuaternion(r);
                    mesh.children.forEach((x)=>{
                        let collider = x.userData.collider;
                        x.position.copy(collider.position);
                        x.setRotationFromQuaternion(collider.orientation);
                    });
                    break;
                case "debug_waypoint":
                    let parent = mesh.userData.parent;
                    t.copy(parent.position);
                    s.set(1, 1, 1);
            }
            mesh.position.copy(t);
            mesh.scale.copy(s);
        }
        document.getElementById("debug").innerHTML = content;
    }
}
exports.default = Debug;
const debug = ()=>window.debug
;

},{"three":"ktPTu","./Physics/Colliders/BoxCollider":"arHpr","./Physics/Colliders/SphereCollider":"5DXdZ","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"arHpr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
class BoxCollider {
    // #region Properties (5)
    // #endregion Properties (5)
    // #region Constructors (1)
    /**
   * Describes a box shaped collider to be attached to a PhysicsBody
   * @param size the size of the box collider
   * @param position the offset from the center of the parent PhysicsBody
   * @param orientation the orientation in relation to the parent PhysicsBody
   */ constructor(size, position, orientation){
        this._position = position || new _three.Vector3();
        this._size = size;
        this._halfSize = new _three.Vector3().copy(size).divideScalar(2);
        this._orientation = orientation || new _three.Quaternion();
        this._matrix = new _three.Matrix4().compose(this._position, this._orientation, new _three.Vector3(1, 1, 1));
    }
    // #region Public Accessors (6)
    get matrix() {
        return this._matrix;
    }
    get maxExtent() {
        return new _three.Vector3().addVectors(this._position, this._halfSize);
    }
    get minExtent() {
        return new _three.Vector3().subVectors(this._position, this._halfSize);
    }
    get orientation() {
        this._orientation.setFromRotationMatrix(this._matrix);
        return this._orientation;
    }
    get position() {
        this._position.setFromMatrixPosition(this._matrix);
        return this._position;
    }
    get size() {
        return this._size;
    }
    // #region Public Methods (3)
    applyMatrix(m) {
        this._matrix.multiply(m);
        this._size.multiplyScalar(this._matrix.getMaxScaleOnAxis()); // Only linear scaling allowed
        this._halfSize.copy(this._size).divideScalar(2);
        return this;
    }
    clone() {
        return new BoxCollider(this._size.clone(), this.position.clone(), this.orientation.clone());
    }
    getBoundingBox() {
        return new _three.Box3(this.minExtent, this.maxExtent);
    }
}
exports.default = BoxCollider;

},{"three":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"5DXdZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
class SphereCollider {
    // #region Properties (5)
    // #endregion Properties (5)
    // #region Constructors (1)
    /**
   * Describes a sphere shaped collider to be attached to a PhysicsBody
   * @param radius the radius
   * @param position the offset from the center of the parent PhysicsBody
   * @param orientation the orientation in relation to the parent PhysicsBody
   */ constructor(radius, position, orientation){
        this._position = position || new _three.Vector3();
        this._orientation = orientation || new _three.Quaternion();
        this._radius = radius;
        this._radiusSq = this._radius * this._radius;
        this._matrix = new _three.Matrix4().compose(this._position, this._orientation, new _three.Vector3(1, 1, 1));
    }
    // #region Public Accessors (5)
    /** matrix describing the local transform */ get matrix() {
        return this._matrix;
    }
    /** local orientation of the collider relative to the parent PhysicsBody */ get orientation() {
        this._orientation.setFromRotationMatrix(this._matrix); // OK to use this method here since colliders don't have scale
        return this._orientation;
    }
    /** local position of the collider relative to the parent PhysicsBody */ get position() {
        this._position.setFromMatrixPosition(this._matrix);
        return this._position;
    }
    /** radius of the SphereCollider */ get radius() {
        return this._radius;
    }
    /** radius squared of the SphereCollider */ get radiusSq() {
        return this._radiusSq;
    }
    // #region Public Methods (2)
    applyMatrix(m) {
        this._matrix = m.clone().multiply(this._matrix);
        this._radius = this._radius * this._matrix.getMaxScaleOnAxis();
        return this;
    }
    clone() {
        return new SphereCollider(this._radius, this.position.clone(), this.orientation.clone());
    }
    getBoundingBox() {
        let bbox = new _three.Box3();
        bbox.set(this._position, this._position);
        bbox.expandByScalar(this._radius);
        return bbox;
    }
}
exports.default = SphereCollider;

},{"three":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"eVIHh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
var _eventHandler = require("./EventHandler");
var _eventHandlerDefault = parcelHelpers.interopDefault(_eventHandler);
class GameTime {
    _clock = new _three.Clock();
    _deltaTime = 0;
    constructor(){
        this._status = "stopped";
        this._deltaTime = 0;
        this._eventHandler = new _eventHandlerDefault.default(this);
    }
    get deltaTime() {
        return this._deltaTime;
    }
    get elapsedTime() {
        return this._clock.elapsedTime;
    }
    get status() {
        return this._status;
    }
    start() {
        this._status = "running";
        this._clock.start();
    }
    stop() {
        this._status = "stopped";
        this._deltaTime = 0;
        this._clock.stop();
    }
    update() {
        if (this._status === "running") {
            this._deltaTime = this._clock.getDelta();
            this._eventHandler.trigger("update");
        }
    }
    every(nMilliseconds, callback) {
        let lastRemainder = 0;
        this._eventHandler.on("update", ()=>{
            let r = this.elapsedTime * 1000 % nMilliseconds;
            if (r < lastRemainder) callback();
            lastRemainder = r;
        });
    }
}
exports.default = GameTime;

},{"three":"ktPTu","./EventHandler":"a6Re1","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"a6Re1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventId = 0;
class EventHandler {
    constructor(parent){
        this._parent = parent;
        this._events = {};
    }
    on(eventName, fn) {
        if (typeof fn === "function") {
            if (Array.isArray(this._events[eventName])) this._events[eventName][++_eventId] = {
                id: _eventId,
                fn: fn
            };
            else {
                this._events[eventName] = [];
                this._events[eventName][++_eventId] = {
                    id: _eventId,
                    fn: fn
                };
            }
            return _eventId;
        }
    }
    off(eventName, eventId) {
        if (this._events[eventName][eventId]) delete this._events[eventName][eventId];
    }
    trigger(eventName) {
        if (Array.isArray(this._events[eventName])) this._events[eventName].forEach((item)=>item.fn(this._parent)
        );
    }
}
exports.default = EventHandler;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"4UWIx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _three = require("three");
var _mtlloader = require("three/examples/jsm/loaders/MTLLoader");
var _objloader = require("three/examples/jsm/loaders/OBJLoader");
var _boxCollider = require("./Physics/Colliders/BoxCollider");
var _boxColliderDefault = parcelHelpers.interopDefault(_boxCollider);
var _sphereCollider = require("./Physics/Colliders/SphereCollider");
var _sphereColliderDefault = parcelHelpers.interopDefault(_sphereCollider);
var _physicsBody = require("./Physics/PhysicsBody");
var _physicsBodyDefault = parcelHelpers.interopDefault(_physicsBody);
const modelLibraryData = [
    {
        name: "aircraft02",
        objFile: "/LightAircraft/light_aircraft_02.obj",
        materialFile: "/LightAircraft/light_aircraft_02.mtl",
        mcgFile: "/LightAircraft/light_aircraft_02.mcg",
        // collision geometry definition
        isStatic: true
    },
    //   name: "building01",
    //   objFile: "/Buildings/Building01.obj",
    //   materialFile: "/Buildings/Building01.mtl",
    //   mcgFile: "/Buildings/Building01.mcg",
    //   isStatic: true,
    // },
    {
        name: "radiomast",
        objFile: "/Buildings/radio_mast.obj",
        materialFile: "/Buildings/radio_mast.mtl",
        mcgFile: "/Buildings/radio_mast.mcg",
        isStatic: true
    },
    {
        name: "house",
        objFile: "/Buildings/House.obj",
        materialFile: "/Buildings/House.mtl",
        mcgFile: "/Buildings/House.mcg",
        isStatic: true
    }
];
class MapContentService {
    // #region Properties (4)
    // #endregion Properties (4)
    // #region Constructors (1)
    constructor(scene, physicsScene){
        console.log("create MapContentService");
        this.activeQuadrants = {};
        this.modelLibrary = {};
        this.scene = scene;
        this.physicsScene = physicsScene;
    }
    // #region Public Methods (3)
    async initModelLibraryAsync() {
        console.log("initialise model library");
        let modelLibrary = this.modelLibrary;
        let loadingManager = new _three.LoadingManager();
        const loadItems = async ()=>{
            for(let i = 0; i < modelLibraryData.length; i++){
                const loadItem = async ()=>{
                    let item = modelLibraryData[i];
                    console.log(`loading material ${item.name}`);
                    let mtl = await MTLLoaderAsync(loadingManager, item);
                    console.log(`loading model ${item.name}`);
                    let obj = await OBJLoaderAsync(loadingManager, item, mtl);
                    obj.name = item.name;
                    console.log(`loading collision geometry ${item.name}`);
                    let mcg = await MCGLoaderAsync(loadingManager, item, obj);
                    modelLibrary[obj.name] = {
                        model: obj,
                        isStatic: item.isStatic,
                        mcg: mcg && mcg.map((x)=>({
                                name: x.name,
                                dimensions: IVector3APIToVector3(x.dimensions),
                                position: IVector3APIToVector3(x.position),
                                orientation: x.orientation ? IQuaternionAPIToQuaternion(x.orientation) : new _three.Quaternion(),
                                type: x.type
                            })
                        )
                    };
                };
                await loadItem();
            }
        };
        await loadItems();
        let cubeGeom = new _three.BoxGeometry(5, 5, 5, 1, 1, 1);
        let cubeMat = new _three.MeshStandardMaterial({
            color: 13176838,
            flatShading: true
        }); // modelLibrary["box"] = { model: new Mesh(cubeGeom, cubeMat), isStatic: false };
        modelLibrary["box"] = {
            model: new _three.Mesh(cubeGeom, cubeMat),
            isStatic: true,
            mcg: [
                {
                    dimensions: new _three.Vector3(5, 35, 5),
                    name: "cg_box",
                    position: new _three.Vector3(0, 0, 0),
                    type: "Box",
                    orientation: new _three.Quaternion()
                }
            ]
        };
        modelLibrary["box"].model.name = "box";
    }
    readAsync(quadrants) {
        console.log("begin MapContentService.readAsync");
        return new Promise((resolve, reject)=>{
            for(let i = 0; i < quadrants.length; i++){
                let quadIdx = quadrants[i].index;
                if (this.activeQuadrants[quadIdx]) continue;
                _axiosDefault.default.get(`/api/map/objects/${quadIdx}`, {
                    responseType: "json"
                }).then((response)=>response.data
                ).then((quadrant)=>{
                    this.activeQuadrants[quadIdx] = [];
                    quadrant.forEach((item)=>{
                        let m = this.spawn(item.name, IVector3APIToVector3(item.pos), IQuaternionAPIToQuaternion(item.q), IVector3APIToVector3(item.scale));
                        if (!m) {
                            reject(`Cannot spawn ${item.name}`);
                            return;
                        }
                        this.activeQuadrants[quadIdx].push(m);
                    });
                    console.log("resolve MapContentService.readAsync");
                    resolve(quadrant);
                });
            }
        });
    }
    spawn(modelName, pos, rotation, scale) {
        let modelLibItem = this.modelLibrary[modelName];
        let model = modelLibItem.model;
        let mcg = modelLibItem.mcg;
        if (!model) return null;
        let m = model.isMesh || model.isGroup ? model.clone() : model.scene.clone();
        m.name = modelName;
        m.userData = {
            isMapContent: true
        };
        m.castShadow = m.receiveShadow = true;
        m.traverse((node)=>{
            if (node.isMesh) node.castShadow = node.receiveShadow = true;
        });
        if (mcg) {
            let physicsBody = new _physicsBodyDefault.default();
            physicsBody.isStatic = modelLibItem.isStatic;
            physicsBody.userData = {
                entity: m
            };
            this.physicsScene.add(physicsBody);
            mcg.map((c)=>{
                let collider = colliderFrom[c.type.toLowerCase()](c.dimensions, c.position || new _three.Vector3(), c.orientation || new _three.Quaternion());
                physicsBody.addCollider(collider);
            });
            physicsBody.setPosition(pos);
            physicsBody.setOrientation(rotation);
            physicsBody.setScale(scale.x);
        } else {
            m.position.set(pos.x, pos.y, pos.z);
            m.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
        }
        m.scale.set(scale.x, scale.y, scale.z);
        this.scene.add(m);
        return m;
    }
}
exports.default = MapContentService;
function IVector3APIToVector3(input) {
    return new _three.Vector3(parseFloat(input.x), parseFloat(input.y), parseFloat(input.z));
}
function IQuaternionAPIToQuaternion(input) {
    return new _three.Quaternion(parseFloat(input.x), parseFloat(input.y), parseFloat(input.z), parseFloat(input.w));
}
const colliderFrom = {
    sphere: (dimensions, position, orientation)=>new _sphereColliderDefault.default(dimensions.x / 2, position, orientation)
    ,
    box: (dimensions, position, rotation)=>new _boxColliderDefault.default(dimensions, position, rotation)
};
async function MTLLoaderAsync(loadingManager, item) {
    let mtlLoader = new _mtlloader.MTLLoader(loadingManager);
    return new Promise((resolve)=>{
        mtlLoader.setPath("/assets/models");
        mtlLoader.load(item.materialFile, (mtl)=>{
            console.log(`finished loading material ${item.name}`);
            resolve(mtl);
        });
    });
}
async function OBJLoaderAsync(loadingManager, item, mtl) {
    let objLoader = new _objloader.OBJLoader(loadingManager);
    return new Promise((resolve)=>{
        objLoader.setMaterials(mtl).setPath("/assets/models").load(item.objFile, (obj)=>{
            console.log(`finished loading model ${item.name}`);
            resolve(obj);
        });
    });
}
/**
 * Model Collision Geometry Loader
 * @param loadingManager
 * @param item
 * @param obj
 */ async function MCGLoaderAsync(loadingManager, item, obj) {
    let mcgLoader = new ModelCollisionGeometryLoader(loadingManager);
    return new Promise((resolve)=>{
        mcgLoader.setPath("/assets/models").load(item.mcgFile, (mcg)=>{
            console.log(`finished loading collision geometry ${item.name}`);
            resolve(mcg);
        });
    });
}
class ModelCollisionGeometryLoader extends _three.FileLoader {
    // #region Constructors (1)
    constructor(loadingManager){
        super(loadingManager);
        this.setResponseType("json");
    }
}

},{"axios":"jo6P5","three":"ktPTu","three/examples/jsm/loaders/MTLLoader":"im57q","three/examples/jsm/loaders/OBJLoader":"htIhD","./Physics/Colliders/BoxCollider":"arHpr","./Physics/Colliders/SphereCollider":"5DXdZ","./Physics/PhysicsBody":"6tk2H","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"im57q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MTLLoader", ()=>MTLLoader
);
/**
 * Loads a Wavefront .mtl file specifying materials
 *
 * @author angelxuanchang
 */ var _threeModuleJs = require("../../../build/three.module.js");
var MTLLoader = function(manager) {
    _threeModuleJs.Loader.call(this, manager);
};
MTLLoader.prototype = Object.assign(Object.create(_threeModuleJs.Loader.prototype), {
    constructor: MTLLoader,
    /**
	 * Loads and parses a MTL asset from a URL.
	 *
	 * @param {String} url - URL to the MTL file.
	 * @param {Function} [onLoad] - Callback invoked with the loaded object.
	 * @param {Function} [onProgress] - Callback for download progress.
	 * @param {Function} [onError] - Callback for download errors.
	 *
	 * @see setPath setResourcePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setResourcePath() explicitly prior to load.
	 */ load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var path = this.path === '' ? _threeModuleJs.LoaderUtils.extractUrlBase(url) : this.path;
        var loader = new _threeModuleJs.FileLoader(this.manager);
        loader.setPath(this.path);
        loader.load(url, function(text) {
            try {
                onLoad(scope.parse(text, path));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope.manager.itemError(url);
            }
        }, onProgress, onError);
    },
    setMaterialOptions: function(value) {
        this.materialOptions = value;
        return this;
    },
    /**
	 * Parses a MTL file.
	 *
	 * @param {String} text - Content of MTL file
	 * @return {MTLLoader.MaterialCreator}
	 *
	 * @see setPath setResourcePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setResourcePath() explicitly prior to parse.
	 */ parse: function(text, path) {
        var lines = text.split('\n');
        var info = {};
        var delimiter_pattern = /\s+/;
        var materialsInfo = {};
        for(var i = 0; i < lines.length; i++){
            var line = lines[i];
            line = line.trim();
            if (line.length === 0 || line.charAt(0) === '#') continue;
            var pos = line.indexOf(' ');
            var key = pos >= 0 ? line.substring(0, pos) : line;
            key = key.toLowerCase();
            var value = pos >= 0 ? line.substring(pos + 1) : '';
            value = value.trim();
            if (key === 'newmtl') {
                // New material
                info = {
                    name: value
                };
                materialsInfo[value] = info;
            } else if (key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke') {
                var ss = value.split(delimiter_pattern, 3);
                info[key] = [
                    parseFloat(ss[0]),
                    parseFloat(ss[1]),
                    parseFloat(ss[2])
                ];
            } else info[key] = value;
        }
        var materialCreator = new MTLLoader.MaterialCreator(this.resourcePath || path, this.materialOptions);
        materialCreator.setCrossOrigin(this.crossOrigin);
        materialCreator.setManager(this.manager);
        materialCreator.setMaterials(materialsInfo);
        return materialCreator;
    }
});
/**
 * Create a new MTLLoader.MaterialCreator
 * @param baseUrl - Url relative to which textures are loaded
 * @param options - Set of options on how to construct the materials
 *                  side: Which side to apply the material
 *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide
 *                  wrap: What type of wrapping to apply for textures
 *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
 *                                Default: false, assumed to be already normalized
 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
 *                                  Default: false
 * @constructor
 */ MTLLoader.MaterialCreator = function(baseUrl, options) {
    this.baseUrl = baseUrl || '';
    this.options = options;
    this.materialsInfo = {};
    this.materials = {};
    this.materialsArray = [];
    this.nameLookup = {};
    this.side = this.options && this.options.side ? this.options.side : _threeModuleJs.FrontSide;
    this.wrap = this.options && this.options.wrap ? this.options.wrap : _threeModuleJs.RepeatWrapping;
};
MTLLoader.MaterialCreator.prototype = {
    constructor: MTLLoader.MaterialCreator,
    crossOrigin: 'anonymous',
    setCrossOrigin: function(value) {
        this.crossOrigin = value;
        return this;
    },
    setManager: function(value) {
        this.manager = value;
    },
    setMaterials: function(materialsInfo) {
        this.materialsInfo = this.convert(materialsInfo);
        this.materials = {};
        this.materialsArray = [];
        this.nameLookup = {};
    },
    convert: function(materialsInfo) {
        if (!this.options) return materialsInfo;
        var converted = {};
        for(var mn in materialsInfo){
            // Convert materials info into normalized form based on options
            var mat = materialsInfo[mn];
            var covmat = {};
            converted[mn] = covmat;
            for(var prop in mat){
                var save = true;
                var value = mat[prop];
                var lprop = prop.toLowerCase();
                switch(lprop){
                    case 'kd':
                    case 'ka':
                    case 'ks':
                        // Diffuse color (color under white light) using RGB values
                        if (this.options && this.options.normalizeRGB) value = [
                            value[0] / 255,
                            value[1] / 255,
                            value[2] / 255
                        ];
                        if (this.options && this.options.ignoreZeroRGBs) {
                            if (value[0] === 0 && value[1] === 0 && value[2] === 0) // ignore
                            save = false;
                        }
                        break;
                    default:
                        break;
                }
                if (save) covmat[lprop] = value;
            }
        }
        return converted;
    },
    preload: function() {
        for(var mn in this.materialsInfo)this.create(mn);
    },
    getIndex: function(materialName) {
        return this.nameLookup[materialName];
    },
    getAsArray: function() {
        var index = 0;
        for(var mn in this.materialsInfo){
            this.materialsArray[index] = this.create(mn);
            this.nameLookup[mn] = index;
            index++;
        }
        return this.materialsArray;
    },
    create: function(materialName) {
        if (this.materials[materialName] === undefined) this.createMaterial_(materialName);
        return this.materials[materialName];
    },
    createMaterial_: function(materialName) {
        // Create material
        var scope = this;
        var mat = this.materialsInfo[materialName];
        var params = {
            name: materialName,
            side: this.side
        };
        function resolveURL(baseUrl, url) {
            if (typeof url !== 'string' || url === '') return '';
            // Absolute URL
            if (/^https?:\/\//i.test(url)) return url;
            return baseUrl + url;
        }
        function setMapForType(mapType, value) {
            if (params[mapType]) return; // Keep the first encountered texture
            var texParams = scope.getTextureParams(value, params);
            var map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));
            map.repeat.copy(texParams.scale);
            map.offset.copy(texParams.offset);
            map.wrapS = scope.wrap;
            map.wrapT = scope.wrap;
            params[mapType] = map;
        }
        for(var prop in mat){
            var value1 = mat[prop];
            var n;
            if (value1 === '') continue;
            switch(prop.toLowerCase()){
                // Ns is material specular exponent
                case 'kd':
                    // Diffuse color (color under white light) using RGB values
                    params.color = new _threeModuleJs.Color().fromArray(value1);
                    break;
                case 'ks':
                    // Specular color (color when light is reflected from shiny surface) using RGB values
                    params.specular = new _threeModuleJs.Color().fromArray(value1);
                    break;
                case 'ke':
                    // Emissive using RGB values
                    params.emissive = new _threeModuleJs.Color().fromArray(value1);
                    break;
                case 'map_kd':
                    // Diffuse texture map
                    setMapForType("map", value1);
                    break;
                case 'map_ks':
                    // Specular map
                    setMapForType("specularMap", value1);
                    break;
                case 'map_ke':
                    // Emissive map
                    setMapForType("emissiveMap", value1);
                    break;
                case 'norm':
                    setMapForType("normalMap", value1);
                    break;
                case 'map_bump':
                case 'bump':
                    // Bump texture map
                    setMapForType("bumpMap", value1);
                    break;
                case 'map_d':
                    // Alpha map
                    setMapForType("alphaMap", value1);
                    params.transparent = true;
                    break;
                case 'ns':
                    // The specular exponent (defines the focus of the specular highlight)
                    // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.
                    params.shininess = parseFloat(value1);
                    break;
                case 'd':
                    n = parseFloat(value1);
                    if (n < 1) {
                        params.opacity = n;
                        params.transparent = true;
                    }
                    break;
                case 'tr':
                    n = parseFloat(value1);
                    if (this.options && this.options.invertTrProperty) n = 1 - n;
                    if (n > 0) {
                        params.opacity = 1 - n;
                        params.transparent = true;
                    }
                    break;
                default:
                    break;
            }
        }
        this.materials[materialName] = new _threeModuleJs.MeshPhongMaterial(params);
        return this.materials[materialName];
    },
    getTextureParams: function(value, matParams) {
        var texParams = {
            scale: new _threeModuleJs.Vector2(1, 1),
            offset: new _threeModuleJs.Vector2(0, 0)
        };
        var items = value.split(/\s+/);
        var pos;
        pos = items.indexOf('-bm');
        if (pos >= 0) {
            matParams.bumpScale = parseFloat(items[pos + 1]);
            items.splice(pos, 2);
        }
        pos = items.indexOf('-s');
        if (pos >= 0) {
            texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
            items.splice(pos, 4); // we expect 3 parameters here!
        }
        pos = items.indexOf('-o');
        if (pos >= 0) {
            texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
            items.splice(pos, 4); // we expect 3 parameters here!
        }
        texParams.url = items.join(' ').trim();
        return texParams;
    },
    loadTexture: function(url, mapping, onLoad, onProgress, onError) {
        var texture;
        var manager = this.manager !== undefined ? this.manager : _threeModuleJs.DefaultLoadingManager;
        var loader = manager.getHandler(url);
        if (loader === null) loader = new _threeModuleJs.TextureLoader(manager);
        if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);
        texture = loader.load(url, onLoad, onProgress, onError);
        if (mapping !== undefined) texture.mapping = mapping;
        return texture;
    }
};

},{"../../../build/three.module.js":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"htIhD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OBJLoader", ()=>OBJLoader
);
/**
 * @author mrdoob / http://mrdoob.com/
 */ var _threeModuleJs = require("../../../build/three.module.js");
var OBJLoader = function() {
    // o object_name | g group_name
    var object_pattern = /^[og]\s*(.+)?/;
    // mtllib file_reference
    var material_library_pattern = /^mtllib /;
    // usemtl material_name
    var material_use_pattern = /^usemtl /;
    // usemap map_name
    var map_use_pattern = /^usemap /;
    var vA = new _threeModuleJs.Vector3();
    var vB = new _threeModuleJs.Vector3();
    var vC = new _threeModuleJs.Vector3();
    var ab = new _threeModuleJs.Vector3();
    var cb = new _threeModuleJs.Vector3();
    function ParserState() {
        var state = {
            objects: [],
            object: {},
            vertices: [],
            normals: [],
            colors: [],
            uvs: [],
            materials: {},
            materialLibraries: [],
            startObject: function(name1, fromDeclaration) {
                // If the current object (initial from reset) is not from a g/o declaration in the parsed
                // file. We need to use it for the first parsed g/o to keep things in sync.
                if (this.object && this.object.fromDeclaration === false) {
                    this.object.name = name1;
                    this.object.fromDeclaration = fromDeclaration !== false;
                    return;
                }
                var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;
                if (this.object && typeof this.object._finalize === 'function') this.object._finalize(true);
                this.object = {
                    name: name1 || '',
                    fromDeclaration: fromDeclaration !== false,
                    geometry: {
                        vertices: [],
                        normals: [],
                        colors: [],
                        uvs: [],
                        hasNormalIndices: false,
                        hasUVIndices: false
                    },
                    materials: [],
                    smooth: true,
                    startMaterial: function(name, libraries) {
                        var previous = this._finalize(false);
                        // New usemtl declaration overwrites an inherited material, except if faces were declared
                        // after the material, then it must be preserved for proper MultiMaterial continuation.
                        if (previous && (previous.inherited || previous.groupCount <= 0)) this.materials.splice(previous.index, 1);
                        var material = {
                            index: this.materials.length,
                            name: name || '',
                            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',
                            smooth: previous !== undefined ? previous.smooth : this.smooth,
                            groupStart: previous !== undefined ? previous.groupEnd : 0,
                            groupEnd: -1,
                            groupCount: -1,
                            inherited: false,
                            clone: function(index) {
                                var cloned = {
                                    index: typeof index === 'number' ? index : this.index,
                                    name: this.name,
                                    mtllib: this.mtllib,
                                    smooth: this.smooth,
                                    groupStart: 0,
                                    groupEnd: -1,
                                    groupCount: -1,
                                    inherited: false
                                };
                                cloned.clone = this.clone.bind(cloned);
                                return cloned;
                            }
                        };
                        this.materials.push(material);
                        return material;
                    },
                    currentMaterial: function() {
                        if (this.materials.length > 0) return this.materials[this.materials.length - 1];
                        return undefined;
                    },
                    _finalize: function(end) {
                        var lastMultiMaterial = this.currentMaterial();
                        if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
                            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                            lastMultiMaterial.inherited = false;
                        }
                        // Ignore objects tail materials if no face declarations followed them before a new o/g started.
                        if (end && this.materials.length > 1) {
                            for(var mi = this.materials.length - 1; mi >= 0; mi--)if (this.materials[mi].groupCount <= 0) this.materials.splice(mi, 1);
                        }
                        // Guarantee at least one empty material, this makes the creation later more straight forward.
                        if (end && this.materials.length === 0) this.materials.push({
                            name: '',
                            smooth: this.smooth
                        });
                        return lastMultiMaterial;
                    }
                };
                // Inherit previous objects material.
                // Spec tells us that a declared material must be set to all objects until a new material is declared.
                // If a usemtl declaration is encountered while this new object is being parsed, it will
                // overwrite the inherited material. Exception being that there was already face declarations
                // to the inherited material, then it will be preserved for proper MultiMaterial continuation.
                if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {
                    var declared = previousMaterial.clone(0);
                    declared.inherited = true;
                    this.object.materials.push(declared);
                }
                this.objects.push(this.object);
            },
            finalize: function() {
                if (this.object && typeof this.object._finalize === 'function') this.object._finalize(true);
            },
            parseVertexIndex: function(value, len) {
                var index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 3) * 3;
            },
            parseNormalIndex: function(value, len) {
                var index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 3) * 3;
            },
            parseUVIndex: function(value, len) {
                var index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 2) * 2;
            },
            addVertex: function(a, b, c) {
                var src = this.vertices;
                var dst = this.object.geometry.vertices;
                dst.push(src[a + 0], src[a + 1], src[a + 2]);
                dst.push(src[b + 0], src[b + 1], src[b + 2]);
                dst.push(src[c + 0], src[c + 1], src[c + 2]);
            },
            addVertexPoint: function(a) {
                var src = this.vertices;
                var dst = this.object.geometry.vertices;
                dst.push(src[a + 0], src[a + 1], src[a + 2]);
            },
            addVertexLine: function(a) {
                var src = this.vertices;
                var dst = this.object.geometry.vertices;
                dst.push(src[a + 0], src[a + 1], src[a + 2]);
            },
            addNormal: function(a, b, c) {
                var src = this.normals;
                var dst = this.object.geometry.normals;
                dst.push(src[a + 0], src[a + 1], src[a + 2]);
                dst.push(src[b + 0], src[b + 1], src[b + 2]);
                dst.push(src[c + 0], src[c + 1], src[c + 2]);
            },
            addFaceNormal: function(a, b, c) {
                var src = this.vertices;
                var dst = this.object.geometry.normals;
                vA.fromArray(src, a);
                vB.fromArray(src, b);
                vC.fromArray(src, c);
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                cb.normalize();
                dst.push(cb.x, cb.y, cb.z);
                dst.push(cb.x, cb.y, cb.z);
                dst.push(cb.x, cb.y, cb.z);
            },
            addColor: function(a, b, c) {
                var src = this.colors;
                var dst = this.object.geometry.colors;
                if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2]);
                if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2]);
                if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2]);
            },
            addUV: function(a, b, c) {
                var src = this.uvs;
                var dst = this.object.geometry.uvs;
                dst.push(src[a + 0], src[a + 1]);
                dst.push(src[b + 0], src[b + 1]);
                dst.push(src[c + 0], src[c + 1]);
            },
            addDefaultUV: function() {
                var dst = this.object.geometry.uvs;
                dst.push(0, 0);
                dst.push(0, 0);
                dst.push(0, 0);
            },
            addUVLine: function(a) {
                var src = this.uvs;
                var dst = this.object.geometry.uvs;
                dst.push(src[a + 0], src[a + 1]);
            },
            addFace: function(a, b, c, ua, ub, uc, na, nb, nc) {
                var vLen = this.vertices.length;
                var ia = this.parseVertexIndex(a, vLen);
                var ib = this.parseVertexIndex(b, vLen);
                var ic = this.parseVertexIndex(c, vLen);
                this.addVertex(ia, ib, ic);
                this.addColor(ia, ib, ic);
                // normals
                if (na !== undefined && na !== '') {
                    var nLen = this.normals.length;
                    ia = this.parseNormalIndex(na, nLen);
                    ib = this.parseNormalIndex(nb, nLen);
                    ic = this.parseNormalIndex(nc, nLen);
                    this.addNormal(ia, ib, ic);
                    this.object.geometry.hasNormalIndices = true;
                } else this.addFaceNormal(ia, ib, ic);
                // uvs
                if (ua !== undefined && ua !== '') {
                    var uvLen = this.uvs.length;
                    ia = this.parseUVIndex(ua, uvLen);
                    ib = this.parseUVIndex(ub, uvLen);
                    ic = this.parseUVIndex(uc, uvLen);
                    this.addUV(ia, ib, ic);
                    this.object.geometry.hasUVIndices = true;
                } else // add placeholder values (for inconsistent face definitions)
                this.addDefaultUV();
            },
            addPointGeometry: function(vertices) {
                this.object.geometry.type = 'Points';
                var vLen = this.vertices.length;
                for(var vi = 0, l = vertices.length; vi < l; vi++)this.addVertexPoint(this.parseVertexIndex(vertices[vi], vLen));
            },
            addLineGeometry: function(vertices, uvs) {
                this.object.geometry.type = 'Line';
                var vLen = this.vertices.length;
                var uvLen = this.uvs.length;
                for(var vi = 0, l = vertices.length; vi < l; vi++)this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
                for(var uvi = 0, l = uvs.length; uvi < l; uvi++)this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
            }
        };
        state.startObject('', false);
        return state;
    }
    //
    function OBJLoader1(manager) {
        _threeModuleJs.Loader.call(this, manager);
        this.materials = null;
    }
    OBJLoader1.prototype = Object.assign(Object.create(_threeModuleJs.Loader.prototype), {
        constructor: OBJLoader1,
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new _threeModuleJs.FileLoader(scope.manager);
            loader.setPath(this.path);
            loader.load(url, function(text) {
                try {
                    onLoad(scope.parse(text));
                } catch (e) {
                    if (onError) onError(e);
                    else console.error(e);
                    scope.manager.itemError(url);
                }
            }, onProgress, onError);
        },
        setMaterials: function(materials) {
            this.materials = materials;
            return this;
        },
        parse: function(text) {
            var state = new ParserState();
            if (text.indexOf('\r\n') !== -1) // This is faster than String.split with regex that splits on both
            text = text.replace(/\r\n/g, '\n');
            if (text.indexOf('\\\n') !== -1) // join lines separated by a line continuation character (\)
            text = text.replace(/\\\n/g, '');
            var lines = text.split('\n');
            var line = '', lineFirstChar = '';
            var lineLength = 0;
            var result = [];
            // Faster to just trim left side of the line. Use if available.
            var trimLeft = typeof ''.trimLeft === 'function';
            for(var i = 0, l = lines.length; i < l; i++){
                line = lines[i];
                line = trimLeft ? line.trimLeft() : line.trim();
                lineLength = line.length;
                if (lineLength === 0) continue;
                lineFirstChar = line.charAt(0);
                // @todo invoke passed in handler if any
                if (lineFirstChar === '#') continue;
                if (lineFirstChar === 'v') {
                    var data = line.split(/\s+/);
                    switch(data[0]){
                        case 'v':
                            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                            if (data.length >= 7) state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));
                            else // if no colors are defined, add placeholders so color and vertex indices match
                            state.colors.push(undefined, undefined, undefined);
                            break;
                        case 'vn':
                            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                            break;
                        case 'vt':
                            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
                            break;
                    }
                } else if (lineFirstChar === 'f') {
                    var lineData = line.substr(1).trim();
                    var vertexData = lineData.split(/\s+/);
                    var faceVertices = [];
                    // Parse the face vertex data into an easy to work with format
                    for(var j = 0, jl = vertexData.length; j < jl; j++){
                        var vertex = vertexData[j];
                        if (vertex.length > 0) {
                            var vertexParts = vertex.split('/');
                            faceVertices.push(vertexParts);
                        }
                    }
                    // Draw an edge between the first vertex and all subsequent vertices to form an n-gon
                    var v1 = faceVertices[0];
                    for(var j = 1, jl = faceVertices.length - 1; j < jl; j++){
                        var v2 = faceVertices[j];
                        var v3 = faceVertices[j + 1];
                        state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
                    }
                } else if (lineFirstChar === 'l') {
                    var lineParts = line.substring(1).trim().split(" ");
                    var lineVertices = [], lineUVs = [];
                    if (line.indexOf("/") === -1) lineVertices = lineParts;
                    else for(var li = 0, llen = lineParts.length; li < llen; li++){
                        var parts = lineParts[li].split("/");
                        if (parts[0] !== "") lineVertices.push(parts[0]);
                        if (parts[1] !== "") lineUVs.push(parts[1]);
                    }
                    state.addLineGeometry(lineVertices, lineUVs);
                } else if (lineFirstChar === 'p') {
                    var lineData = line.substr(1).trim();
                    var pointData = lineData.split(" ");
                    state.addPointGeometry(pointData);
                } else if ((result = object_pattern.exec(line)) !== null) {
                    // o object_name
                    // or
                    // g group_name
                    // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
                    // var name = result[ 0 ].substr( 1 ).trim();
                    var name = (" " + result[0].substr(1).trim()).substr(1);
                    state.startObject(name);
                } else if (material_use_pattern.test(line)) // material
                state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
                else if (material_library_pattern.test(line)) // mtl file
                state.materialLibraries.push(line.substring(7).trim());
                else if (map_use_pattern.test(line)) // the line is parsed but ignored since the loader assumes textures are defined MTL files
                // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)
                console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
                else if (lineFirstChar === 's') {
                    result = line.split(' ');
                    // smooth shading
                    // @todo Handle files that have varying smooth values for a set of faces inside one geometry,
                    // but does not define a usemtl for each face set.
                    // This should be detected and a dummy material created (later MultiMaterial and geometry groups).
                    // This requires some care to not create extra material on each smooth value for "normal" obj files.
                    // where explicit usemtl defines geometry groups.
                    // Example asset: examples/models/obj/cerberus/Cerberus.obj
                    /*
					 * http://paulbourke.net/dataformats/obj/
					 * or
					 * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf
					 *
					 * From chapter "Grouping" Syntax explanation "s group_number":
					 * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
					 * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
					 * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
					 * than 0."
					 */ if (result.length > 1) {
                        var value = result[1].trim().toLowerCase();
                        state.object.smooth = value !== '0' && value !== 'off';
                    } else // ZBrush can produce "s" lines #11707
                    state.object.smooth = true;
                    var material = state.object.currentMaterial();
                    if (material) material.smooth = state.object.smooth;
                } else {
                    // Handle null terminated files without exception
                    if (line === '\0') continue;
                    console.warn('THREE.OBJLoader: Unexpected line: "' + line + '"');
                }
            }
            state.finalize();
            var container = new _threeModuleJs.Group();
            container.materialLibraries = [].concat(state.materialLibraries);
            for(var i = 0, l = state.objects.length; i < l; i++){
                var object = state.objects[i];
                var geometry = object.geometry;
                var materials = object.materials;
                var isLine = geometry.type === 'Line';
                var isPoints = geometry.type === 'Points';
                var hasVertexColors = false;
                // Skip o/g line declarations that did not follow with any faces
                if (geometry.vertices.length === 0) continue;
                var buffergeometry = new _threeModuleJs.BufferGeometry();
                buffergeometry.setAttribute('position', new _threeModuleJs.Float32BufferAttribute(geometry.vertices, 3));
                if (geometry.hasNormalIndices === true) buffergeometry.setAttribute('normal', new _threeModuleJs.Float32BufferAttribute(geometry.normals, 3));
                if (geometry.colors.length > 0) {
                    hasVertexColors = true;
                    buffergeometry.setAttribute('color', new _threeModuleJs.Float32BufferAttribute(geometry.colors, 3));
                }
                if (geometry.hasUVIndices === true) buffergeometry.setAttribute('uv', new _threeModuleJs.Float32BufferAttribute(geometry.uvs, 2));
                // Create materials
                var createdMaterials = [];
                for(var mi = 0, miLen = materials.length; mi < miLen; mi++){
                    var sourceMaterial = materials[mi];
                    var materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;
                    var material = state.materials[materialHash];
                    if (this.materials !== null) {
                        material = this.materials.create(sourceMaterial.name);
                        // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
                        if (isLine && material && !(material instanceof _threeModuleJs.LineBasicMaterial)) {
                            var materialLine = new _threeModuleJs.LineBasicMaterial();
                            _threeModuleJs.Material.prototype.copy.call(materialLine, material);
                            materialLine.color.copy(material.color);
                            material = materialLine;
                        } else if (isPoints && material && !(material instanceof _threeModuleJs.PointsMaterial)) {
                            var materialPoints = new _threeModuleJs.PointsMaterial({
                                size: 10,
                                sizeAttenuation: false
                            });
                            _threeModuleJs.Material.prototype.copy.call(materialPoints, material);
                            materialPoints.color.copy(material.color);
                            materialPoints.map = material.map;
                            material = materialPoints;
                        }
                    }
                    if (material === undefined) {
                        if (isLine) material = new _threeModuleJs.LineBasicMaterial();
                        else if (isPoints) material = new _threeModuleJs.PointsMaterial({
                            size: 1,
                            sizeAttenuation: false
                        });
                        else material = new _threeModuleJs.MeshPhongMaterial();
                        material.name = sourceMaterial.name;
                        material.flatShading = sourceMaterial.smooth ? false : true;
                        material.vertexColors = hasVertexColors;
                        state.materials[materialHash] = material;
                    }
                    createdMaterials.push(material);
                }
                // Create mesh
                var mesh;
                if (createdMaterials.length > 1) {
                    for(var mi = 0, miLen = materials.length; mi < miLen; mi++){
                        var sourceMaterial = materials[mi];
                        buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
                    }
                    if (isLine) mesh = new _threeModuleJs.LineSegments(buffergeometry, createdMaterials);
                    else if (isPoints) mesh = new _threeModuleJs.Points(buffergeometry, createdMaterials);
                    else mesh = new _threeModuleJs.Mesh(buffergeometry, createdMaterials);
                } else {
                    if (isLine) mesh = new _threeModuleJs.LineSegments(buffergeometry, createdMaterials[0]);
                    else if (isPoints) mesh = new _threeModuleJs.Points(buffergeometry, createdMaterials[0]);
                    else mesh = new _threeModuleJs.Mesh(buffergeometry, createdMaterials[0]);
                }
                mesh.name = object.name;
                container.add(mesh);
            }
            return container;
        }
    });
    return OBJLoader1;
}();

},{"../../../build/three.module.js":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"6tk2H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
var _defaultVectors = require("../DEFAULT_VECTORS");
var _defaultVectorsDefault = parcelHelpers.interopDefault(_defaultVectors);
var _bounds = require("./Bounds");
var _boundsDefault = parcelHelpers.interopDefault(_bounds);
var _force = require("./Force");
var _forceDefault = parcelHelpers.interopDefault(_force);
var _velocity = require("./Velocity");
var _velocityDefault = parcelHelpers.interopDefault(_velocity);
class PhysicsBody {
    // #region Properties (22)
    static EPSILON = 0.001;
    // #endregion Properties (22)
    // #region Constructors (1)
    constructor(colliders){
        this.acceleration = 1;
        this.followTerrain = false;
        this.isStatic = false;
        this.bounciness = 0.1;
        this._colliders = colliders || [];
        this._bounds = new _boundsDefault.default(this._colliders);
        this._worldBounds = this._bounds.clone();
        this._forceBuffer = Array();
        this._moveBuffer = Array();
        this._turnBuffer = Array();
        this._currentVelocity = new _velocityDefault.default(new _three.Vector3(), 0);
        this._targetVelocity = new _velocityDefault.default(new _three.Vector3(), 0);
        this._targetForce = new _forceDefault.default(new _three.Vector3(), 0);
        this._colliders = [];
        this._matrixWorld = new _three.Matrix4();
        this._position = new _three.Vector3();
        this._orientation = new _three.Quaternion();
        this._scale = new _three.Vector3(1, 1, 1);
        this._tempMatrix = new _three.Matrix4();
    }
    // #region Public Accessors (11)
    get bounds() {
        return this._bounds;
    }
    get colliders() {
        return this._colliders;
    }
    get forward() {
        let r = this.resolveTurns();
        let q = new _three.Quaternion();
        q.copy(this.orientation);
        q.multiply(r); // This gives us the new rotation of the object in 'q'
        return _defaultVectorsDefault.default.forward.applyQuaternion(q).normalize();
    }
    get matrixWorld() {
        return this._matrixWorld;
    }
    get numMoves() {
        return this._moveBuffer.length;
    }
    get orientation() {
        // return this._orientation.setFromRotationMatrix(this._matrixWorld).normalize();
        this._matrixWorld.decompose(this._position, this._orientation, this._scale);
        return this._orientation;
    }
    get position() {
        return this._position.setFromMatrixPosition(this._matrixWorld);
    }
    get right() {
        return new _three.Vector3().crossVectors(this.forward, _defaultVectorsDefault.default.up).normalize();
    }
    get scale() {
        this._matrixWorld.decompose(this._position, this._orientation, this._scale);
        return this._scale;
    }
    get velocity() {
        return this._currentVelocity;
    }
    get worldBounds() {
        return this._worldBounds.copy(this._bounds).applyMatrix4(this._matrixWorld);
    }
    // #region Public Methods (21)
    addCollider(collider) {
        this._colliders.push(collider); // Recalculate bounds
        this._bounds = new _boundsDefault.default(this._colliders);
    }
    applyForce(f) {
        if (f instanceof _forceDefault.default && !this.isStatic) this._forceBuffer.push(f);
        return this;
    }
    /** Adds the given position vector to the current position
   * @param vec The vector to apply to the current position
   */ applyPosition(vec) {
        this._matrixWorld.setPosition(this.position.clone().add(vec));
    }
    getColliderWorldMatrix(collider) {
        this._tempMatrix.multiplyMatrices(this.matrixWorld, collider.matrix);
        return this._tempMatrix;
    }
    move(v) {
        if (v instanceof _velocityDefault.default && !this.isStatic) this._moveBuffer.push(v);
        return this; // so we can chain moves/turns
    }
    resetForces() {
        delete this._forceBuffer;
        this._forceBuffer = Array();
    }
    resetMoves() {
        delete this._moveBuffer;
        this._moveBuffer = Array();
    }
    resetTurns() {
        delete this._turnBuffer;
        this._turnBuffer = Array();
    }
    resetVelocity() {
        this._currentVelocity = new _velocityDefault.default();
        this._targetVelocity = new _velocityDefault.default();
    }
    resolveForces() {
        let result = new _forceDefault.default();
        for(let i = 0; i < this._forceBuffer.length; i++)result = result.add(this._forceBuffer[i]);
        delete this._forceBuffer;
        this._forceBuffer = [
            result
        ];
        return result;
    }
    resolveMoves() {
        let result = new _velocityDefault.default();
        for(let i = 0; i < this._moveBuffer.length; i++)result = result.add(this._moveBuffer[i]);
        return result;
    }
    resolveTurns() {
        let result = new _three.Quaternion();
        for(let i = 0; i < this._turnBuffer.length; i++)result.multiply(this._turnBuffer[i]);
        return result.normalize();
    }
    resolveVelocity(deltaTime) {
        // Calculate current velocity from target speed and acceleration
        let targetVelocity = this.resolveMoves(); // Resolve any forces applied
        let targetForce = this.resolveForces();
        return targetVelocity.add(new _velocityDefault.default(targetForce.direction, targetForce.acceleration * deltaTime));
    }
    setOrientation(q) {
        this._matrixWorld.decompose(this._position, this._orientation, this._scale);
        this._matrixWorld.compose(this._position, q, this._scale);
    }
    setPosition(x, y, z) {
        if (x instanceof _three.Vector3) this._matrixWorld.setPosition(x);
        else this._matrixWorld.setPosition(x, y, z);
    }
    setScale(linearScale) {
        let newScale = new _three.Vector3(linearScale, linearScale, linearScale);
        this._matrixWorld.decompose(this._position, this._orientation, this._scale);
        this._matrixWorld.compose(this._position, this._orientation, newScale);
    }
    turn(q) {
        if (typeof q === "object" && q.isQuaternion && !this.isStatic) this._turnBuffer.push(q);
        return this; // so we can chain moves/turns
    }
    undoForces(n) {
        if (n > 0) this._forceBuffer = this._forceBuffer.slice(0, -Math.min(n, this._forceBuffer.length));
    }
    undoMoves(n) {
        if (n > 0) this._moveBuffer = this._moveBuffer.slice(0, -Math.min(n, this._moveBuffer.length));
    }
    undoTurns(n) {
        if (n > 0) this._turnBuffer = this._turnBuffer.slice(0, -Math.min(n, this._turnBuffer.length));
    }
    update(gameTime) {
        if (this.onPreUpdate) this.onPreUpdate(gameTime, this);
        this._targetVelocity = this.resolveVelocity(gameTime.deltaTime);
        let velocityDiff = this._targetVelocity.sub(this._currentVelocity);
        if (Math.abs(velocityDiff.speed) > PhysicsBody.EPSILON) this._currentVelocity = this._currentVelocity.accelerateTo(this._targetVelocity, gameTime.deltaTime * this.acceleration);
        else // Eliminate really small differences in velocity
        this._currentVelocity.copy(this._targetVelocity);
        this.setPosition(this.position.clone().add(this._currentVelocity.resolve(gameTime.deltaTime)));
        this.setOrientation(this.orientation.clone().multiply(this.resolveTurns()));
        if (this.onPostUpdate) this.onPostUpdate(gameTime, this);
        else if (PhysicsBody.onUpdate) PhysicsBody.onUpdate(gameTime, this);
    }
}
exports.default = PhysicsBody;

},{"three":"ktPTu","../DEFAULT_VECTORS":"4oEJD","./Bounds":"5jh0l","./Force":"5gIXl","./Velocity":"fsoO0","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"4oEJD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
exports.default = {
    get right () {
        return new _three.Vector3(1, 0, 0);
    },
    get left () {
        return new _three.Vector3(1, 0, 0);
    },
    get up () {
        return new _three.Vector3(0, 1, 0);
    },
    get down () {
        return new _three.Vector3(0, -1, 0);
    },
    get forward () {
        return new _three.Vector3(0, 0, -1);
    },
    get back () {
        return new _three.Vector3(0, 0, 1);
    }
};

},{"three":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"5jh0l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
class Bounds extends _three.Box3 {
    // #region Constructors (1)
    constructor(colliders){
        super();
        if (colliders) for(let i = 0; i < colliders.length; i++){
            let collider = colliders[i];
            let bbox = collider.getBoundingBox();
            this.union(bbox);
        }
    }
}
exports.default = Bounds;

},{"three":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"5gIXl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
class Force {
    // #region Properties (2)
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(direction, acceleration){
        if (direction === undefined && acceleration === undefined) {
            this._direction = new _three.Vector3();
            this._acceleration = 0;
        } else if (direction instanceof _three.Vector3 && (Number.isFinite(acceleration) || typeof acceleration === "function")) {
            this._direction = direction;
            this._acceleration = acceleration;
        } else throw "Invalid parameters while instantiating " + Force.name;
    }
    // #region Public Accessors (2)
    get acceleration() {
        return this._acceleration;
    }
    get direction() {
        return this._direction.clone().normalize();
    }
    // #region Public Methods (4)
    add(force) {
        if (force instanceof Force) {
            let r = this.resolve().add(force.resolve());
            let s = r.length();
            return new Force(r.normalize(), s);
        } else throw "Invalid parameters passed to 'add' function";
    }
    copy(force) {
        this._direction = force.direction.clone();
        this._acceleration = force.acceleration;
    }
    resolve() {
        return this._direction.clone().multiplyScalar(this._acceleration);
    }
    sub(force) {
        if (force instanceof Force) {
            let r = this.resolve().sub(force.resolve());
            let s = r.length();
            return new Force(r.normalize(), s);
        } else throw "Invalid parameters passed to 'sub' function";
    }
}
exports.default = Force;

},{"three":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"fsoO0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
class Velocity {
    // #region Properties (4)
    static from = (vector)=>{
        let len = vector.length();
        return new Velocity(vector.clone().normalize(), len);
    };
    // #region Constructors (1)
    // | Function;
    constructor(direction, speed){
        this._direction;
        this._speed;
        this._temp = new _three.Vector3();
        if (direction === undefined && speed === undefined) {
            this._direction = new _three.Vector3();
            this._speed = 0;
        } else if (direction instanceof _three.Vector3 && Number.isFinite(speed)) {
            this._direction = direction;
            this._speed = Math.round(speed * 10000) / 10000;
        } else if (typeof speed === "function") {
            this._direction = direction;
            this._speed = speed;
        } else throw "Invalid parameters while instantiating " + Velocity.name;
    }
    // #region Public Accessors (2)
    get direction() {
        return this._temp.copy(this._direction).normalize();
    }
    get speed() {
        return this._speed;
    }
    // #region Public Methods (6)
    accelerateTo(v, acc) {
        let vi = this.resolve();
        let vt = v.resolve();
        let r = vi.lerp(vt, acc);
        let s = r.length();
        return new Velocity(r.normalize(), s);
    }
    add(v) {
        if (v instanceof Velocity) {
            let r = this.resolve().add(v.resolve());
            let s = r.length();
            return new Velocity(r.normalize(), s);
        } else throw "Invalid parameters passed to 'add' function";
    }
    copy(v) {
        this._direction = v.direction;
        this._speed = v.speed;
    }
    multiplyScalar(s) {
        let r = this.resolve().multiplyScalar(s);
        return new Velocity(this._temp.copy(r).normalize(), r.length());
    }
    resolve(deltaTime) {
        // let s = typeof this._speed === "function" ? this._speed() : this._speed;
        let s = this._speed;
        return deltaTime ? this._temp.copy(this._direction).multiplyScalar(s * deltaTime) : this._temp.copy(this._direction).multiplyScalar(s);
    }
    sub(v) {
        if (v instanceof Velocity) {
            let r = this.resolve().sub(v.resolve());
            let s = r.length();
            return new Velocity(r.normalize(), s);
        } else throw "Invalid parameters passed to 'sub' function";
    }
}
exports.default = Velocity;

},{"three":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"ky7np":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
var _defaultVectors = require("../DEFAULT_VECTORS");
var _defaultVectorsDefault = parcelHelpers.interopDefault(_defaultVectors);
var _broadPhase = require("./BroadPhase");
var _broadPhaseDefault = parcelHelpers.interopDefault(_broadPhase);
var _force = require("./Force");
var _forceDefault = parcelHelpers.interopDefault(_force);
var _narrowPhase = require("./NarrowPhase");
var _narrowPhaseDefault = parcelHelpers.interopDefault(_narrowPhase);
var _terrainPhysicsBody = require("./TerrainPhysicsBody");
var _terrainPhysicsBodyDefault = parcelHelpers.interopDefault(_terrainPhysicsBody);
class PhysicsScene {
    // #region Properties (5)
    static maxIterationsPerPass = 10;
    // #endregion Properties (5)
    // #region Constructors (1)
    constructor(){
        this._sceneEntities = Array();
        this._entitySize = new _three.Vector3();
        this.gAcceleration = 30;
    }
    // #region Public Accessors (2)
    get entities() {
        return this._sceneEntities;
    }
    get terrain() {
        return this._terrain;
    }
    // #region Public Methods (3)
    add(physicsBody) {
        if (physicsBody instanceof _terrainPhysicsBodyDefault.default) this._terrain = physicsBody;
        else this._sceneEntities.push(physicsBody);
    }
    remove(physicsBody) {
        this._sceneEntities = this._sceneEntities.filter((x)=>x !== physicsBody
        );
    }
    update(gameTime) {
        if (this._sceneEntities.length > 1) {
            let collisionsOccurred = true;
            let iteration = 0;
            while(collisionsOccurred && iteration < PhysicsScene.maxIterationsPerPass){
                iteration++;
                let broadPhaseResult = _broadPhaseDefault.default(this._sceneEntities);
                collisionsOccurred = _narrowPhaseDefault.default(broadPhaseResult, gameTime);
            }
        } // Terrain gravity handling is a different beast...
        for(let i = 0; i < this._sceneEntities.length; i++){
            let entity = this._sceneEntities[i];
            if (this._terrain && entity.followTerrain) {
                let targetPos = entity.position.clone();
                let terrainHeight = this._terrain.heightAt(entity.position.x, entity.position.z);
                entity.bounds.getSize(this._entitySize);
                this._entitySize.multiply(entity.scale);
                targetPos.y = (terrainHeight ? terrainHeight.h : targetPos.y) + this._entitySize.y;
                if (entity.position.y <= targetPos.y) {
                    entity.setPosition(targetPos); // entity.position.y = targetPos.y;
                    entity.resetForces();
                } else // Apply gravity
                entity.applyForce(new _forceDefault.default(_defaultVectorsDefault.default.down, this.gAcceleration));
            }
            entity.update(gameTime);
            entity.resetMoves();
            entity.resetTurns();
        }
    }
}
exports.default = PhysicsScene;

},{"three":"ktPTu","../DEFAULT_VECTORS":"4oEJD","./BroadPhase":"hV1hs","./Force":"5gIXl","./NarrowPhase":"9zNk1","./TerrainPhysicsBody":"9REyN","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"hV1hs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function BroadPhase(sceneEntities) {
    let result = {
        pairs: []
    }; // let worldBoundsA = new Box3();
    // let worldBoundsB = new Box3();
    for(let i = 0; i < sceneEntities.length; i++){
        let bodyA = sceneEntities[i];
        for(let j = i + 1; j < sceneEntities.length; j++){
            let bodyB = sceneEntities[j]; // worldBoundsA.copy(bodyA.bounds).applyMatrix4(bodyA.matrixWorld);
            // worldBoundsB.copy(bodyB.bounds).applyMatrix4(bodyB.matrixWorld);
            if (bodyA.worldBounds.intersectsBox(bodyB.worldBounds)) result.pairs.push({
                bodyA,
                bodyB
            });
        }
    }
    return result;
}
exports.default = BroadPhase;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"9zNk1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _boxCollider = require("./Colliders/BoxCollider");
var _boxColliderDefault = parcelHelpers.interopDefault(_boxCollider);
var _sphereCollider = require("./Colliders/SphereCollider");
var _sphereColliderDefault = parcelHelpers.interopDefault(_sphereCollider);
var _physicsBodyBoxResolver = require("./Resolvers/PhysicsBodyBoxResolver");
var _physicsBodyBoxResolverDefault = parcelHelpers.interopDefault(_physicsBodyBoxResolver);
var _physicsBodySphereResolver = require("./Resolvers/PhysicsBodySphereResolver");
var _physicsBodySphereResolverDefault = parcelHelpers.interopDefault(_physicsBodySphereResolver);
var _sphereBoxSolver = require("./Solvers/SphereBoxSolver");
var _sphereBoxSolverDefault = parcelHelpers.interopDefault(_sphereBoxSolver);
var _sphereSphereSolver = require("./Solvers/SphereSphereSolver");
var _sphereSphereSolverDefault = parcelHelpers.interopDefault(_sphereSphereSolver);
function NarrowPhase(broadPhaseResult, gameTime) {
    let collisionsOccurred = false;
    for(let i = 0; i < broadPhaseResult.pairs.length; i++){
        let pair = broadPhaseResult.pairs[i]; // Check for collision between each collider in BodyA with each collider in BodyB.
        for(let j = 0; j < pair.bodyA.colliders.length; j++)for(let k = 0; k < pair.bodyB.colliders.length; k++){
            let colliderA = pair.bodyA.colliders[j];
            let colliderB = pair.bodyB.colliders[k];
            if (colliderA instanceof _sphereColliderDefault.default && colliderB instanceof _sphereColliderDefault.default) {
                let collisionResult = _sphereSphereSolverDefault.default(pair.bodyA, colliderA, pair.bodyB, colliderB);
                if (collisionResult.intersects) {
                    collisionsOccurred = true;
                    _physicsBodySphereResolverDefault.default(pair.bodyA, collisionResult.poi, collisionResult.collisionPair.normalB, colliderA, gameTime);
                    _physicsBodySphereResolverDefault.default(pair.bodyB, collisionResult.poi, collisionResult.collisionPair.normalA, colliderB, gameTime);
                } //
            } else if (colliderA instanceof _sphereColliderDefault.default && colliderB instanceof _boxColliderDefault.default) {
                let collisionResult = _sphereBoxSolverDefault.default(pair.bodyA, colliderA, pair.bodyB, colliderB);
                if (collisionResult.intersects) {
                    collisionsOccurred = true;
                    _physicsBodySphereResolverDefault.default(pair.bodyA, collisionResult.poi, collisionResult.collisionPair.normalB.clone(), colliderA, gameTime);
                    _physicsBodyBoxResolverDefault.default(pair.bodyB, collisionResult.poi, collisionResult.collisionPair.normalA, colliderB, gameTime);
                } //
            }
        }
    }
    return collisionsOccurred;
}
exports.default = NarrowPhase;

},{"./Colliders/BoxCollider":"arHpr","./Colliders/SphereCollider":"5DXdZ","./Resolvers/PhysicsBodyBoxResolver":"kyXQF","./Resolvers/PhysicsBodySphereResolver":"isuNW","./Solvers/SphereBoxSolver":"ayr3S","./Solvers/SphereSphereSolver":"738lZ","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"kyXQF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _velocity = require("../Velocity");
var _velocityDefault = parcelHelpers.interopDefault(_velocity);
function PhysicsBodyBoxResolver(physicsBody, poi, collisionNormal, collider, gameTime) {
    if (physicsBody.isStatic) return;
    let reflect = physicsBody.velocity.direction.clone().reflect(collisionNormal);
    physicsBody.move(new _velocityDefault.default(reflect, physicsBody.velocity.speed * physicsBody.bounciness));
}
exports.default = PhysicsBodyBoxResolver;

},{"../Velocity":"fsoO0","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"isuNW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _velocity = require("../Velocity");
var _velocityDefault = parcelHelpers.interopDefault(_velocity);
function PhysicsBodySphereResolver(physicsBody, poi, collisionNormal, collider, gameTime) {
    if (physicsBody.isStatic) return;
    let reflect = physicsBody.velocity.direction.clone().reflect(collisionNormal);
    let v = new _velocityDefault.default(reflect, physicsBody.velocity.speed * physicsBody.bounciness);
    let worldCollider = collider.clone().applyMatrix(physicsBody.matrixWorld);
    physicsBody.setPosition(poi.clone().add(collisionNormal.multiplyScalar(worldCollider.radius).add(v.resolve(gameTime.deltaTime))));
    physicsBody.move(new _velocityDefault.default(reflect, physicsBody.velocity.speed * physicsBody.bounciness));
}
exports.default = PhysicsBodySphereResolver;

},{"../Velocity":"fsoO0","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"ayr3S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
function SphereBoxSolver(bodyA, colliderA, bodyB, colliderB) {
    // Transform colliderA into local space of colliderB so we can perform a more simple sphere-AABB test
    let localAToLocalB = new _three.Matrix4().getInverse(bodyB.matrixWorld).multiply(bodyA.matrixWorld);
    let colliderAInLocalBSpace = colliderA.clone().applyMatrix(localAToLocalB);
    let result = {
        intersects: false,
        collisionPair: {
            colliderA: colliderA,
            colliderB: colliderB
        }
    }; // now determine point of intersection and face normal
    let poi = new _three.Vector3();
    let collidersIntersect = DistancePointToAABB(colliderAInLocalBSpace.position, colliderB) <= colliderAInLocalBSpace.radius;
    if (collidersIntersect) {
        ClosestPointToAABB(colliderAInLocalBSpace.position, colliderB, poi);
        result.intersects = true; // Transform point of intersection back from B's local space to world space
        result.poi = poi.applyMatrix4(bodyB.matrixWorld);
        result.collisionPair.normalA = new _three.Vector3().subVectors(poi, colliderA.clone().applyMatrix(bodyA.matrixWorld).position).normalize();
        result.collisionPair.normalB = result.collisionPair.normalA.clone().negate();
    }
    return result;
}
exports.default = SphereBoxSolver;
function ClosestPointToAABB(point, box, result) {
    result.copy(point).clamp(box.minExtent, box.maxExtent);
}
function DistancePointToAABB(point, box) {
    let closestPt = new _three.Vector3();
    ClosestPointToAABB(point, box, closestPt);
    return closestPt.sub(point).length();
}

},{"three":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"738lZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
function SphereSphereSolver(bodyA, colliderA, bodyB, colliderB) {
    let colliderWorldA = colliderA.clone().applyMatrix(bodyA.matrixWorld);
    let colliderWorldB = colliderB.clone().applyMatrix(bodyB.matrixWorld);
    let distanceSq = new _three.Vector3().subVectors(colliderWorldA.position, colliderWorldB.position).lengthSq();
    let combinedRadius = colliderWorldA.radius + colliderWorldB.radius;
    let collisionResult = {
        intersects: false,
        collisionPair: {
            colliderA: colliderA,
            colliderB: colliderB
        }
    };
    if (distanceSq <= combinedRadius * combinedRadius) {
        let closestPt = new _three.Vector3();
        ClosestPointToSphere(colliderWorldA.position, colliderWorldB.position, colliderWorldB.radius, closestPt);
        collisionResult.intersects = true;
        collisionResult.collisionPair.normalA = new _three.Vector3().subVectors(closestPt, colliderWorldA.position).normalize();
        collisionResult.collisionPair.normalB = new _three.Vector3().subVectors(closestPt, colliderWorldB.position).normalize();
        collisionResult.poi = closestPt;
    }
    return collisionResult;
}
exports.default = SphereSphereSolver;
function ClosestPointToSphere(point, spherePos, sphereRadius, result) {
    result.subVectors(point, spherePos).normalize().multiplyScalar(sphereRadius).add(spherePos);
}

},{"three":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"9REyN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _three = require("three");
var _defaultVectors = require("../DEFAULT_VECTORS");
var _defaultVectorsDefault = parcelHelpers.interopDefault(_defaultVectors);
var _physicsBody = require("./PhysicsBody");
var _physicsBodyDefault = parcelHelpers.interopDefault(_physicsBody);
class TerrainPhysicsBody extends _physicsBodyDefault.default {
    // #region Properties (6)
    // #endregion Properties (6)
    // #region Constructors (1)
    constructor(args){
        super();
        this.quadrants = [];
        this.mapSize = args.mapSize;
        this.viewSize = args.viewSize;
        this.subdivisions = args.subdivisions;
        this.quadrantSize = args.quadrantSize;
        this.quadrantLoadZoneSize = args.quadrantSize;
    }
    // #region Public Methods (3)
    heightAt(x, z) {
        let r = this.quadrantAndFaceIndexFromPos(x, z);
        let quadrant = this.quadrants[r.quadrant.index];
        if (!quadrant) return false;
        let face = quadrant.collisionGeom.faces[r.faceIndex];
        if (!face) return; // Then use the associated vertices to calc the intersection
        let t = new _three.Triangle(quadrant.collisionGeom.vertices[face.a], quadrant.collisionGeom.vertices[face.b], quadrant.collisionGeom.vertices[face.c]); // let p = {}; // , tNormal = new Vector3();
        // t.getNormal( tNormal );
        // t.intersectRay(new Vector3(x, -z, 0), new Vector3(0, 0, 1), p);
        let p = new _three.Vector3();
        let ray = new _three.Ray(new _three.Vector3(x, -z, 0), _defaultVectorsDefault.default.back);
        if (ray.intersectTriangle(t.a, t.b, t.c, false, p) === null) return false;
        else return {
            h: p.z,
            normal: new _three.Vector3(face.normal.x, face.normal.z, -face.normal.y)
        };
    }
    quadrantAndFaceIndexFromPos(x, z) {
        let q = quadrantsFromXZ(x, z, this)[0];
        let halfSize = this.quadrantSize / 2;
        let quadSubdiv = this.quadrantSize / this.viewSize * this.subdivisions;
        let localPos = new _three.Vector3(x - q.centre.x, 0, z - q.centre.z);
        localPos.add(new _three.Vector3(halfSize, 0, halfSize));
        let t = localPos.divideScalar(this.quadrantSize);
        t.multiplyScalar(quadSubdiv); // Determine a 'grid' position from the local position
        let g = new _three.Vector2(Math.floor(t.x), Math.floor(t.z)); // And determine which half of the grid square the co-ords are in
        let faceOffset = 1 - frac(t.z) <= frac(t.x) ? 1 : 0; // Use this to calculate the face array index.
        let idx = (g.x + g.y * quadSubdiv) * 2 + faceOffset;
        return {
            gridCoords: g,
            faceIndex: idx,
            quadrant: q
        };
    }
    async readAsync(pos) {
        console.log("read terrain collision geometry");
        let quadrants = quadrantsFromXZ(pos.x, pos.z, this);
        return Promise.allSettled(quadrants.map((quad)=>{
            if (this.quadrants[quad.index] === undefined) return _axiosDefault.default.get(`/api/map/collisiongeometry/${quad.centre.x}/${quad.centre.z}`).then((response)=>{
                this.quadrants[quad.index] = {
                    index: quad.index,
                    centre: quad.centre,
                    collisionGeom: response.data
                };
            });
        })).then((results)=>{
            // Unload any quadrants we're no longer using.
            this.quadrants.forEach((quad, idx)=>{
                if (quadrants.filter((x)=>x.index === idx
                ).length === 0) delete this.quadrants[idx];
            });
            console.log("finished loading terrain collision geometry");
            return Promise.resolve(quadrants);
        });
    }
}
exports.default = TerrainPhysicsBody;
function quadrantCentreFromIndex(idx, terrain) {
    let halfSize = terrain.mapSize / 2;
    let quadrantsPerRow = terrain.mapSize / terrain.quadrantSize;
    let qr = Math.floor(idx / quadrantsPerRow);
    let qp = idx * terrain.quadrantSize - terrain.mapSize * qr + terrain.quadrantSize / 2;
    return {
        x: qp - halfSize,
        z: qr * terrain.quadrantSize + terrain.quadrantSize / 2 - halfSize
    };
}
function quadrantFromXZ(x, z, terrain) {
    let halfSize = terrain.mapSize / 2;
    let quadrantsPerRow = terrain.mapSize / terrain.quadrantSize;
    let adjX = x + halfSize;
    let adjZ = z + halfSize;
    let q = quadrantsPerRow * Math.floor(adjZ / terrain.quadrantSize) + Math.floor(adjX / terrain.quadrantSize);
    return {
        index: q,
        centre: quadrantCentreFromIndex(q, terrain)
    };
}
function quadrantsFromXZ(x, z, terrain) {
    let mainQuad = quadrantFromXZ(x, z, terrain);
    let result = [
        mainQuad
    ]; // Determine other quadrants near to given position (used for preloading)
    let diff = {
        x: x - mainQuad.centre.x,
        z: z - mainQuad.centre.z
    };
    let threshold = (terrain.quadrantSize - terrain.quadrantLoadZoneSize) / 2;
    let xAdjQuad, zAdjQuad;
    if (Math.abs(diff.x) > threshold) {
        xAdjQuad = Math.sign(diff.x) >= 0 ? quadrantFromXZ(x + terrain.quadrantLoadZoneSize, z, terrain) : quadrantFromXZ(x - terrain.quadrantLoadZoneSize, z, terrain);
        result.push(xAdjQuad);
    }
    if (Math.abs(diff.z) > threshold) {
        zAdjQuad = Math.sign(diff.z) >= 0 ? quadrantFromXZ(x, z + terrain.quadrantLoadZoneSize, terrain) : quadrantFromXZ(x, z - terrain.quadrantLoadZoneSize, terrain);
        result.push(zAdjQuad);
    }
    if (xAdjQuad && zAdjQuad) {
        let idx = xAdjQuad.index + zAdjQuad.index - mainQuad.index;
        let xzAdjQuad = {
            index: idx,
            centre: quadrantCentreFromIndex(idx, terrain)
        };
        result.push(xzAdjQuad);
    }
    return result;
}
function frac(n) {
    return n - Math.floor(n);
}

},{"axios":"jo6P5","three":"ktPTu","../DEFAULT_VECTORS":"4oEJD","./PhysicsBody":"6tk2H","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"7ZISl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class PlayerController {
    // #region Properties (5)
    // #endregion Properties (5)
    // #region Constructors (1)
    constructor(args){
        let _this = this;
        this.useMouseLook = args.useMouseLook || false;
        this.enabled = args.enabled === true ? true : false;
        this.keyMap = args.keyMap || {
            turnright: "39",
            turnleft: "37",
            forward: "87",
            backward: "83",
            up: "38",
            down: "40",
            strafeleft: "65",
            straferight: "68"
        };
        this.actions = args.actions || {
            turnright: function() {},
            turnleft: function() {},
            forward: function() {},
            backward: function() {},
            up: function() {},
            down: function() {},
            strafeleft: function() {},
            straferight: function() {},
            mousemove: function() {}
        };
        this.keyStates = {};
        for(let k1 in this.keyMap)this.keyStates[k1] = {
            active: false,
            changed: false
        };
        var onKeyDown = function(ev) {
            if (!_this.enabled) return; // Convert keyCode to movement identifier
            for(let k in _this.keyMap)if (ev.keyCode == _this.keyMap[k]) {
                let lastState = _this.keyStates[k].active;
                _this.keyStates[k] = {
                    active: true,
                    changed: lastState == true ? false : true
                };
            }
            ev.preventDefault();
        };
        var onKeyUp = function(ev) {
            if (!_this.enabled) return;
            for(let k in _this.keyMap)if (ev.keyCode == _this.keyMap[k]) {
                let lastState = _this.keyStates[k].active;
                _this.keyStates[k] = {
                    active: false,
                    changed: lastState == true ? true : false
                };
            }
        };
        var onMouseMove = function(ev) {
            if (!_this.enabled) return;
            if (typeof _this.actions.mousemove == "function" && _this.useMouseLook) _this.actions.mousemove(_this, ev);
        }; // Register events
        window.addEventListener("keydown", onKeyDown);
        window.addEventListener("keyup", onKeyUp);
        window.addEventListener("mousemove", onMouseMove);
    }
    // #region Public Methods (1)
    update() {
        if (this === undefined || !this.enabled) return;
        for(let k in this.keyStates){
            if (typeof this.actions[k] !== "function") continue;
            if (this.keyStates[k].active) this.actions[k](this, false);
            else if (!this.keyStates[k].active && this.keyStates[k].changed) this.actions[k](this, true);
            this.keyStates[k].changed = false;
        }
    }
}
exports.default = PlayerController;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"kLQbG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PLAYER_STATES", ()=>PLAYER_STATES
);
var _three = require("three");
var _defaultSpeeds = require("./DEFAULT_SPEEDS");
var _defaultSpeedsDefault = parcelHelpers.interopDefault(_defaultSpeeds);
var _velocity = require("./Physics/Velocity");
var _velocityDefault = parcelHelpers.interopDefault(_velocity);
class PlayerState {
    // #region Properties (6)
    // #endregion Properties (6)
    // #region Constructors (1)
    constructor(args){
        if (args) {
            this.name = args.name;
            this.maxSpeed = args.maxSpeed;
            this.minPitch = args.minPitch;
            this.maxPitch = args.maxPitch;
            this.targetSpeed = args.targetSpeed.bind(this);
            this.resolveMove = args.resolveMove;
        }
    }
}
exports.default = PlayerState;
const _doNothing = function() {};
const _resolveMove = function(physicsBody, direction, targetSpeed) {
    // Pass the speed as a function, to be resolved when the PhysicsManager resolves all movements during its update.
    physicsBody.move(new _velocityDefault.default(direction, targetSpeed));
};
const PLAYER_STATES = {
    WALKING: new PlayerState({
        name: "WALKING",
        maxSpeed: _defaultSpeedsDefault.default.WALKING,
        minPitch: -1.2,
        maxPitch: 1.2,
        targetSpeed: function(grad) {
            return _three.MathUtils.clamp(this.maxSpeed * grad + this.maxSpeed, 0, this.maxSpeed * 2);
        },
        resolveMove: _resolveMove
    }),
    RUNNING: new PlayerState({
        name: "RUNNING",
        maxSpeed: _defaultSpeedsDefault.default.RUNNING,
        minPitch: -1.2,
        maxPitch: 1.2,
        targetSpeed: function(grad) {
            return _three.MathUtils.clamp(this.maxSpeed * grad + this.maxSpeed, 0, this.maxSpeed * 2);
        },
        resolveMove: _resolveMove
    }),
    SKIING: new PlayerState({
        name: "SKIING",
        maxSpeed: _defaultSpeedsDefault.default.SKIING,
        minPitch: -1.2,
        maxPitch: 1.2,
        targetSpeed: function(grad) {
            return _three.MathUtils.clamp(this.maxSpeed * grad + this.maxSpeed, 0, this.maxSpeed * 2);
        },
        resolveMove: _resolveMove
    }),
    DRIVING: new PlayerState({
        name: "DRIVING",
        maxSpeed: _defaultSpeedsDefault.default.DRIVING,
        minPitch: -1.2,
        maxPitch: 1.2,
        targetSpeed: function(grad) {
            return _three.MathUtils.clamp(this.maxSpeed * grad + this.maxSpeed, 0, this.maxSpeed * 2);
        },
        resolveMove: _resolveMove
    }),
    FALLING: new PlayerState({
        name: "FALLING",
        maxSpeed: _defaultSpeedsDefault.default.FALLING,
        minPitch: -1.2,
        maxPitch: 1.2,
        targetSpeed: function() {
            return this.maxSpeed;
        },
        resolveMove: _doNothing
    }),
    DROWNING: new PlayerState({
        name: "DROWNING",
        maxSpeed: _defaultSpeedsDefault.default.DROWNING,
        minPitch: -1.2,
        maxPitch: 1.2,
        targetSpeed: function() {
            return this.maxSpeed;
        },
        resolveMove: _resolveMove
    }),
    SLEEPING: new PlayerState({
        name: "SLEEPING",
        maxSpeed: _defaultSpeedsDefault.default.SLEEPING,
        minPitch: 0,
        maxPitch: 0,
        targetSpeed: ()=>0
        ,
        resolveMove: _doNothing
    }),
    FREEROAM: new PlayerState({
        name: "FREEROAM",
        maxSpeed: _defaultSpeedsDefault.default.FREEROAM,
        minPitch: -1.2,
        maxPitch: 1.2,
        targetSpeed: function(grad) {
            return _three.MathUtils.clamp(-this.maxSpeed * grad + this.maxSpeed, 0, this.maxSpeed * 2);
        },
        resolveMove: function(physicsBody, direction, targetSpeed) {
            physicsBody.move(new _velocityDefault.default(direction, targetSpeed));
        }
    })
};

},{"three":"ktPTu","./DEFAULT_SPEEDS":"2I8I7","./Physics/Velocity":"fsoO0","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"2I8I7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const DEFAULT_SPEEDS = {
    get DROWNING () {
        return 2;
    },
    get WALKING () {
        return 6;
    },
    get RUNNING () {
        return 10;
    },
    get SKIING () {
        return 20;
    },
    get DRIVING () {
        return 70;
    },
    get FALLING () {
        return 100;
    },
    get FREEROAM () {
        return 100;
    },
    get SLEEPING () {
        return 0;
    }
};
exports.default = DEFAULT_SPEEDS;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"1aeCQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @author mrdoob / http://mrdoob.com/
 */ var Stats = function() {
    var startTime = Date.now(), prevTime = startTime;
    var ms = 0, msMin = Infinity, msMax = 0;
    var fps = 0, fpsMin = Infinity, fpsMax = 0;
    var frames = 0, mode = 0;
    var container = document.createElement("div");
    container.id = "stats";
    container.addEventListener("mousedown", function(event) {
        event.preventDefault();
        setMode(++mode % 2);
    }, false);
    container.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
    var fpsDiv = document.createElement("div");
    fpsDiv.id = "fps";
    fpsDiv.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#002";
    container.appendChild(fpsDiv);
    var fpsText = document.createElement("div");
    fpsText.id = "fpsText";
    fpsText.style.cssText = "color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
    fpsText.innerHTML = "FPS";
    fpsDiv.appendChild(fpsText);
    var fpsGraph = document.createElement("div");
    fpsGraph.id = "fpsGraph";
    fpsGraph.style.cssText = "position:relative;width:74px;height:30px;background-color:#0ff";
    fpsDiv.appendChild(fpsGraph);
    while(fpsGraph.children.length < 74){
        var bar = document.createElement("span");
        bar.style.cssText = "width:1px;height:30px;float:left;background-color:#113";
        fpsGraph.appendChild(bar);
    }
    var msDiv = document.createElement("div");
    msDiv.id = "ms";
    msDiv.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#020;display:none";
    container.appendChild(msDiv);
    var msText = document.createElement("div");
    msText.id = "msText";
    msText.style.cssText = "color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
    msText.innerHTML = "MS";
    msDiv.appendChild(msText);
    var msGraph = document.createElement("div");
    msGraph.id = "msGraph";
    msGraph.style.cssText = "position:relative;width:74px;height:30px;background-color:#0f0";
    msDiv.appendChild(msGraph);
    while(msGraph.children.length < 74){
        var bar = document.createElement("span");
        bar.style.cssText = "width:1px;height:30px;float:left;background-color:#131";
        msGraph.appendChild(bar);
    }
    var setMode = function(value) {
        mode = value;
        switch(mode){
            case 0:
                fpsDiv.style.display = "block";
                msDiv.style.display = "none";
                break;
            case 1:
                fpsDiv.style.display = "none";
                msDiv.style.display = "block";
                break;
        }
    };
    var updateGraph = function(dom, value) {
        var child = dom.appendChild(dom.firstChild);
        child.style.height = value + "px";
    };
    return {
        REVISION: 12,
        domElement: container,
        setMode: setMode,
        begin: function() {
            startTime = Date.now();
        },
        end: function() {
            var time = Date.now();
            ms = time - startTime;
            msMin = Math.min(msMin, ms);
            msMax = Math.max(msMax, ms);
            msText.textContent = ms + " MS (" + msMin + "-" + msMax + ")";
            updateGraph(msGraph, Math.min(30, 30 - ms / 200 * 30));
            frames++;
            if (time > prevTime + 1000) {
                fps = Math.round(frames * 1000 / (time - prevTime));
                fpsMin = Math.min(fpsMin, fps);
                fpsMax = Math.max(fpsMax, fps);
                fpsText.textContent = fps + " FPS (" + fpsMin + "-" + fpsMax + ")";
                updateGraph(fpsGraph, Math.min(30, 30 - fps / 100 * 30));
                prevTime = time;
                frames = 0;
            }
            return time;
        },
        update: function() {
            startTime = this.end();
        }
    };
};
exports.default = Stats;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"hWq8A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
var _terrainMaterial = require("./TerrainMaterial");
var _terrainMaterialDefault = parcelHelpers.interopDefault(_terrainMaterial);
class Terrain {
    // #region Properties (14)
    //MeshStandardMaterial;
    // #endregion Properties (14)
    // #region Constructors (1)
    constructor(renderer, scene, args){
        this.terrainMesh;
        this.oceanMesh;
        this.renderer = renderer;
        this.parentScene = scene;
        this.cameraPos = new _three.Vector3();
        this.mapSize = args.mapSize || 4096;
        this.viewSize = args.viewDistance;
        this.subdivisions = this.viewSize / args.subdivisionSize;
        this.maxHeight = args.maxHeight || 100;
        this.ocean = args.ocean || {
            height: args.ocean ? args.ocean.height ? args.ocean.height : 0 : 0,
            color: args.ocean ? args.ocean.color ? args.ocean.color : "#11378A" : "#11378A"
        };
    }
    // #region Public Methods (5)
    addToScene(scene) {
        scene.add(this.terrainMesh);
        if (this.oceanMesh) scene.add(this.oceanMesh);
    }
    async loadAsync(heightMapPath) {
        console.log("loading terrain");
        return new Promise((resolve, reject)=>{
            let terrainVertexShader, oceanVertexShader, heightMap, terrainGeom, _this = this;
            let loadingManager = new _three.LoadingManager(function() {
                heightMap.minFilter = _three.NearestFilter;
                heightMap.magFilter = _three.NearestFilter;
                let terrainMaterial = new _terrainMaterialDefault.default({
                    color: new _three.Color(13759743),
                    heightMap: heightMap,
                    heightScale: _this.maxHeight,
                    mapSize: _this.mapSize,
                    playerPos: _this.cameraPos,
                    subdivisions: _this.subdivisions,
                    textureSize: heightMap.image.width,
                    viewSize: _this.viewSize
                });
                terrainGeom = new _three.PlaneBufferGeometry(_this.viewSize, _this.viewSize, _this.subdivisions, _this.subdivisions);
                terrainGeom.computeBoundingBox();
                terrainGeom.computeBoundingSphere();
                terrainGeom.boundingSphere.radius = Math.max(_this.viewSize, _this.maxHeight);
                _this.terrainMesh = new _three.Mesh(terrainGeom, terrainMaterial);
                _this.terrainMesh.position.y = 0;
                _this.terrainMesh.rotation.x = -Math.PI / 2;
                _this.terrainMesh.receiveShadow = true;
                _this.terrainMesh.castShadow = true;
                _this.terrainMesh.visible = true;
                if (_this.ocean) {
                    _this.oceanGeom = new _three.PlaneBufferGeometry(_this.viewSize, _this.viewSize, _this.subdivisions, _this.subdivisions);
                    _this.oceanMaterial = new _three.MeshStandardMaterial({
                        color: _this.ocean.color,
                        flatShading: true,
                        roughness: 0.6,
                        metalness: 0.4,
                        side: _three.FrontSide
                    });
                    _this.oceanUniforms = {
                        heightMap: {
                            value: heightMap
                        },
                        heightScale: {
                            value: 2
                        },
                        nSeaLevel: {
                            value: _this.ocean.height / _this.maxHeight
                        },
                        playerPos: {
                            value: _this.cameraPos
                        },
                        mapSize: {
                            value: _this.mapSize
                        },
                        viewSize: {
                            value: _this.viewSize
                        },
                        subdivisions: {
                            value: _this.subdivisions
                        },
                        time: {
                            value: 0
                        },
                        waveFreq: {
                            value: 1300
                        },
                        waveOrigin: {
                            type: "v2v",
                            value: [
                                new _three.Vector2(0.5, 0.5),
                                new _three.Vector2(0.3, 0.25),
                                new _three.Vector2(0.9, 0.75)
                            ]
                        }
                    };
                    _this.oceanMaterial.onBeforeCompile = function(shader) {
                        for(let p in _this.oceanUniforms)shader.uniforms[p] = _this.oceanUniforms[p];
                        shader.vertexShader = oceanVertexShader;
                    };
                    _this.oceanMesh = new _three.Mesh(_this.oceanGeom, _this.oceanMaterial);
                    _this.oceanMesh.position.set(0, 0, 0);
                    _this.oceanMesh.rotation.x = -Math.PI / 2;
                    _this.oceanMesh.visible = true;
                    _this.oceanMesh.castShadow = false;
                    _this.oceanMesh.receiveShadow = false;
                }
                _this.addToScene(_this.parentScene);
                console.log("terrain loaded");
                resolve(_this);
            });
            let textureLoader = new _three.TextureLoader(loadingManager);
            heightMap = textureLoader.load(heightMapPath);
            let fileLoader = new _three.FileLoader(loadingManager);
            fileLoader.load("/shaders/OceanVertexShader.glsl", function(data) {
                oceanVertexShader = data;
            });
        });
    }
    oceanHeightAt(x, z) {
        let displace = 0;
        let waveFreq = this.oceanUniforms.waveFreq.value;
        let time = this.oceanUniforms.time.value; // let tDepth = ( this.ocean.height - this.heightAt( x, z ).h ) / this.maxHeight || 1;
        let tDepth = 1; // Convert player position to the equivalent UV coord.
        let uv = new _three.Vector2(x, z);
        uv.addScalar(this.mapSize / 2);
        uv.divideScalar(this.mapSize);
        for(let i = 0; i < 3; i++){
            let waveOriginDist = this.oceanUniforms.waveOrigin.value[i].distanceTo(uv);
            displace += Math.cos(waveFreq * (1 / (i + 1)) * waveOriginDist + time * 2) * tDepth;
            displace += Math.cos(waveFreq * tDepth * 2.5 * waveOriginDist - time * 1.5) * 0.75;
        }
        return this.ocean.height + displace * tDepth * this.oceanUniforms.heightScale.value;
    }
    removeFromScene(scene) {
        scene.remove(this.terrainMesh);
        if (this.oceanMesh) scene.remove(this.oceanMesh);
    }
    update(camera, gameTime) {
        this.oceanUniforms.time.value = gameTime.elapsedTime * 0.8;
        if (this.terrainMesh) {
            this.cameraPos.set(camera.position.x, camera.position.y, camera.position.z);
            this.terrainMesh.position.set(camera.position.x, 0, camera.position.z);
        }
        if (this.oceanMesh) this.oceanMesh.position.set(camera.position.x, this.ocean.height, camera.position.z);
    }
}
exports.default = Terrain;

},{"three":"ktPTu","./TerrainMaterial":"i1LOC","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"i1LOC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
var _terrainFragmentShaderGlsl = require("../../Assets/shaders/TerrainFragmentShader.glsl");
var _terrainFragmentShaderGlslDefault = parcelHelpers.interopDefault(_terrainFragmentShaderGlsl);
var _terrainVertexShaderGlsl = require("../../Assets/shaders/TerrainVertexShader.glsl");
var _terrainVertexShaderGlslDefault = parcelHelpers.interopDefault(_terrainVertexShaderGlsl);
class TerrainMaterial extends _three.MeshStandardMaterial {
    constructor(props){
        let baseShaderParams = {
            color: props.color,
            flatShading: true,
            roughness: 0.9,
            metalness: 0,
            emissive: new _three.Color(11184844),
            emissiveIntensity: 0.1,
            side: _three.FrontSide
        };
        super(baseShaderParams); // this.setValues(baseShaderParams);
        this.onBeforeCompile = (shader)=>{
            shader.vertexShader = _terrainVertexShaderGlslDefault.default;
            shader.fragmentShader = _terrainFragmentShaderGlslDefault.default;
            shader.uniforms.heightMap = {
                value: props.heightMap
            };
            shader.uniforms.heightScale = {
                value: props.heightScale
            };
            shader.uniforms.playerPos = {
                value: props.playerPos
            };
            shader.uniforms.mapSize = {
                value: props.mapSize
            };
            shader.uniforms.viewSize = {
                value: props.viewSize
            };
            shader.uniforms.subdivisions = {
                value: props.subdivisions
            };
            shader.uniforms.textureSize = {
                value: props.textureSize
            };
        };
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
    }
}
exports.default = TerrainMaterial;

},{"three":"ktPTu","../../Assets/shaders/TerrainFragmentShader.glsl":"3yEQ2","../../Assets/shaders/TerrainVertexShader.glsl":"8Qj7u","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"3yEQ2":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\n#define STANDARD\n\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n// #include <shadowmap_pars_fragment>\n\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): create uniforms for area light shadows\n\n\t#endif\n\t*/\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n\t}\n\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n\t\tfloat occlusion = 1.0;\n\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\n\t\tfloat hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n\t\tif (hard_shadow != 1.0 ) {\n\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n\t\t}\n\t\treturn occlusion;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tfloat shadow = 1.0;\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\n\t\t\tshadow = clamp( shadow + 0.25, 0., 1.);\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t\tshadow = clamp( shadow + 0.8, 0., 1.);\n\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn shadow;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the vector from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n\t\tdp += shadowBias;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t// vec3 outgoingLight = reflectedLight.directDiffuse;\n\n\t// this is a stub for the transparency model\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}";

},{}],"8Qj7u":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\n#define PHYSICAL\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nuniform sampler2D heightMap;\n// uniform sampler2D normalMap;\nuniform vec3 playerPos;\nuniform float mapSize;\nuniform float viewSize;\nuniform float subdivisions;\nuniform float textureSize;\nuniform float heightScale;\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\tfloat step = viewSize / subdivisions;\n\tvec2 pp = vec2(playerPos.x, -playerPos.z);\n\tvec2 adjPlayerPos = floor(pp / step) * step;\n\tvec2 remainderPP = pp - adjPlayerPos;\n\n\tfloat uvScale = viewSize / mapSize;\n\tvec2 uvOffset = vec2(adjPlayerPos + (mapSize / 2.) - (viewSize / 2.)) / mapSize;\n\tvec2 newUV = uvOffset + uv * uvScale;\n\n\tvec4 dm = texture2D(heightMap, newUV);\n\tvec3 newPos = vec3( position.x - remainderPP.x, position.y - remainderPP.y, dm.r * heightScale );\n\tvec3 transformed = newPos;\n\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n";

},{}],"5ddeH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
var _defaultVectors = require("./DEFAULT_VECTORS");
var _defaultVectorsDefault = parcelHelpers.interopDefault(_defaultVectors);
var _path01 = require("./path01");
var _path01Default = parcelHelpers.interopDefault(_path01);
var _sphereCollider = require("./Physics/Colliders/SphereCollider");
var _sphereColliderDefault = parcelHelpers.interopDefault(_sphereCollider);
var _physicsBody = require("./Physics/PhysicsBody");
var _physicsBodyDefault = parcelHelpers.interopDefault(_physicsBody);
var _playerState = require("./PlayerState");
var _stateful = require("./Stateful");
var _statefulDefault = parcelHelpers.interopDefault(_stateful);
var _wayPointPath = require("./WayPointPath");
var _wayPointPathDefault = parcelHelpers.interopDefault(_wayPointPath);
class DollyCamera extends _three.PerspectiveCamera {
    // #region Properties (17)
    // #endregion Properties (17)
    // #region Constructors (1)
    constructor(canvasElement){
        console.log("Creating Player");
        super(65, window.innerWidth / window.innerHeight, 0.01, 6000);
        this.canvas = canvasElement;
        this.coverText = document.getElementById("cover");
        this._wayPointPath = new _wayPointPathDefault.default(_path01Default.default);
        this._wayPointPath.normalize(40);
        this._t = 0.04;
        this._yaw = Math.PI * 0.85;
        this._pitch = this._wayPointPath.at(0).direction.y;
        this._roll = 0;
        this._qPitch = new _three.Quaternion();
        this._qYaw = new _three.Quaternion();
        this._qRoll = new _three.Quaternion();
        this._gradient = 0;
        this.physicsBody = new _physicsBodyDefault.default();
        this.physicsBody.acceleration = 6;
        this.physicsBody.followTerrain = false;
        this.physicsBody.addCollider(new _sphereColliderDefault.default(3));
        this.physicsBody.userData = {
            entity: this
        };
        this.physicsBody.onPreUpdate = this.update.bind(this);
        this.playerState = _statefulDefault.default.from(_playerState.PLAYER_STATES.WALKING);
        this.name = "Player";
        this.targetSpeed = 0;
        this.positionOffset = new _three.Vector3(); // Configure valid player state transitions
        _statefulDefault.default.when(this.playerState).changes.from(_playerState.PLAYER_STATES.WALKING).to(_playerState.PLAYER_STATES.RUNNING).then(()=>{});
        _statefulDefault.default.when(this.playerState).changes.from(_playerState.PLAYER_STATES.RUNNING).to(_playerState.PLAYER_STATES.WALKING).then(()=>{});
        _statefulDefault.default.when(this.playerState).changes.from(_playerState.PLAYER_STATES.WALKING).to(_playerState.PLAYER_STATES.SKIING).then(()=>{});
        _statefulDefault.default.when(this.playerState).changes.from(_playerState.PLAYER_STATES.SKIING).to(_playerState.PLAYER_STATES.WALKING).then(()=>{});
        _statefulDefault.default.when(this.playerState).changes.from(_playerState.PLAYER_STATES.WALKING, _playerState.PLAYER_STATES.RUNNING, _playerState.PLAYER_STATES.SKIING).to(_playerState.PLAYER_STATES.FALLING).then(()=>{});
        _statefulDefault.default.when(this.playerState).changes.from(_playerState.PLAYER_STATES.FALLING).to(_playerState.PLAYER_STATES.WALKING, _playerState.PLAYER_STATES.RUNNING, _playerState.PLAYER_STATES.SKIING).then(()=>{});
    }
    // #region Public Accessors (4)
    get backward() {
        return this.forward.negate();
    }
    get forward() {
        return _defaultVectorsDefault.default.forward.applyAxisAngle(_defaultVectorsDefault.default.up, this._yaw).normalize();
    }
    get left() {
        return this.right.negate();
    }
    get right() {
        return new _three.Vector3().crossVectors(this.forward, _defaultVectorsDefault.default.up).normalize();
    }
    // #region Public Methods (6)
    addPitch(radians) {
        this._pitch = _three.MathUtils.clamp(this._pitch + radians, this.playerState.minPitch, this.playerState.maxPitch);
    }
    addYaw(radians) {
        this._yaw += radians;
        this._yaw = this._yaw % (Math.PI * 2);
    }
    move() {
        let _this = this;
        return {
            forward: function() {
                _this.targetSpeed = _this.playerState.targetSpeed(_this._gradient);
                _this.playerState.resolveMove(_this.physicsBody, _this.forward, _this.targetSpeed);
            },
            backward: function() {
                _this.targetSpeed = _this.playerState.targetSpeed(_this._gradient);
                _this.playerState.resolveMove(_this.physicsBody, _this.backward, _this.targetSpeed);
            },
            left: function() {
                _this.targetSpeed = _this.playerState.targetSpeed(_this._gradient);
                _this.playerState.resolveMove(_this.physicsBody, _this.left, _this.targetSpeed);
            },
            right: function() {
                _this.targetSpeed = _this.playerState.targetSpeed(_this._gradient);
                _this.playerState.resolveMove(_this.physicsBody, _this.right, _this.targetSpeed);
            }
        };
    }
    revertPlayerState() {
        this.playerState.set(this._prevPlayerState);
    }
    setFromPitchYawRoll(gameTime) {
        this._qPitch.setFromAxisAngle(this.right, this._pitch);
        this._qYaw.setFromAxisAngle(_defaultVectorsDefault.default.up, this._yaw);
        this._qRoll.setFromAxisAngle(_defaultVectorsDefault.default.forward, this._roll);
        let qTarget = new _three.Quaternion().multiplyQuaternions(this._qPitch, this._qYaw).normalize();
        qTarget.multiply(this._qRoll);
        this.physicsBody.setOrientation(this.physicsBody.orientation.clone().slerp(qTarget, gameTime.deltaTime / 0.075));
    }
    update(gameTime, physicsBody) {
        this.setFromPitchYawRoll(gameTime);
        this._t += gameTime.deltaTime * 0.0038;
        let w = this._wayPointPath.at(this._t);
        if (w) {
            if (this._wayPointPath.next !== this._lastWayPoint) // debug().addDebugWayPoint(this._wayPointPath.next);
            this._lastWayPoint = this._wayPointPath.next;
            physicsBody.setPosition(w.position);
            this._pitch = w.direction.y;
            if (w.userData && w.userData.opacity !== undefined) {
                this.canvas.style.opacity = _three.MathUtils.clamp(w.userData.opacity, 0, 1).toFixed(3);
                this.coverText.style.opacity = (0.9 - _three.MathUtils.clamp(w.userData.opacity, 0, 1)).toFixed(3);
            }
        }
    }
}
exports.default = DollyCamera;

},{"three":"ktPTu","./DEFAULT_VECTORS":"4oEJD","./path01":"2IT3g","./Physics/Colliders/SphereCollider":"5DXdZ","./Physics/PhysicsBody":"6tk2H","./PlayerState":"kLQbG","./Stateful":"j3BxY","./WayPointPath":"5zt05","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"2IT3g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    {
        position: {
            x: 9815.958250487854,
            y: 265,
            z: -15383.947489281616
        },
        radius: 60,
        direction: {
            x: 0,
            y: -1,
            z: 0
        },
        userData: {
            opacity: 0
        }
    },
    {
        position: {
            x: 9459,
            y: 265,
            z: -14668
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.9,
            z: 0
        },
        userData: {
            opacity: 0
        }
    },
    {
        position: {
            x: 8741.205471517902,
            y: 300.5757125457283,
            z: -13231.632053845618
        },
        radius: 60,
        direction: {
            x: 0,
            y: 0.3,
            z: 0
        },
        userData: {
            opacity: 2
        }
    },
    {
        position: {
            x: 8166.964215569304,
            y: 762.1956286419831,
            z: -12079.882276731794
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.3,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 7792.31607262486,
            y: 871.1686274509804,
            z: -11328.454352209783
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 7512.763480626733,
            y: 865.3367167063174,
            z: -10767.758595522011
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 7267.275077775943,
            y: 851.8569834599729,
            z: -10275.38503242725
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 7018.352803636967,
            y: 867.1217721649482,
            z: -9776.124189030284
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 6754.943213122749,
            y: 693.69112374123,
            z: -9247.806284279211
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 6491.696743065243,
            y: 777.7278100242178,
            z: -8719.815548549366
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 5948.483315243447,
            y: 845.7303106505058,
            z: -7631.117284968416
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 5741.994580031465,
            y: 763.1753156222709,
            z: -7216.1456358930245
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.7,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 5406.871301109407,
            y: 689.6090483577349,
            z: -6543.992324361065
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.2,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 5104.116492165671,
            y: 822.9803921568628,
            z: -5936.760119936702
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 4856.408164161809,
            y: 800.9965588484539,
            z: -5439.934075809348
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 4601.357418134091,
            y: 776.4593146643849,
            z: -4928.381419417782
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 4354.008893133903,
            y: 628.0894784230629,
            z: -4432.277028471861
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 4085.290349589915,
            y: 595.4036771727275,
            z: -3893.3110112673294
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 3843.5489424788066,
            y: 708.1932865237518,
            z: -3408.4527589645395
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 3455.9970459634405,
            y: 752.5886006224575,
            z: -2631.143908707422
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 3292.9956537580197,
            y: 749.1363422335792,
            z: -2304.2136939291227
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 3037.707805586427,
            y: 717.3288515155552,
            z: -1792.185484207782
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 2694.4858208372516,
            y: 866.5768334650357,
            z: -1103.7886817481349
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 1
        }
    },
    {
        position: {
            x: 2432.1936251049437,
            y: 1016.9585950111084,
            z: -577.7119242111951
        },
        radius: 60,
        direction: {
            x: 0,
            y: -0.1,
            z: 0
        },
        userData: {
            opacity: 0
        }
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"j3BxY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Stateful {
    static from(src, transitions) {
        return new Proxy(new Stateful(src, transitions || []), {
            get (target, prop) {
                if ([
                    "set",
                    "_current",
                    "_transitions",
                    "isStateful",
                    "is",
                    "isAnyOf"
                ].some((x)=>x === prop
                )) return target[prop];
                return target._current[prop];
            }
        });
    }
    static when(state) {
        let _src = [], _target = [];
        let r = {
            from: (...src)=>{
                _src = src;
                return r;
            },
            to: (...target)=>{
                _target = target;
                return r;
            },
            then: (callback)=>{
                if (_src.length === 0) _src.push(null);
                if (_target.length === 0) _target.push(null);
                _src.forEach((src)=>{
                    _target.forEach((target)=>{
                        state._transitions.push({
                            from: src,
                            to: target,
                            then: callback
                        });
                    });
                });
            }
        };
        return {
            changes: r
        };
    }
    constructor(src, transitions){
        this._current = src;
        this._transitions = transitions;
    }
    set(newState) {
        let matchingTransitions = this._transitions.filter((x)=>(x.from == undefined || x.from === this._current) && (x.to == undefined || x.to === newState)
        );
        if (matchingTransitions.length > 0) {
            let prvState = this._current;
            this._current = newState;
            matchingTransitions.forEach((t)=>t.then(prvState, newState)
            );
            return true;
        }
        return false;
    }
    is(comparitor) {
        return this._current === comparitor;
    }
    isAnyOf(...comparitors) {
        return comparitors.some((x)=>x === this._current
        );
    }
}
exports.default = Stateful;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"5zt05":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
var _wayPoint = require("./WayPoint");
var _wayPointDefault = parcelHelpers.interopDefault(_wayPoint);
class WayPointPath {
    // #region Properties (4)
    static DEFAULT_STEP = 0.0001;
    // #region Constructors (1)
    constructor(waypoints){
        this._waypoints = waypoints ? waypoints.map((w)=>w instanceof _wayPointDefault.default ? w : new _wayPointDefault.default(new _three.Vector3(w.position.x, w.position.y, w.position.z), w.direction ? new _three.Vector3(w.direction.x, w.direction.y, w.direction.z) : new _three.Vector3(), w.radius, w.userData)
        ) : [];
        this._isNormalized = false;
        this._current = 0;
    }
    // #region Public Accessors (4)
    get current() {
        return this._waypoints[this._current];
    }
    get isNormalized() {
        return this._isNormalized;
    }
    get length() {
        return this._waypoints.length;
    }
    get next() {
        this._current++;
        if (this._current < this._waypoints.length) return this._waypoints[this._current];
        return null;
    }
    // #region Public Methods (4)
    /**
   * Returns an interpolated WayPoint at value 't' along the path (0 <= t <= 1)
   * @param t represents the position along the path to interpolate.  Must be a value between 0 and 1.
   */ at(t) {
        t = _three.MathUtils.clamp(t, 0, 1);
        if (this._isNormalized) return this._at(this.denormalizeT(t));
        return this._at(t);
    }
    /**
   * Normalize the path
   * @param nWayPoints Number of evenly distributed way-points to create
   * @description For a linear increase in 't' the distance along the path also increases linearly after normalization
   */ normalize(nWayPoints) {
        let lengths = [];
        let totalPathLength = this.pathLength();
        let pl = 0;
        for(let i = 0; i < this._waypoints.length - 1; i++){
            this._waypoints[i].t = i / (this._waypoints.length - 1);
            pl = this.pathLength(WayPointPath.DEFAULT_STEP, 0, i + 1);
            lengths.push(pl);
        }
        this._waypoints[this._waypoints.length - 1].t = 1;
        this._waypoints[0].tNormalized = 0; // Recalculate 't' for linear scale
        for(let i1 = 0; i1 < lengths.length; i1++){
            let w1 = this._waypoints[i1 + 1];
            w1.tNormalized = lengths[i1] / totalPathLength;
        }
        this._isNormalized = true;
        let newWayPoints = [];
        let tStep = 1 / nWayPoints;
        for(let t = 0; t < 1 + tStep; t += tStep){
            let w = this.at(t);
            w.t = w.tNormalized = t;
            newWayPoints.push(w);
        }
        this._waypoints = newWayPoints;
    }
    /**
   * Approximate the length of the way-point path
   * @param step the step size (0.0001 < step < 0.1)
   * @param startIndex the index of the first waypoint to measure from
   * @param endIndex the index of the last waypoint to measure to
   */ pathLength(step, startIndex, endIndex) {
        let l = 0;
        let si = (startIndex || 0) / (this._waypoints.length - 1);
        let ei = (endIndex || this._waypoints.length - 1) / (this._waypoints.length - 1);
        let d = new _three.Vector3();
        step = Math.min(Math.max(step || WayPointPath.DEFAULT_STEP, 0.0001), 0.1); // clamp the step value
        let last;
        for(let t = si; t <= ei; t += step){
            let w = this.at(t);
            if (last) l += d.subVectors(w.position, last.position).length();
            last = w;
        }
        return l;
    }
    reset() {
        this._current = 0;
    }
    // #region Private Methods (2)
    _at(t) {
        let ti = t * (this._waypoints.length - 1);
        let t1 = this._current = Math.floor(ti);
        let t2 = Math.ceil(ti);
        if (t1 === t2 || t2 >= this._waypoints.length) return this._waypoints[t1];
        let w0 = this._waypoints[Math.max(t1 - 1, 0)];
        let w1 = this._waypoints[t1];
        let w2 = this._waypoints[t2];
        let w3 = this._waypoints[Math.min(t2 + 1, this._waypoints.length - 1)];
        let mu = ti - t1;
        let ip = Vector3CubicInterpolate([
            w0.position,
            w1.position,
            w2.position,
            w3.position
        ], mu);
        let id = Vector3CubicInterpolate([
            w0.direction,
            w1.direction,
            w2.direction,
            w3.direction
        ], mu);
        let ir = CubicInterpolate(w0.radius, w1.radius, w2.radius, w3.radius, mu);
        let iud = {};
        if (w0.userData && w1.userData && w2.userData && w3.userData) for(let prop in w0.userData){
            let p0 = w0.userData[prop];
            let p1 = w1.userData[prop];
            let p2 = w2.userData[prop];
            let p3 = w3.userData[prop];
            iud[prop] = CubicInterpolate(p0, p1, p2, p3, mu);
        }
        if (ip) return new _wayPointDefault.default(ip, id, ir, iud);
        return null;
    }
    denormalizeT(tNormalized) {
        let t = tNormalized;
        let idx = this._waypoints.findIndex((x)=>x.tNormalized >= t
        );
        if (idx > 0) {
            // If path has been normalised, translate 't' to normalised value
            let wp1 = this._waypoints[idx - 1];
            let wp2 = this._waypoints[idx];
            let m = (wp2.t - wp1.t) / (wp2.tNormalized - wp1.tNormalized);
            let c = wp1.t - m * wp1.tNormalized;
            t = m * t + c;
        }
        return t;
    }
}
exports.default = WayPointPath;
function CubicInterpolate(y0, y1, y2, y3, mu) {
    let mu2 = mu * mu;
    let mu3 = mu * mu * mu;
    let a0 = -0.5 * y0 + 1.5 * y1 - 1.5 * y2 + 0.5 * y3;
    let a1 = y0 - 2.5 * y1 + 2 * y2 - 0.5 * y3;
    let a2 = -0.5 * y0 + 0.5 * y2;
    let a3 = y1;
    return a0 * mu3 + a1 * mu2 + a2 * mu + a3;
}
function Vector3CubicInterpolate(points, mu) {
    if (points.length < 4) return;
    let r = new _three.Vector3();
    for(let n = 0; n < 3; n++){
        let c1 = points[0].getComponent(n);
        let c2 = points[1].getComponent(n);
        let c3 = points[2].getComponent(n);
        let c4 = points[3].getComponent(n);
        r.setComponent(n, CubicInterpolate(c1, c2, c3, c4, mu));
    }
    return r;
}

},{"three":"ktPTu","./WayPoint":"6Qt7J","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}],"6Qt7J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _three = require("three");
class WayPoint {
    // #region Properties (4)
    // #endregion Properties (4)
    // #region Constructors (1)
    constructor(position, direction, radius = 60, userData){
        this.position = position;
        this.direction = direction || new _three.Vector3();
        this.radius = radius;
        this.userData = userData;
    }
    // #region Public Methods (1)
    distanceTo(v) {
        return Math.max(Math.abs(this.position.distanceTo(v)) - this.radius, 0);
    }
}
exports.default = WayPoint;

},{"three":"ktPTu","@parcel/transformer-js/src/esmodule-helpers.js":"fwRQw"}]},["bq5lJ","h7u1C"], "h7u1C", "parcelRequire0d40")

//# sourceMappingURL=index.b71e74eb.js.map
